{
  "3000": "\n[3000] Maximum Area of Longest Diagonal Rectangle is on the run...\n\n\nYou are given a 2D 0-indexed integer array dimensions.\n\nFor all indices i, 0 <= i < dimensions.length, dimensions[i][0] represents the length and dimensions[i][1] represents the width of the rectangle i.\n\nReturn the area of the rectangle having the longest diagonal. If there are multiple rectangles with the longest diagonal, return the area of the rectangle having the maximum area.\n\n \nExample 1:\n\nInput: dimensions = [[9,3],[8,6]]\nOutput: 48\nExplanation: \nFor index = 0, length = 9 and width = 3. Diagonal length = sqrt(9 * 9 + 3 * 3) = sqrt(90) ≈ 9.487.\nFor index = 1, length = 8 and width = 6. Diagonal length = sqrt(8 * 8 + 6 * 6) = sqrt(100) = 10.\nSo, the rectangle at index 1 has a greater diagonal length therefore we return area = 8 * 6 = 48.\n\n\nExample 2:\n\nInput: dimensions = [[3,4],[4,3]]\nOutput: 12\nExplanation: Length of diagonal is the same for both which is 5, so maximum area = 12.\n\n\n \nConstraints:\n\n\n\t1 <= dimensions.length <= 100\n\tdimensions[i].length == 2\n\t1 <= dimensions[i][0], dimensions[i][1] <= 100\n\n\n",
  "3001": "\n[3001] Minimum Moves to Capture The Queen is on the run...\n\n\nThere is a 1-indexed 8 x 8 chessboard containing 3 pieces.\n\nYou are given 6 integers a, b, c, d, e, and f where:\n\n\n\t(a, b) denotes the position of the white rook.\n\t(c, d) denotes the position of the white bishop.\n\t(e, f) denotes the position of the black queen.\n\n\nGiven that you can only move the white pieces, return the minimum number of moves required to capture the black queen.\n\nNote that:\n\n\n\tRooks can move any number of squares either vertically or horizontally, but cannot jump over other pieces.\n\tBishops can move any number of squares diagonally, but cannot jump over other pieces.\n\tA rook or a bishop can capture the queen if it is located in a square that they can move to.\n\tThe queen does not move.\n\n\n \nExample 1:\n\nInput: a = 1, b = 1, c = 8, d = 8, e = 2, f = 3\nOutput: 2\nExplanation: We can capture the black queen in two moves by moving the white rook to (1, 3) then to (2, 3).\nIt is impossible to capture the black queen in less than two moves since it is not being attacked by any of the pieces at the beginning.\n\n\nExample 2:\n\nInput: a = 5, b = 3, c = 3, d = 4, e = 5, f = 2\nOutput: 1\nExplanation: We can capture the black queen in a single move by doing one of the following: \n- Move the white rook to (5, 2).\n- Move the white bishop to (5, 2).\n\n\n \nConstraints:\n\n\n\t1 <= a, b, c, d, e, f <= 8\n\tNo two pieces are on the same square.\n\n\n",
  "3002": "\n[3002] Maximum Size of a Set After Removals is on the run...\n\n\nYou are given two 0-indexed integer arrays nums1 and nums2 of even length n.\n\nYou must remove n / 2 elements from nums1 and n / 2 elements from nums2. After the removals, you insert the remaining elements of nums1 and nums2 into a set s.\n\nReturn the maximum possible size of the set s.\n\n \nExample 1:\n\nInput: nums1 = [1,2,1,2], nums2 = [1,1,1,1]\nOutput: 2\nExplanation: We remove two occurences of 1 from nums1 and nums2. After the removals, the arrays become equal to nums1 = [2,2] and nums2 = [1,1]. Therefore, s = {1,2}.\nIt can be shown that 2 is the maximum possible size of the set s after the removals.\n\n\nExample 2:\n\nInput: nums1 = [1,2,3,4,5,6], nums2 = [2,3,2,3,2,3]\nOutput: 5\nExplanation: We remove 2, 3, and 6 from nums1, as well as 2 and two occurrences of 3 from nums2. After the removals, the arrays become equal to nums1 = [1,4,5] and nums2 = [2,3,2]. Therefore, s = {1,2,3,4,5}.\nIt can be shown that 5 is the maximum possible size of the set s after the removals.\n\n\nExample 3:\n\nInput: nums1 = [1,1,2,2,3,3], nums2 = [4,4,5,5,6,6]\nOutput: 6\nExplanation: We remove 1, 2, and 3 from nums1, as well as 4, 5, and 6 from nums2. After the removals, the arrays become equal to nums1 = [1,2,3] and nums2 = [4,5,6]. Therefore, s = {1,2,3,4,5,6}.\nIt can be shown that 6 is the maximum possible size of the set s after the removals.\n\n\n \nConstraints:\n\n\n\tn == nums1.length == nums2.length\n\t1 <= n <= 2 * 10⁴\n\tn is even.\n\t1 <= nums1[i], nums2[i] <= 10⁹\n\n\n",
  "3003": "\n[3003] Maximize the Number of Partitions After Operations is on the run...\n\n\nYou are given a string s and an integer k.\n\nFirst, you are allowed to change at most one index in s to another lowercase English letter.\n\nAfter that, do the following partitioning operation until s is empty:\n\n\n\tChoose the longest prefix of s containing at most k distinct characters.\n\tDelete the prefix from s and increase the number of partitions by one. The remaining characters (if any) in s maintain their initial order.\n\n\nReturn an integer denoting the maximum number of resulting partitions after the operations by optimally choosing at most one index to change.\n\n \nExample 1:\n\n\nInput: s = \"accca\", k = 2\n\nOutput: 3\n\nExplanation:\n\nThe optimal way is to change s[2] to something other than a and c, for example, b. then it becomes \"acbca\".\n\nThen we perform the operations:\n\n\n\tThe longest prefix containing at most 2 distinct characters is \"ac\", we remove it and s becomes \"bca\".\n\tNow The longest prefix containing at most 2 distinct characters is \"bc\", so we remove it and s becomes \"a\".\n\tFinally, we remove \"a\" and s becomes empty, so the procedure ends.\n\n\nDoing the operations, the string is divided into 3 partitions, so the answer is 3.\n\n\nExample 2:\n\n\nInput: s = \"aabaab\", k = 3\n\nOutput: 1\n\nExplanation:\n\nInitially s contains 2 distinct characters, so whichever character we change, it will contain at most 3 distinct characters, so the longest prefix with at most 3 distinct characters would always be all of it, therefore the answer is 1.\n\n\nExample 3:\n\n\nInput: s = \"xxyz\", k = 1\n\nOutput: 4\n\nExplanation:\n\nThe optimal way is to change s[0] or s[1] to something other than characters in s, for example, to change s[0] to w.\n\nThen s becomes \"wxyz\", which consists of 4 distinct characters, so as k is 1, it will divide into 4 partitions.\n\n\n \nConstraints:\n\n\n\t1 <= s.length <= 10⁴\n\ts consists only of lowercase English letters.\n\t1 <= k <= 26\n\n\n",
  "3004": "\n[3004] Maximum Subtree of the Same Color is on the run...\n\n\nYou are given a 2D integer array edges representing a tree with n nodes, numbered from 0 to n - 1, rooted at node 0, where edges[i] = [ui, vi] means there is an edge between the nodes vi and ui.\n\nYou are also given a 0-indexed integer array colors of size n, where colors[i] is the color assigned to node i.\n\nWe want to find a node v such that every node in the subtree of v has the same color.\n\nReturn the size of such subtree with the maximum number of nodes possible.\n\n \n\n\nExample 1:\n\nInput: edges = [[0,1],[0,2],[0,3]], colors = [1,1,2,3]\nOutput: 1\nExplanation: Each color is represented as: 1 -> Red, 2 -> Green, 3 -> Blue. We can see that the subtree rooted at node 0 has children with different colors. Any other subtree is of the same color and has a size of 1. Hence, we return 1.\n\n\nExample 2:\n\nInput: edges = [[0,1],[0,2],[0,3]], colors = [1,1,1,1]\nOutput: 4\nExplanation: The whole tree has the same color, and the subtree rooted at node 0 has the most number of nodes which is 4. Hence, we return 4.\n\n\n\n\nExample 3:\n\nInput: edges = [[0,1],[0,2],[2,3],[2,4]], colors = [1,2,3,3,3]\nOutput: 3\nExplanation: Each color is represented as: 1 -> Red, 2 -> Green, 3 -> Blue. We can see that the subtree rooted at node 0 has children with different colors. Any other subtree is of the same color, but the subtree rooted at node 2 has a size of 3 which is the maximum. Hence, we return 3.\n\n\n \nConstraints:\n\n\n\tn == edges.length + 1\n\t1 <= n <= 5 * 10⁴\n\tedges[i] == [ui, vi]\n\t0 <= ui, vi < n\n\tcolors.length == n\n\t1 <= colors[i] <= 10⁵\n\tThe input is generated such that the graph represented by edges is a tree.\n\n\n",
  "3005": "\n[3005] Count Elements With Maximum Frequency is on the run...\n\n\nYou are given an array nums consisting of positive integers.\n\nReturn the total frequencies of elements in nums such that those elements all have the maximum frequency.\n\nThe frequency of an element is the number of occurrences of that element in the array.\n\n \nExample 1:\n\nInput: nums = [1,2,2,3,1,4]\nOutput: 4\nExplanation: The elements 1 and 2 have a frequency of 2 which is the maximum frequency in the array.\nSo the number of elements in the array with maximum frequency is 4.\n\n\nExample 2:\n\nInput: nums = [1,2,3,4,5]\nOutput: 5\nExplanation: All elements of the array have a frequency of 1 which is the maximum.\nSo the number of elements in the array with maximum frequency is 5.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 100\n\t1 <= nums[i] <= 100\n\n\n",
  "3006": "\n[3006] Find Beautiful Indices in the Given Array I is on the run...\n\n\nYou are given a 0-indexed string s, a string a, a string b, and an integer k.\n\nAn index i is beautiful if:\n\n\n\t0 <= i <= s.length - a.length\n\ts[i..(i + a.length - 1)] == a\n\tThere exists an index j such that:\n\t\n\t\t0 <= j <= s.length - b.length\n\t\ts[j..(j + b.length - 1)] == b\n\t\t|j - i| <= k\n\t\n\t\n\n\nReturn the array that contains beautiful indices in sorted order from smallest to largest.\n\n \nExample 1:\n\nInput: s = \"isawsquirrelnearmysquirrelhouseohmy\", a = \"my\", b = \"squirrel\", k = 15\nOutput: [16,33]\nExplanation: There are 2 beautiful indices: [16,33].\n- The index 16 is beautiful as s[16..17] == \"my\" and there exists an index 4 with s[4..11] == \"squirrel\" and |16 - 4| <= 15.\n- The index 33 is beautiful as s[33..34] == \"my\" and there exists an index 18 with s[18..25] == \"squirrel\" and |33 - 18| <= 15.\nThus we return [16,33] as the result.\n\n\nExample 2:\n\nInput: s = \"abcd\", a = \"a\", b = \"a\", k = 4\nOutput: [0]\nExplanation: There is 1 beautiful index: [0].\n- The index 0 is beautiful as s[0..0] == \"a\" and there exists an index 0 with s[0..0] == \"a\" and |0 - 0| <= 4.\nThus we return [0] as the result.\n\n\n \nConstraints:\n\n\n\t1 <= k <= s.length <= 10⁵\n\t1 <= a.length, b.length <= 10\n\ts, a, and b contain only lowercase English letters.\n\n\n",
  "3007": "\n[3007] Maximum Number That Sum of the Prices Is Less Than or Equal to K is on the run...\n\n\nYou are given an integer k and an integer x. The price of a number num is calculated by the count of set bits at positions x, 2x, 3x, etc., in its binary representation, starting from the least significant bit. The following table contains examples of how price is calculated.\n\n\n\t\n\t\t\n\t\t\tx\n\t\t\tnum\n\t\t\tBinary Representation\n\t\t\tPrice\n\t\t\n\t\t\n\t\t\t1\n\t\t\t13\n\t\t\t000001101\n\t\t\t3\n\t\t\n\t\t\n\t\t\t2\n\t\t\t13\n\t\t\t000001101\n\t\t\t1\n\t\t\n\t\t\n\t\t\t2\n\t\t\t233\n\t\t\t011101001\n\t\t\t3\n\t\t\n\t\t\n\t\t\t3\n\t\t\t13\n\t\t\t000001101\n\t\t\t1\n\t\t\n\t\t\n\t\t\t3\n\t\t\t362\n\t\t\t101101010\n\t\t\t2\n\t\t\n\t\n\n\nThe accumulated price of num is the total price of numbers from 1 to num. num is considered cheap if its accumulated price is less than or equal to k.\n\nReturn the greatest cheap number.\n\n \nExample 1:\n\n\nInput: k = 9, x = 1\n\nOutput: 6\n\nExplanation:\n\nAs shown in the table below, 6 is the greatest cheap number.\n\n\n\t\n\t\t\n\t\t\tx\n\t\t\tnum\n\t\t\tBinary Representation\n\t\t\tPrice\n\t\t\tAccumulated Price\n\t\t\n\t\t\n\t\t\t1\n\t\t\t1\n\t\t\t001\n\t\t\t1\n\t\t\t1\n\t\t\n\t\t\n\t\t\t1\n\t\t\t2\n\t\t\t010\n\t\t\t1\n\t\t\t2\n\t\t\n\t\t\n\t\t\t1\n\t\t\t3\n\t\t\t011\n\t\t\t2\n\t\t\t4\n\t\t\n\t\t\n\t\t\t1\n\t\t\t4\n\t\t\t100\n\t\t\t1\n\t\t\t5\n\t\t\n\t\t\n\t\t\t1\n\t\t\t5\n\t\t\t101\n\t\t\t2\n\t\t\t7\n\t\t\n\t\t\n\t\t\t1\n\t\t\t6\n\t\t\t110\n\t\t\t2\n\t\t\t9\n\t\t\n\t\t\n\t\t\t1\n\t\t\t7\n\t\t\t111\n\t\t\t3\n\t\t\t12\n\t\t\n\t\n\n\n\nExample 2:\n\n\nInput: k = 7, x = 2\n\nOutput: 9\n\nExplanation:\n\nAs shown in the table below, 9 is the greatest cheap number.\n\n\n\t\n\t\t\n\t\t\tx\n\t\t\tnum\n\t\t\tBinary Representation\n\t\t\tPrice\n\t\t\tAccumulated Price\n\t\t\n\t\t\n\t\t\t2\n\t\t\t1\n\t\t\t0001\n\t\t\t0\n\t\t\t0\n\t\t\n\t\t\n\t\t\t2\n\t\t\t2\n\t\t\t0010\n\t\t\t1\n\t\t\t1\n\t\t\n\t\t\n\t\t\t2\n\t\t\t3\n\t\t\t0011\n\t\t\t1\n\t\t\t2\n\t\t\n\t\t\n\t\t\t2\n\t\t\t4\n\t\t\t0100\n\t\t\t0\n\t\t\t2\n\t\t\n\t\t\n\t\t\t2\n\t\t\t5\n\t\t\t0101\n\t\t\t0\n\t\t\t2\n\t\t\n\t\t\n\t\t\t2\n\t\t\t6\n\t\t\t0110\n\t\t\t1\n\t\t\t3\n\t\t\n\t\t\n\t\t\t2\n\t\t\t7\n\t\t\t0111\n\t\t\t1\n\t\t\t4\n\t\t\n\t\t\n\t\t\t2\n\t\t\t8\n\t\t\t1000\n\t\t\t1\n\t\t\t5\n\t\t\n\t\t\n\t\t\t2\n\t\t\t9\n\t\t\t1001\n\t\t\t1\n\t\t\t6\n\t\t\n\t\t\n\t\t\t2\n\t\t\t10\n\t\t\t1010\n\t\t\t2\n\t\t\t8\n\t\t\n\t\n\n\n\n \nConstraints:\n\n\n\t1 <= k <= 10¹⁵\n\t1 <= x <= 8\n\n\n",
  "3008": "\n[3008] Find Beautiful Indices in the Given Array II is on the run...\n\n\nYou are given a 0-indexed string s, a string a, a string b, and an integer k.\n\nAn index i is beautiful if:\n\n\n\t0 <= i <= s.length - a.length\n\ts[i..(i + a.length - 1)] == a\n\tThere exists an index j such that:\n\t\n\t\t0 <= j <= s.length - b.length\n\t\ts[j..(j + b.length - 1)] == b\n\t\t|j - i| <= k\n\t\n\t\n\n\nReturn the array that contains beautiful indices in sorted order from smallest to largest.\n\n \nExample 1:\n\nInput: s = \"isawsquirrelnearmysquirrelhouseohmy\", a = \"my\", b = \"squirrel\", k = 15\nOutput: [16,33]\nExplanation: There are 2 beautiful indices: [16,33].\n- The index 16 is beautiful as s[16..17] == \"my\" and there exists an index 4 with s[4..11] == \"squirrel\" and |16 - 4| <= 15.\n- The index 33 is beautiful as s[33..34] == \"my\" and there exists an index 18 with s[18..25] == \"squirrel\" and |33 - 18| <= 15.\nThus we return [16,33] as the result.\n\n\nExample 2:\n\nInput: s = \"abcd\", a = \"a\", b = \"a\", k = 4\nOutput: [0]\nExplanation: There is 1 beautiful index: [0].\n- The index 0 is beautiful as s[0..0] == \"a\" and there exists an index 0 with s[0..0] == \"a\" and |0 - 0| <= 4.\nThus we return [0] as the result.\n\n\n \nConstraints:\n\n\n\t1 <= k <= s.length <= 5 * 10⁵\n\t1 <= a.length, b.length <= 5 * 10⁵\n\ts, a, and b contain only lowercase English letters.\n\n\n",
  "3009": "\n[3009] Maximum Number of Intersections on the Chart is on the run...\n\n\nThere is a line chart consisting of n points connected by line segments. You are given a 1-indexed integer array y. The kth point has coordinates (k, y[k]). There are no horizontal lines; that is, no two consecutive points have the same y-coordinate.\n\nWe can draw an infinitely long horizontal line. Return the maximum number of points of intersection of the line with the chart.\n\n \nExample 1:\n\n\nInput: y = [1,2,1,2,1,3,2]\nOutput: 5\nExplanation: As you can see in the image above, the line y = 1.5 has 5 intersections with the chart (in red crosses). You can also see the line y = 2 which intersects the chart in 4 points (in red crosses). It can be shown that there is no horizontal line intersecting the chart at more than 5 points. So the answer would be 5.\n\n\nExample 2:\n\n\nInput: y = [2,1,3,4,5]\nOutput: 2\nExplanation: As you can see in the image above, the line y = 1.5 has 2 intersections with the chart (in red crosses). You can also see the line y = 2 which intersects the chart in 2 points (in red crosses). It can be shown that there is no horizontal line intersecting the chart at more than 2 points. So the answer would be 2.\n\n\n \nConstraints:\n\n\n\t2 <= y.length <= 10⁵\n\t1 <= y[i] <= 10⁹\n\ty[i] != y[i + 1] for i in range [1, n - 1]\n\n\n",
  "3010": "\n[3010] Divide an Array Into Subarrays With Minimum Cost I is on the run...\n\n\nYou are given an array of integers nums of length n.\n\nThe cost of an array is the value of its first element. For example, the cost of [1,2,3] is 1 while the cost of [3,4,1] is 3.\n\nYou need to divide nums into 3 disjoint contiguous subarrays.\n\nReturn the minimum possible sum of the cost of these subarrays.\n\n \nExample 1:\n\nInput: nums = [1,2,3,12]\nOutput: 6\nExplanation: The best possible way to form 3 subarrays is: [1], [2], and [3,12] at a total cost of 1 + 2 + 3 = 6.\nThe other possible ways to form 3 subarrays are:\n- [1], [2,3], and [12] at a total cost of 1 + 2 + 12 = 15.\n- [1,2], [3], and [12] at a total cost of 1 + 3 + 12 = 16.\n\n\nExample 2:\n\nInput: nums = [5,4,3]\nOutput: 12\nExplanation: The best possible way to form 3 subarrays is: [5], [4], and [3] at a total cost of 5 + 4 + 3 = 12.\nIt can be shown that 12 is the minimum cost achievable.\n\n\nExample 3:\n\nInput: nums = [10,3,1,1]\nOutput: 12\nExplanation: The best possible way to form 3 subarrays is: [10,3], [1], and [1] at a total cost of 10 + 1 + 1 = 12.\nIt can be shown that 12 is the minimum cost achievable.\n\n\n \nConstraints:\n\n\n\t3 <= n <= 50\n\t1 <= nums[i] <= 50\n\n\n",
  "3011": "\n[3011] Find if Array Can Be Sorted is on the run...\n\n\nYou are given a 0-indexed array of positive integers nums.\n\nIn one operation, you can swap any two adjacent elements if they have the same number of set bits. You are allowed to do this operation any number of times (including zero).\n\nReturn true if you can sort the array in ascending order, else return false.\n\n \nExample 1:\n\nInput: nums = [8,4,2,30,15]\nOutput: true\nExplanation: Let's look at the binary representation of every element. The numbers 2, 4, and 8 have one set bit each with binary representation \"10\", \"100\", and \"1000\" respectively. The numbers 15 and 30 have four set bits each with binary representation \"1111\" and \"11110\".\nWe can sort the array using 4 operations:\n- Swap nums[0] with nums[1]. This operation is valid because 8 and 4 have one set bit each. The array becomes [4,8,2,30,15].\n- Swap nums[1] with nums[2]. This operation is valid because 8 and 2 have one set bit each. The array becomes [4,2,8,30,15].\n- Swap nums[0] with nums[1]. This operation is valid because 4 and 2 have one set bit each. The array becomes [2,4,8,30,15].\n- Swap nums[3] with nums[4]. This operation is valid because 30 and 15 have four set bits each. The array becomes [2,4,8,15,30].\nThe array has become sorted, hence we return true.\nNote that there may be other sequences of operations which also sort the array.\n\n\nExample 2:\n\nInput: nums = [1,2,3,4,5]\nOutput: true\nExplanation: The array is already sorted, hence we return true.\n\n\nExample 3:\n\nInput: nums = [3,16,8,4,2]\nOutput: false\nExplanation: It can be shown that it is not possible to sort the input array using any number of operations.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 100\n\t1 <= nums[i] <= 2⁸\n\n\n",
  "3012": "\n[3012] Minimize Length of Array Using Operations is on the run...\n\n\nYou are given a 0-indexed integer array nums containing positive integers.\n\nYour task is to minimize the length of nums by performing the following operations any number of times (including zero):\n\n\n\tSelect two distinct indices i and j from nums, such that nums[i] > 0 and nums[j] > 0.\n\tInsert the result of nums[i] % nums[j] at the end of nums.\n\tDelete the elements at indices i and j from nums.\n\n\nReturn an integer denoting the minimum length of nums after performing the operation any number of times.\n\n \nExample 1:\n\nInput: nums = [1,4,3,1]\nOutput: 1\nExplanation: One way to minimize the length of the array is as follows:\nOperation 1: Select indices 2 and 1, insert nums[2] % nums[1] at the end and it becomes [1,4,3,1,3], then delete elements at indices 2 and 1.\nnums becomes [1,1,3].\nOperation 2: Select indices 1 and 2, insert nums[1] % nums[2] at the end and it becomes [1,1,3,1], then delete elements at indices 1 and 2.\nnums becomes [1,1].\nOperation 3: Select indices 1 and 0, insert nums[1] % nums[0] at the end and it becomes [1,1,0], then delete elements at indices 1 and 0.\nnums becomes [0].\nThe length of nums cannot be reduced further. Hence, the answer is 1.\nIt can be shown that 1 is the minimum achievable length. \n\nExample 2:\n\nInput: nums = [5,5,5,10,5]\nOutput: 2\nExplanation: One way to minimize the length of the array is as follows:\nOperation 1: Select indices 0 and 3, insert nums[0] % nums[3] at the end and it becomes [5,5,5,10,5,5], then delete elements at indices 0 and 3.\nnums becomes [5,5,5,5]. \nOperation 2: Select indices 2 and 3, insert nums[2] % nums[3] at the end and it becomes [5,5,5,5,0], then delete elements at indices 2 and 3. \nnums becomes [5,5,0]. \nOperation 3: Select indices 0 and 1, insert nums[0] % nums[1] at the end and it becomes [5,5,0,0], then delete elements at indices 0 and 1.\nnums becomes [0,0].\nThe length of nums cannot be reduced further. Hence, the answer is 2.\nIt can be shown that 2 is the minimum achievable length. \n\nExample 3:\n\nInput: nums = [2,3,4]\nOutput: 1\nExplanation: One way to minimize the length of the array is as follows: \nOperation 1: Select indices 1 and 2, insert nums[1] % nums[2] at the end and it becomes [2,3,4,3], then delete elements at indices 1 and 2.\nnums becomes [2,3].\nOperation 2: Select indices 1 and 0, insert nums[1] % nums[0] at the end and it becomes [2,3,1], then delete elements at indices 1 and 0.\nnums becomes [1].\nThe length of nums cannot be reduced further. Hence, the answer is 1.\nIt can be shown that 1 is the minimum achievable length.\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 10⁵\n\t1 <= nums[i] <= 10⁹\n\n\n",
  "3013": "\n[3013] Divide an Array Into Subarrays With Minimum Cost II is on the run...\n\n\nYou are given a 0-indexed array of integers nums of length n, and two positive integers k and dist.\n\nThe cost of an array is the value of its first element. For example, the cost of [1,2,3] is 1 while the cost of [3,4,1] is 3.\n\nYou need to divide nums into k disjoint contiguous subarrays, such that the difference between the starting index of the second subarray and the starting index of the kth subarray should be less than or equal to dist. In other words, if you divide nums into the subarrays nums[0..(i₁ - 1)], nums[i₁..(i₂ - 1)], ..., nums[ik-1..(n - 1)], then ik-1 - i₁ <= dist.\n\nReturn the minimum possible sum of the cost of these subarrays.\n\n \nExample 1:\n\nInput: nums = [1,3,2,6,4,2], k = 3, dist = 3\nOutput: 5\nExplanation: The best possible way to divide nums into 3 subarrays is: [1,3], [2,6,4], and [2]. This choice is valid because ik-1 - i₁ is 5 - 2 = 3 which is equal to dist. The total cost is nums[0] + nums[2] + nums[5] which is 1 + 2 + 2 = 5.\nIt can be shown that there is no possible way to divide nums into 3 subarrays at a cost lower than 5.\n\n\nExample 2:\n\nInput: nums = [10,1,2,2,2,1], k = 4, dist = 3\nOutput: 15\nExplanation: The best possible way to divide nums into 4 subarrays is: [10], [1], [2], and [2,2,1]. This choice is valid because ik-1 - i₁ is 3 - 1 = 2 which is less than dist. The total cost is nums[0] + nums[1] + nums[2] + nums[3] which is 10 + 1 + 2 + 2 = 15.\nThe division [10], [1], [2,2,2], and [1] is not valid, because the difference between ik-1 and i₁ is 5 - 1 = 4, which is greater than dist.\nIt can be shown that there is no possible way to divide nums into 4 subarrays at a cost lower than 15.\n\n\nExample 3:\n\nInput: nums = [10,8,18,9], k = 3, dist = 1\nOutput: 36\nExplanation: The best possible way to divide nums into 4 subarrays is: [10], [8], and [18,9]. This choice is valid because ik-1 - i₁ is 2 - 1 = 1 which is equal to dist.The total cost is nums[0] + nums[1] + nums[2] which is 10 + 8 + 18 = 36.\nThe division [10], [8,18], and [9] is not valid, because the difference between ik-1 and i₁ is 3 - 1 = 2, which is greater than dist.\nIt can be shown that there is no possible way to divide nums into 3 subarrays at a cost lower than 36.\n\n\n \nConstraints:\n\n\n\t3 <= n <= 10⁵\n\t1 <= nums[i] <= 10⁹\n\t3 <= k <= n\n\tk - 2 <= dist <= n - 2\n\n\n",
  "3014": "\n[3014] Minimum Number of Pushes to Type Word I is on the run...\n\n\nYou are given a string word containing distinct lowercase English letters.\n\nTelephone keypads have keys mapped with distinct collections of lowercase English letters, which can be used to form words by pushing them. For example, the key 2 is mapped with [\"a\",\"b\",\"c\"], we need to push the key one time to type \"a\", two times to type \"b\", and three times to type \"c\" .\n\nIt is allowed to remap the keys numbered 2 to 9 to distinct collections of letters. The keys can be remapped to any amount of letters, but each letter must be mapped to exactly one key. You need to find the minimum number of times the keys will be pushed to type the string word.\n\nReturn the minimum number of pushes needed to type word after remapping the keys.\n\nAn example mapping of letters to keys on a telephone keypad is given below. Note that 1, *, #, and 0 do not map to any letters.\n\n \nExample 1:\n\nInput: word = \"abcde\"\nOutput: 5\nExplanation: The remapped keypad given in the image provides the minimum cost.\n\"a\" -> one push on key 2\n\"b\" -> one push on key 3\n\"c\" -> one push on key 4\n\"d\" -> one push on key 5\n\"e\" -> one push on key 6\nTotal cost is 1 + 1 + 1 + 1 + 1 = 5.\nIt can be shown that no other mapping can provide a lower cost.\n\n\nExample 2:\n\nInput: word = \"xycdefghij\"\nOutput: 12\nExplanation: The remapped keypad given in the image provides the minimum cost.\n\"x\" -> one push on key 2\n\"y\" -> two pushes on key 2\n\"c\" -> one push on key 3\n\"d\" -> two pushes on key 3\n\"e\" -> one push on key 4\n\"f\" -> one push on key 5\n\"g\" -> one push on key 6\n\"h\" -> one push on key 7\n\"i\" -> one push on key 8\n\"j\" -> one push on key 9\nTotal cost is 1 + 2 + 1 + 2 + 1 + 1 + 1 + 1 + 1 + 1 = 12.\nIt can be shown that no other mapping can provide a lower cost.\n\n\n \nConstraints:\n\n\n\t1 <= word.length <= 26\n\tword consists of lowercase English letters.\n\tAll letters in word are distinct.\n\n\n",
  "3015": "\n[3015] Count the Number of Houses at a Certain Distance I is on the run...\n\n\nYou are given three positive integers n, x, and y.\n\nIn a city, there exist houses numbered 1 to n connected by n streets. There is a street connecting the house numbered i with the house numbered i + 1 for all 1 <= i <= n - 1 . An additional street connects the house numbered x with the house numbered y.\n\nFor each k, such that 1 <= k <= n, you need to find the number of pairs of houses (house₁, house₂) such that the minimum number of streets that need to be traveled to reach house₂ from house₁ is k.\n\nReturn a 1-indexed array result of length n where result[k] represents the total number of pairs of houses such that the minimum streets required to reach one house from the other is k.\n\nNote that x and y can be equal.\n\n \nExample 1:\n\nInput: n = 3, x = 1, y = 3\nOutput: [6,0,0]\nExplanation: Let's look at each pair of houses:\n- For the pair (1, 2), we can go from house 1 to house 2 directly.\n- For the pair (2, 1), we can go from house 2 to house 1 directly.\n- For the pair (1, 3), we can go from house 1 to house 3 directly.\n- For the pair (3, 1), we can go from house 3 to house 1 directly.\n- For the pair (2, 3), we can go from house 2 to house 3 directly.\n- For the pair (3, 2), we can go from house 3 to house 2 directly.\n\n\nExample 2:\n\nInput: n = 5, x = 2, y = 4\nOutput: [10,8,2,0,0]\nExplanation: For each distance k the pairs are:\n- For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (2, 4), (4, 2), (3, 4), (4, 3), (4, 5), and (5, 4).\n- For k == 2, the pairs are (1, 3), (3, 1), (1, 4), (4, 1), (2, 5), (5, 2), (3, 5), and (5, 3).\n- For k == 3, the pairs are (1, 5), and (5, 1).\n- For k == 4 and k == 5, there are no pairs.\n\n\nExample 3:\n\nInput: n = 4, x = 1, y = 1\nOutput: [6,4,2,0]\nExplanation: For each distance k the pairs are:\n- For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (3, 4), and (4, 3).\n- For k == 2, the pairs are (1, 3), (3, 1), (2, 4), and (4, 2).\n- For k == 3, the pairs are (1, 4), and (4, 1).\n- For k == 4, there are no pairs.\n\n\n \nConstraints:\n\n\n\t2 <= n <= 100\n\t1 <= x, y <= n\n\n\n",
  "3016": "\n[3016] Minimum Number of Pushes to Type Word II is on the run...\n\n\nYou are given a string word containing lowercase English letters.\n\nTelephone keypads have keys mapped with distinct collections of lowercase English letters, which can be used to form words by pushing them. For example, the key 2 is mapped with [\"a\",\"b\",\"c\"], we need to push the key one time to type \"a\", two times to type \"b\", and three times to type \"c\" .\n\nIt is allowed to remap the keys numbered 2 to 9 to distinct collections of letters. The keys can be remapped to any amount of letters, but each letter must be mapped to exactly one key. You need to find the minimum number of times the keys will be pushed to type the string word.\n\nReturn the minimum number of pushes needed to type word after remapping the keys.\n\nAn example mapping of letters to keys on a telephone keypad is given below. Note that 1, *, #, and 0 do not map to any letters.\n\n \nExample 1:\n\nInput: word = \"abcde\"\nOutput: 5\nExplanation: The remapped keypad given in the image provides the minimum cost.\n\"a\" -> one push on key 2\n\"b\" -> one push on key 3\n\"c\" -> one push on key 4\n\"d\" -> one push on key 5\n\"e\" -> one push on key 6\nTotal cost is 1 + 1 + 1 + 1 + 1 = 5.\nIt can be shown that no other mapping can provide a lower cost.\n\n\nExample 2:\n\nInput: word = \"xyzxyzxyzxyz\"\nOutput: 12\nExplanation: The remapped keypad given in the image provides the minimum cost.\n\"x\" -> one push on key 2\n\"y\" -> one push on key 3\n\"z\" -> one push on key 4\nTotal cost is 1 * 4 + 1 * 4 + 1 * 4 = 12\nIt can be shown that no other mapping can provide a lower cost.\nNote that the key 9 is not mapped to any letter: it is not necessary to map letters to every key, but to map all the letters.\n\n\nExample 3:\n\nInput: word = \"aabbccddeeffgghhiiiiii\"\nOutput: 24\nExplanation: The remapped keypad given in the image provides the minimum cost.\n\"a\" -> one push on key 2\n\"b\" -> one push on key 3\n\"c\" -> one push on key 4\n\"d\" -> one push on key 5\n\"e\" -> one push on key 6\n\"f\" -> one push on key 7\n\"g\" -> one push on key 8\n\"h\" -> two pushes on key 9\n\"i\" -> one push on key 9\nTotal cost is 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 1 * 2 + 2 * 2 + 6 * 1 = 24.\nIt can be shown that no other mapping can provide a lower cost.\n\n\n \nConstraints:\n\n\n\t1 <= word.length <= 10⁵\n\tword consists of lowercase English letters.\n\n\n",
  "3017": "\n[3017] Count the Number of Houses at a Certain Distance II is on the run...\n\n\nYou are given three positive integers n, x, and y.\n\nIn a city, there exist houses numbered 1 to n connected by n streets. There is a street connecting the house numbered i with the house numbered i + 1 for all 1 <= i <= n - 1 . An additional street connects the house numbered x with the house numbered y.\n\nFor each k, such that 1 <= k <= n, you need to find the number of pairs of houses (house₁, house₂) such that the minimum number of streets that need to be traveled to reach house₂ from house₁ is k.\n\nReturn a 1-indexed array result of length n where result[k] represents the total number of pairs of houses such that the minimum streets required to reach one house from the other is k.\n\nNote that x and y can be equal.\n\n \nExample 1:\n\nInput: n = 3, x = 1, y = 3\nOutput: [6,0,0]\nExplanation: Let's look at each pair of houses:\n- For the pair (1, 2), we can go from house 1 to house 2 directly.\n- For the pair (2, 1), we can go from house 2 to house 1 directly.\n- For the pair (1, 3), we can go from house 1 to house 3 directly.\n- For the pair (3, 1), we can go from house 3 to house 1 directly.\n- For the pair (2, 3), we can go from house 2 to house 3 directly.\n- For the pair (3, 2), we can go from house 3 to house 2 directly.\n\n\nExample 2:\n\nInput: n = 5, x = 2, y = 4\nOutput: [10,8,2,0,0]\nExplanation: For each distance k the pairs are:\n- For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (2, 4), (4, 2), (3, 4), (4, 3), (4, 5), and (5, 4).\n- For k == 2, the pairs are (1, 3), (3, 1), (1, 4), (4, 1), (2, 5), (5, 2), (3, 5), and (5, 3).\n- For k == 3, the pairs are (1, 5), and (5, 1).\n- For k == 4 and k == 5, there are no pairs.\n\n\nExample 3:\n\nInput: n = 4, x = 1, y = 1\nOutput: [6,4,2,0]\nExplanation: For each distance k the pairs are:\n- For k == 1, the pairs are (1, 2), (2, 1), (2, 3), (3, 2), (3, 4), and (4, 3).\n- For k == 2, the pairs are (1, 3), (3, 1), (2, 4), and (4, 2).\n- For k == 3, the pairs are (1, 4), and (4, 1).\n- For k == 4, there are no pairs.\n\n\n \nConstraints:\n\n\n\t2 <= n <= 10⁵\n\t1 <= x, y <= n\n\n\n",
  "3018": "\n[3018] Maximum Number of Removal Queries That Can Be Processed I is on the run...\n\n\nYou are given a 0-indexed array nums and a 0-indexed array queries.\n\nYou can do the following operation at the beginning at most once:\n\n\n\tReplace nums with a subsequence of nums.\n\n\nWe start processing queries in the given order; for each query, we do the following:\n\n\n\tIf the first and the last element of nums is less than queries[i], the processing of queries ends.\n\tOtherwise, we choose either the first or the last element of nums if it is greater than or equal to queries[i], and we remove the chosen element from nums.\n\n\nReturn the maximum number of queries that can be processed by doing the operation optimally.\n\n \nExample 1:\n\nInput: nums = [1,2,3,4,5], queries = [1,2,3,4,6]\nOutput: 4\nExplanation: We don't do any operation and process the queries as follows:\n1- We choose and remove nums[0] since 1 <= 1, then nums becomes [2,3,4,5].\n2- We choose and remove nums[0] since 2 <= 2, then nums becomes [3,4,5].\n3- We choose and remove nums[0] since 3 <= 3, then nums becomes [4,5].\n4- We choose and remove nums[0] since 4 <= 4, then nums becomes [5].\n5- We can not choose any elements from nums since they are not greater than or equal to 5.\nHence, the answer is 4.\nIt can be shown that we can't process more than 4 queries.\n\n\nExample 2:\n\nInput: nums = [2,3,2], queries = [2,2,3]\nOutput: 3\nExplanation: We don't do any operation and process the queries as follows:\n1- We choose and remove nums[0] since 2 <= 2, then nums becomes [3,2].\n2- We choose and remove nums[1] since 2 <= 2, then nums becomes [3].\n3- We choose and remove nums[0] since 3 <= 3, then nums becomes [].\nHence, the answer is 3.\nIt can be shown that we can't process more than 3 queries.\n\n\nExample 3:\n\nInput: nums = [3,4,3], queries = [4,3,2]\nOutput: 2\nExplanation: First we replace nums with the subsequence of nums [4,3].\nThen we can process the queries as follows:\n1- We choose and remove nums[0] since 4 <= 4, then nums becomes [3].\n2- We choose and remove nums[0] since 3 <= 3, then nums becomes [].\n3- We can not process any more queries since nums is empty.\nHence, the answer is 2.\nIt can be shown that we can't process more than 2 queries.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 1000\n\t1 <= queries.length <= 1000\n\t1 <= nums[i], queries[i] <= 10⁹\n\n\n",
  "3019": "\n[3019] Number of Changing Keys is on the run...\n\n\nYou are given a 0-indexed string s typed by a user. Changing a key is defined as using a key different from the last used key. For example, s = \"ab\" has a change of a key while s = \"bBBb\" does not have any.\n\nReturn the number of times the user had to change the key. \n\nNote: Modifiers like shift or caps lock won't be counted in changing the key that is if a user typed the letter 'a' and then the letter 'A' then it will not be considered as a changing of key.\n\n \nExample 1:\n\nInput: s = \"aAbBcC\"\nOutput: 2\nExplanation: \nFrom s[0] = 'a' to s[1] = 'A', there is no change of key as caps lock or shift is not counted.\nFrom s[1] = 'A' to s[2] = 'b', there is a change of key.\nFrom s[2] = 'b' to s[3] = 'B', there is no change of key as caps lock or shift is not counted.\nFrom s[3] = 'B' to s[4] = 'c', there is a change of key.\nFrom s[4] = 'c' to s[5] = 'C', there is no change of key as caps lock or shift is not counted.\n\n\n\nExample 2:\n\nInput: s = \"AaAaAaaA\"\nOutput: 0\nExplanation: There is no change of key since only the letters 'a' and 'A' are pressed which does not require change of key.\n\n\n \nConstraints:\n\n\n\t1 <= s.length <= 100\n\ts consists of only upper case and lower case English letters.\n\n\n",
  "3020": "\n[3020] Find the Maximum Number of Elements in Subset is on the run...\n\n\nYou are given an array of positive integers nums.\n\nYou need to select a subset of nums which satisfies the following condition:\n\n\n\tYou can place the selected elements in a 0-indexed array such that it follows the pattern: [x, x², x⁴, ..., xk/2, xk, xk/2, ..., x⁴, x², x] (Note that k can be be any non-negative power of 2). For example, [2, 4, 16, 4, 2] and [3, 9, 3] follow the pattern while [2, 4, 8, 4, 2] does not.\n\n\nReturn the maximum number of elements in a subset that satisfies these conditions.\n\n \nExample 1:\n\nInput: nums = [5,4,1,2,2]\nOutput: 3\nExplanation: We can select the subset {4,2,2}, which can be placed in the array as [2,4,2] which follows the pattern and 2² == 4. Hence the answer is 3.\n\n\nExample 2:\n\nInput: nums = [1,3,2,4]\nOutput: 1\nExplanation: We can select the subset {1}, which can be placed in the array as [1] which follows the pattern. Hence the answer is 1. Note that we could have also selected the subsets {2}, {3}, or {4}, there may be multiple subsets which provide the same answer. \n\n\n \nConstraints:\n\n\n\t2 <= nums.length <= 10⁵\n\t1 <= nums[i] <= 10⁹\n\n\n",
  "3021": "\n[3021] Alice and Bob Playing Flower Game is on the run...\n\n\nAlice and Bob are playing a turn-based game on a circular field surrounded by flowers. The circle represents the field, and there are x flowers in the clockwise direction between Alice and Bob, and y flowers in the anti-clockwise direction between them.\n\nThe game proceeds as follows:\n\n\n\tAlice takes the first turn.\n\tIn each turn, a player must choose either the clockwise or anti-clockwise direction and pick one flower from that side.\n\tAt the end of the turn, if there are no flowers left at all, the current player captures their opponent and wins the game.\n\n\nGiven two integers, n and m, the task is to compute the number of possible pairs (x, y) that satisfy the conditions:\n\n\n\tAlice must win the game according to the described rules.\n\tThe number of flowers x in the clockwise direction must be in the range [1,n].\n\tThe number of flowers y in the anti-clockwise direction must be in the range [1,m].\n\n\nReturn the number of possible pairs (x, y) that satisfy the conditions mentioned in the statement.\n\n \nExample 1:\n\nInput: n = 3, m = 2\nOutput: 3\nExplanation: The following pairs satisfy conditions described in the statement: (1,2), (3,2), (2,1).\n\n\nExample 2:\n\nInput: n = 1, m = 1\nOutput: 0\nExplanation: No pairs satisfy the conditions described in the statement.\n\n\n \nConstraints:\n\n\n\t1 <= n, m <= 10⁵\n\n\n",
  "3022": "\n[3022] Minimize OR of Remaining Elements Using Operations is on the run...\n\n\nYou are given a 0-indexed integer array nums and an integer k.\n\nIn one operation, you can pick any index i of nums such that 0 <= i < nums.length - 1 and replace nums[i] and nums[i + 1] with a single occurrence of nums[i] & nums[i + 1], where & represents the bitwise AND operator.\n\nReturn the minimum possible value of the bitwise OR of the remaining elements of nums after applying at most k operations.\n\n \nExample 1:\n\nInput: nums = [3,5,3,2,7], k = 2\nOutput: 3\nExplanation: Let's do the following operations:\n1. Replace nums[0] and nums[1] with (nums[0] & nums[1]) so that nums becomes equal to [1,3,2,7].\n2. Replace nums[2] and nums[3] with (nums[2] & nums[3]) so that nums becomes equal to [1,3,2].\nThe bitwise-or of the final array is 3.\nIt can be shown that 3 is the minimum possible value of the bitwise OR of the remaining elements of nums after applying at most k operations.\n\nExample 2:\n\nInput: nums = [7,3,15,14,2,8], k = 4\nOutput: 2\nExplanation: Let's do the following operations:\n1. Replace nums[0] and nums[1] with (nums[0] & nums[1]) so that nums becomes equal to [3,15,14,2,8]. \n2. Replace nums[0] and nums[1] with (nums[0] & nums[1]) so that nums becomes equal to [3,14,2,8].\n3. Replace nums[0] and nums[1] with (nums[0] & nums[1]) so that nums becomes equal to [2,2,8].\n4. Replace nums[1] and nums[2] with (nums[1] & nums[2]) so that nums becomes equal to [2,0].\nThe bitwise-or of the final array is 2.\nIt can be shown that 2 is the minimum possible value of the bitwise OR of the remaining elements of nums after applying at most k operations.\n\n\nExample 3:\n\nInput: nums = [10,7,10,3,9,14,9,4], k = 1\nOutput: 15\nExplanation: Without applying any operations, the bitwise-or of nums is 15.\nIt can be shown that 15 is the minimum possible value of the bitwise OR of the remaining elements of nums after applying at most k operations.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 10⁵\n\t0 <= nums[i] < 2³⁰\n\t0 <= k < nums.length\n\n\n",
  "3023": "\n[3023] Find Pattern in Infinite Stream I is on the run...\n\n\nYou are given a binary array pattern and an object stream of class InfiniteStream representing a 0-indexed infinite stream of bits.\n\nThe class InfiniteStream contains the following function:\n\n\n\tint next(): Reads a single bit (which is either 0 or 1) from the stream and returns it.\n\n\nReturn the first starting index where the pattern matches the bits read from the stream. For example, if the pattern is [1, 0], the first match is the highlighted part in the stream [0, 1, 0, 1, ...].\n\n \nExample 1:\n\nInput: stream = [1,1,1,0,1,1,1,...], pattern = [0,1]\nOutput: 3\nExplanation: The first occurrence of the pattern [0,1] is highlighted in the stream [1,1,1,0,1,...], which starts at index 3.\n\n\nExample 2:\n\nInput: stream = [0,0,0,0,...], pattern = [0]\nOutput: 0\nExplanation: The first occurrence of the pattern [0] is highlighted in the stream [0,...], which starts at index 0.\n\n\nExample 3:\n\nInput: stream = [1,0,1,1,0,1,1,0,1,...], pattern = [1,1,0,1]\nOutput: 2\nExplanation: The first occurrence of the pattern [1,1,0,1] is highlighted in the stream [1,0,1,1,0,1,...], which starts at index 2.\n\n\n \nConstraints:\n\n\n\t1 <= pattern.length <= 100\n\tpattern consists only of 0 and 1.\n\tstream consists only of 0 and 1.\n\tThe input is generated such that the pattern's start index exists in the first 10⁵ bits of the stream.\n\n\n",
  "3024": "\n[3024] Type of Triangle is on the run...\n\n\nYou are given a 0-indexed integer array nums of size 3 which can form the sides of a triangle.\n\n\n\tA triangle is called equilateral if it has all sides of equal length.\n\tA triangle is called isosceles if it has exactly two sides of equal length.\n\tA triangle is called scalene if all its sides are of different lengths.\n\n\nReturn a string representing the type of triangle that can be formed or \"none\" if it cannot form a triangle.\n\n \nExample 1:\n\nInput: nums = [3,3,3]\nOutput: \"equilateral\"\nExplanation: Since all the sides are of equal length, therefore, it will form an equilateral triangle.\n\n\nExample 2:\n\nInput: nums = [3,4,5]\nOutput: \"scalene\"\nExplanation: \nnums[0] + nums[1] = 3 + 4 = 7, which is greater than nums[2] = 5.\nnums[0] + nums[2] = 3 + 5 = 8, which is greater than nums[1] = 4.\nnums[1] + nums[2] = 4 + 5 = 9, which is greater than nums[0] = 3. \nSince the sum of the two sides is greater than the third side for all three cases, therefore, it can form a triangle.\nAs all the sides are of different lengths, it will form a scalene triangle.\n\n\n \nConstraints:\n\n\n\tnums.length == 3\n\t1 <= nums[i] <= 100\n\n\n",
  "3025": "\n[3025] Find the Number of Ways to Place People I is on the run...\n\n\nYou are given a 2D array points of size n x 2 representing integer coordinates of some points on a 2D plane, where points[i] = [xi, yi].\n\nCount the number of pairs of points (A, B), where\n\n\n\tA is on the upper left side of B, and\n\tthere are no other points in the rectangle (or line) they make (including the border).\n\n\nReturn the count.\n\n \nExample 1:\n\n\nInput: points = [[1,1],[2,2],[3,3]]\n\nOutput: 0\n\nExplanation:\n\n\n\nThere is no way to choose A and B so A is on the upper left side of B.\n\n\nExample 2:\n\n\nInput: points = [[6,2],[4,4],[2,6]]\n\nOutput: 2\n\nExplanation:\n\n\n\n\n\tThe left one is the pair (points[1], points[0]), where points[1] is on the upper left side of points[0] and the rectangle is empty.\n\tThe middle one is the pair (points[2], points[1]), same as the left one it is a valid pair.\n\tThe right one is the pair (points[2], points[0]), where points[2] is on the upper left side of points[0], but points[1] is inside the rectangle so it's not a valid pair.\n\n\n\nExample 3:\n\n\nInput: points = [[3,1],[1,3],[1,1]]\n\nOutput: 2\n\nExplanation:\n\n\n\n\n\tThe left one is the pair (points[2], points[0]), where points[2] is on the upper left side of points[0] and there are no other points on the line they form. Note that it is a valid state when the two points form a line.\n\tThe middle one is the pair (points[1], points[2]), it is a valid pair same as the left one.\n\tThe right one is the pair (points[1], points[0]), it is not a valid pair as points[2] is on the border of the rectangle.\n\n\n\n \nConstraints:\n\n\n\t2 <= n <= 50\n\tpoints[i].length == 2\n\t0 <= points[i][0], points[i][1] <= 50\n\tAll points[i] are distinct.\n\n\n",
  "3026": "\n[3026] Maximum Good Subarray Sum is on the run...\n\n\nYou are given an array nums of length n and a positive integer k.\n\nA subarray of nums is called good if the absolute difference between its first and last element is exactly k, in other words, the subarray nums[i..j] is good if |nums[i] - nums[j]| == k.\n\nReturn the maximum sum of a good subarray of nums. If there are no good subarrays, return 0.\n\n \nExample 1:\n\nInput: nums = [1,2,3,4,5,6], k = 1\nOutput: 11\nExplanation: The absolute difference between the first and last element must be 1 for a good subarray. All the good subarrays are: [1,2], [2,3], [3,4], [4,5], and [5,6]. The maximum subarray sum is 11 for the subarray [5,6].\n\n\nExample 2:\n\nInput: nums = [-1,3,2,4,5], k = 3\nOutput: 11\nExplanation: The absolute difference between the first and last element must be 3 for a good subarray. All the good subarrays are: [-1,3,2], and [2,4,5]. The maximum subarray sum is 11 for the subarray [2,4,5].\n\n\nExample 3:\n\nInput: nums = [-1,-2,-3,-4], k = 2\nOutput: -6\nExplanation: The absolute difference between the first and last element must be 2 for a good subarray. All the good subarrays are: [-1,-2,-3], and [-2,-3,-4]. The maximum subarray sum is -6 for the subarray [-1,-2,-3].\n\n\n \nConstraints:\n\n\n\t2 <= nums.length <= 10⁵\n\t-10⁹ <= nums[i] <= 10⁹\n\t1 <= k <= 10⁹\n\n\n",
  "3027": "\n[3027] Find the Number of Ways to Place People II is on the run...\n\n\nYou are given a 2D array points of size n x 2 representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].\n\nWe define the right direction as positive x-axis (increasing x-coordinate) and the left direction as negative x-axis (decreasing x-coordinate). Similarly, we define the up direction as positive y-axis (increasing y-coordinate) and the down direction as negative y-axis (decreasing y-coordinate)\n\nYou have to place n people, including Alice and Bob, at these points such that there is exactly one person at every point. Alice wants to be alone with Bob, so Alice will build a rectangular fence with Alice's position as the upper left corner and Bob's position as the lower right corner of the fence (Note that the fence might not enclose any area, i.e. it can be a line). If any person other than Alice and Bob is either inside the fence or on the fence, Alice will be sad.\n\nReturn the number of pairs of points where you can place Alice and Bob, such that Alice does not become sad on building the fence.\n\nNote that Alice can only build a fence with Alice's position as the upper left corner, and Bob's position as the lower right corner. For example, Alice cannot build either of the fences in the picture below with four corners (1, 1), (1, 3), (3, 1), and (3, 3), because:\n\n\n\tWith Alice at (3, 3) and Bob at (1, 1), Alice's position is not the upper left corner and Bob's position is not the lower right corner of the fence.\n\tWith Alice at (1, 3) and Bob at (1, 1), Bob's position is not the lower right corner of the fence.\n\n\n \nExample 1:\n\nInput: points = [[1,1],[2,2],[3,3]]\nOutput: 0\nExplanation: There is no way to place Alice and Bob such that Alice can build a fence with Alice's position as the upper left corner and Bob's position as the lower right corner. Hence we return 0. \n\n\nExample 2:\n\nInput: points = [[6,2],[4,4],[2,6]]\nOutput: 2\nExplanation: There are two ways to place Alice and Bob such that Alice will not be sad:\n- Place Alice at (4, 4) and Bob at (6, 2).\n- Place Alice at (2, 6) and Bob at (4, 4).\nYou cannot place Alice at (2, 6) and Bob at (6, 2) because the person at (4, 4) will be inside the fence.\n\n\nExample 3:\n\nInput: points = [[3,1],[1,3],[1,1]]\nOutput: 2\nExplanation: There are two ways to place Alice and Bob such that Alice will not be sad:\n- Place Alice at (1, 1) and Bob at (3, 1).\n- Place Alice at (1, 3) and Bob at (1, 1).\nYou cannot place Alice at (1, 3) and Bob at (3, 1) because the person at (1, 1) will be on the fence.\nNote that it does not matter if the fence encloses any area, the first and second fences in the image are valid.\n\n\n \nConstraints:\n\n\n\t2 <= n <= 1000\n\tpoints[i].length == 2\n\t-10⁹ <= points[i][0], points[i][1] <= 10⁹\n\tAll points[i] are distinct.\n\n\n",
  "3028": "\n[3028] Ant on the Boundary is on the run...\n\n\nAn ant is on a boundary. It sometimes goes left and sometimes right.\n\nYou are given an array of non-zero integers nums. The ant starts reading nums from the first element of it to its end. At each step, it moves according to the value of the current element:\n\n\n\tIf nums[i] < 0, it moves left by -nums[i] units.\n\tIf nums[i] > 0, it moves right by nums[i] units.\n\n\nReturn the number of times the ant returns to the boundary.\n\nNotes:\n\n\n\tThere is an infinite space on both sides of the boundary.\n\tWe check whether the ant is on the boundary only after it has moved |nums[i]| units. In other words, if the ant crosses the boundary during its movement, it does not count.\n\n\n \nExample 1:\n\nInput: nums = [2,3,-5]\nOutput: 1\nExplanation: After the first step, the ant is 2 steps to the right of the boundary.\nAfter the second step, the ant is 5 steps to the right of the boundary.\nAfter the third step, the ant is on the boundary.\nSo the answer is 1.\n\n\nExample 2:\n\nInput: nums = [3,2,-3,-4]\nOutput: 0\nExplanation: After the first step, the ant is 3 steps to the right of the boundary.\nAfter the second step, the ant is 5 steps to the right of the boundary.\nAfter the third step, the ant is 2 steps to the right of the boundary.\nAfter the fourth step, the ant is 2 steps to the left of the boundary.\nThe ant never returned to the boundary, so the answer is 0.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 100\n\t-10 <= nums[i] <= 10\n\tnums[i] != 0\n\n\n",
  "3029": "\n[3029] Minimum Time to Revert Word to Initial State I is on the run...\n\n\nYou are given a 0-indexed string word and an integer k.\n\nAt every second, you must perform the following operations:\n\n\n\tRemove the first k characters of word.\n\tAdd any k characters to the end of word.\n\n\nNote that you do not necessarily need to add the same characters that you removed. However, you must perform both operations at every second.\n\nReturn the minimum time greater than zero required for word to revert to its initial state.\n\n \nExample 1:\n\nInput: word = \"abacaba\", k = 3\nOutput: 2\nExplanation: At the 1st second, we remove characters \"aba\" from the prefix of word, and add characters \"bac\" to the end of word. Thus, word becomes equal to \"cababac\".\nAt the 2nd second, we remove characters \"cab\" from the prefix of word, and add \"aba\" to the end of word. Thus, word becomes equal to \"abacaba\" and reverts to its initial state.\nIt can be shown that 2 seconds is the minimum time greater than zero required for word to revert to its initial state.\n\n\nExample 2:\n\nInput: word = \"abacaba\", k = 4\nOutput: 1\nExplanation: At the 1st second, we remove characters \"abac\" from the prefix of word, and add characters \"caba\" to the end of word. Thus, word becomes equal to \"abacaba\" and reverts to its initial state.\nIt can be shown that 1 second is the minimum time greater than zero required for word to revert to its initial state.\n\n\nExample 3:\n\nInput: word = \"abcbabcd\", k = 2\nOutput: 4\nExplanation: At every second, we will remove the first 2 characters of word, and add the same characters to the end of word.\nAfter 4 seconds, word becomes equal to \"abcbabcd\" and reverts to its initial state.\nIt can be shown that 4 seconds is the minimum time greater than zero required for word to revert to its initial state.\n\n\n \nConstraints:\n\n\n\t1 <= word.length <= 50 \n\t1 <= k <= word.length\n\tword consists only of lowercase English letters.\n\n\n",
  "3030": "\n[3030] Find the Grid of Region Average is on the run...\n\n\nYou are given m x n grid image which represents a grayscale image, where image[i][j] represents a pixel with intensity in the range [0..255]. You are also given a non-negative integer threshold.\n\nTwo pixels are adjacent if they share an edge.\n\nA region is a 3 x 3 subgrid where the absolute difference in intensity between any two adjacent pixels is less than or equal to threshold.\n\nAll pixels in a region belong to that region, note that a pixel can belong to multiple regions.\n\nYou need to calculate a m x n grid result, where result[i][j] is the average intensity of the regions to which image[i][j] belongs, rounded down to the nearest integer. If image[i][j] belongs to multiple regions, result[i][j] is the average of the rounded-down average intensities of these regions, rounded down to the nearest integer. If image[i][j] does not belong to any region, result[i][j] is equal to image[i][j].\n\nReturn the grid result.\n\n \nExample 1:\n\n\nInput: image = [[5,6,7,10],[8,9,10,10],[11,12,13,10]], threshold = 3\n\nOutput: [[9,9,9,9],[9,9,9,9],[9,9,9,9]]\n\nExplanation:\n\n\n\nThere are two regions as illustrated above. The average intensity of the first region is 9, while the average intensity of the second region is 9.67 which is rounded down to 9. The average intensity of both of the regions is (9 + 9) / 2 = 9. As all the pixels belong to either region 1, region 2, or both of them, the intensity of every pixel in the result is 9.\n\nPlease note that the rounded-down values are used when calculating the average of multiple regions, hence the calculation is done using 9 as the average intensity of region 2, not 9.67.\n\n\nExample 2:\n\n\nInput: image = [[10,20,30],[15,25,35],[20,30,40],[25,35,45]], threshold = 12\n\nOutput: [[25,25,25],[27,27,27],[27,27,27],[30,30,30]]\n\nExplanation:\n\n\n\nThere are two regions as illustrated above. The average intensity of the first region is 25, while the average intensity of the second region is 30. The average intensity of both of the regions is (25 + 30) / 2 = 27.5 which is rounded down to 27.\n\nAll the pixels in row 0 of the image belong to region 1, hence all the pixels in row 0 in the result are 25. Similarly, all the pixels in row 3 in the result are 30. The pixels in rows 1 and 2 of the image belong to region 1 and region 2, hence their assigned value is 27 in the result.\n\n\nExample 3:\n\n\nInput: image = [[5,6,7],[8,9,10],[11,12,13]], threshold = 1\n\nOutput: [[5,6,7],[8,9,10],[11,12,13]]\n\nExplanation:\n\nThere is only one 3 x 3 subgrid, while it does not have the condition on difference of adjacent pixels, for example, the difference between image[0][0] and image[1][0] is |5 - 8| = 3 > threshold = 1. None of them belong to any valid regions, so the result should be the same as image.\n\n\n \nConstraints:\n\n\n\t3 <= n, m <= 500\n\t0 <= image[i][j] <= 255\n\t0 <= threshold <= 255\n\n\n",
  "3031": "\n[3031] Minimum Time to Revert Word to Initial State II is on the run...\n\n\nYou are given a 0-indexed string word and an integer k.\n\nAt every second, you must perform the following operations:\n\n\n\tRemove the first k characters of word.\n\tAdd any k characters to the end of word.\n\n\nNote that you do not necessarily need to add the same characters that you removed. However, you must perform both operations at every second.\n\nReturn the minimum time greater than zero required for word to revert to its initial state.\n\n \nExample 1:\n\nInput: word = \"abacaba\", k = 3\nOutput: 2\nExplanation: At the 1st second, we remove characters \"aba\" from the prefix of word, and add characters \"bac\" to the end of word. Thus, word becomes equal to \"cababac\".\nAt the 2nd second, we remove characters \"cab\" from the prefix of word, and add \"aba\" to the end of word. Thus, word becomes equal to \"abacaba\" and reverts to its initial state.\nIt can be shown that 2 seconds is the minimum time greater than zero required for word to revert to its initial state.\n\n\nExample 2:\n\nInput: word = \"abacaba\", k = 4\nOutput: 1\nExplanation: At the 1st second, we remove characters \"abac\" from the prefix of word, and add characters \"caba\" to the end of word. Thus, word becomes equal to \"abacaba\" and reverts to its initial state.\nIt can be shown that 1 second is the minimum time greater than zero required for word to revert to its initial state.\n\n\nExample 3:\n\nInput: word = \"abcbabcd\", k = 2\nOutput: 4\nExplanation: At every second, we will remove the first 2 characters of word, and add the same characters to the end of word.\nAfter 4 seconds, word becomes equal to \"abcbabcd\" and reverts to its initial state.\nIt can be shown that 4 seconds is the minimum time greater than zero required for word to revert to its initial state.\n\n\n \nConstraints:\n\n\n\t1 <= word.length <= 10⁶\n\t1 <= k <= word.length\n\tword consists only of lowercase English letters.\n\n\n",
  "3032": "\n[3032] Count Numbers With Unique Digits II is on the run...\n\n\nGiven two positive integers a and b, return the count of numbers having unique digits in the range [a, b] (inclusive).\n \nExample 1:\n\nInput: a = 1, b = 20\nOutput: 19\nExplanation: All the numbers in the range [1, 20] have unique digits except 11. Hence, the answer is 19.\n\n\nExample 2:\n\nInput: a = 9, b = 19\nOutput: 10\nExplanation: All the numbers in the range [9, 19] have unique digits except 11. Hence, the answer is 10. \n\n\nExample 3:\n\nInput: a = 80, b = 120\nOutput: 27\nExplanation: There are 41 numbers in the range [80, 120], 27 of which have unique digits.\n\n\n \nConstraints:\n\n\n\t1 <= a <= b <= 1000\n\n\n",
  "3033": "\n[3033] Modify the Matrix is on the run...\n\n\nGiven a 0-indexed m x n integer matrix matrix, create a new 0-indexed matrix called answer. Make answer equal to matrix, then replace each element with the value -1 with the maximum element in its respective column.\n\nReturn the matrix answer.\n\n \nExample 1:\n\nInput: matrix = [[1,2,-1],[4,-1,6],[7,8,9]]\nOutput: [[1,2,9],[4,8,6],[7,8,9]]\nExplanation: The diagram above shows the elements that are changed (in blue).\n- We replace the value in the cell [1][1] with the maximum value in the column 1, that is 8.\n- We replace the value in the cell [0][2] with the maximum value in the column 2, that is 9.\n\n\nExample 2:\n\nInput: matrix = [[3,-1],[5,2]]\nOutput: [[3,2],[5,2]]\nExplanation: The diagram above shows the elements that are changed (in blue).\n\n\n \nConstraints:\n\n\n\tm == matrix.length\n\tn == matrix[i].length\n\t2 <= m, n <= 50\n\t-1 <= matrix[i][j] <= 100\n\tThe input is generated such that each column contains at least one non-negative integer.\n\n\n",
  "3034": "\n[3034] Number of Subarrays That Match a Pattern I is on the run...\n\n\nYou are given a 0-indexed integer array nums of size n, and a 0-indexed integer array pattern of size m consisting of integers -1, 0, and 1.\n\nA subarray nums[i..j] of size m + 1 is said to match the pattern if the following conditions hold for each element pattern[k]:\n\n\n\tnums[i + k + 1] > nums[i + k] if pattern[k] == 1.\n\tnums[i + k + 1] == nums[i + k] if pattern[k] == 0.\n\tnums[i + k + 1] < nums[i + k] if pattern[k] == -1.\n\n\nReturn the count of subarrays in nums that match the pattern.\n\n \nExample 1:\n\nInput: nums = [1,2,3,4,5,6], pattern = [1,1]\nOutput: 4\nExplanation: The pattern [1,1] indicates that we are looking for strictly increasing subarrays of size 3. In the array nums, the subarrays [1,2,3], [2,3,4], [3,4,5], and [4,5,6] match this pattern.\nHence, there are 4 subarrays in nums that match the pattern.\n\n\nExample 2:\n\nInput: nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]\nOutput: 2\nExplanation: Here, the pattern [1,0,-1] indicates that we are looking for a sequence where the first number is smaller than the second, the second is equal to the third, and the third is greater than the fourth. In the array nums, the subarrays [1,4,4,1], and [3,5,5,3] match this pattern.\nHence, there are 2 subarrays in nums that match the pattern.\n\n\n \nConstraints:\n\n\n\t2 <= n == nums.length <= 100\n\t1 <= nums[i] <= 10⁹\n\t1 <= m == pattern.length < n\n\t-1 <= pattern[i] <= 1\n\n\n",
  "3035": "\n[3035] Maximum Palindromes After Operations is on the run...\n\n\nYou are given a 0-indexed string array words having length n and containing 0-indexed strings.\n\nYou are allowed to perform the following operation any number of times (including zero):\n\n\n\tChoose integers i, j, x, and y such that 0 <= i, j < n, 0 <= x < words[i].length, 0 <= y < words[j].length, and swap the characters words[i][x] and words[j][y].\n\n\nReturn an integer denoting the maximum number of palindromes words can contain, after performing some operations.\n\nNote: i and j may be equal during an operation.\n\n \nExample 1:\n\nInput: words = [\"abbb\",\"ba\",\"aa\"]\nOutput: 3\nExplanation: In this example, one way to get the maximum number of palindromes is:\nChoose i = 0, j = 1, x = 0, y = 0, so we swap words[0][0] and words[1][0]. words becomes [\"bbbb\",\"aa\",\"aa\"].\nAll strings in words are now palindromes.\nHence, the maximum number of palindromes achievable is 3.\n\nExample 2:\n\nInput: words = [\"abc\",\"ab\"]\nOutput: 2\nExplanation: In this example, one way to get the maximum number of palindromes is: \nChoose i = 0, j = 1, x = 1, y = 0, so we swap words[0][1] and words[1][0]. words becomes [\"aac\",\"bb\"].\nChoose i = 0, j = 0, x = 1, y = 2, so we swap words[0][1] and words[0][2]. words becomes [\"aca\",\"bb\"].\nBoth strings are now palindromes.\nHence, the maximum number of palindromes achievable is 2.\n\n\nExample 3:\n\nInput: words = [\"cd\",\"ef\",\"a\"]\nOutput: 1\nExplanation: In this example, there is no need to perform any operation.\nThere is one palindrome in words \"a\".\nIt can be shown that it is not possible to get more than one palindrome after any number of operations.\nHence, the answer is 1.\n\n \nConstraints:\n\n\n\t1 <= words.length <= 1000\n\t1 <= words[i].length <= 100\n\twords[i] consists only of lowercase English letters.\n\n\n",
  "3036": "\n[3036] Number of Subarrays That Match a Pattern II is on the run...\n\n\nYou are given a 0-indexed integer array nums of size n, and a 0-indexed integer array pattern of size m consisting of integers -1, 0, and 1.\n\nA subarray nums[i..j] of size m + 1 is said to match the pattern if the following conditions hold for each element pattern[k]:\n\n\n\tnums[i + k + 1] > nums[i + k] if pattern[k] == 1.\n\tnums[i + k + 1] == nums[i + k] if pattern[k] == 0.\n\tnums[i + k + 1] < nums[i + k] if pattern[k] == -1.\n\n\nReturn the count of subarrays in nums that match the pattern.\n\n \nExample 1:\n\nInput: nums = [1,2,3,4,5,6], pattern = [1,1]\nOutput: 4\nExplanation: The pattern [1,1] indicates that we are looking for strictly increasing subarrays of size 3. In the array nums, the subarrays [1,2,3], [2,3,4], [3,4,5], and [4,5,6] match this pattern.\nHence, there are 4 subarrays in nums that match the pattern.\n\n\nExample 2:\n\nInput: nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]\nOutput: 2\nExplanation: Here, the pattern [1,0,-1] indicates that we are looking for a sequence where the first number is smaller than the second, the second is equal to the third, and the third is greater than the fourth. In the array nums, the subarrays [1,4,4,1], and [3,5,5,3] match this pattern.\nHence, there are 2 subarrays in nums that match the pattern.\n\n\n \nConstraints:\n\n\n\t2 <= n == nums.length <= 10⁶\n\t1 <= nums[i] <= 10⁹\n\t1 <= m == pattern.length < n\n\t-1 <= pattern[i] <= 1\n\n\n",
  "3037": "\n[3037] Find Pattern in Infinite Stream II is on the run...\n\n\nYou are given a binary array pattern and an object stream of class InfiniteStream representing a 0-indexed infinite stream of bits.\n\nThe class InfiniteStream contains the following function:\n\n\n\tint next(): Reads a single bit (which is either 0 or 1) from the stream and returns it.\n\n\nReturn the first starting index where the pattern matches the bits read from the stream. For example, if the pattern is [1, 0], the first match is the highlighted part in the stream [0, 1, 0, 1, ...].\n\n \nExample 1:\n\nInput: stream = [1,1,1,0,1,1,1,...], pattern = [0,1]\nOutput: 3\nExplanation: The first occurrence of the pattern [0,1] is highlighted in the stream [1,1,1,0,1,...], which starts at index 3.\n\n\nExample 2:\n\nInput: stream = [0,0,0,0,...], pattern = [0]\nOutput: 0\nExplanation: The first occurrence of the pattern [0] is highlighted in the stream [0,...], which starts at index 0.\n\n\nExample 3:\n\nInput: stream = [1,0,1,1,0,1,1,0,1,...], pattern = [1,1,0,1]\nOutput: 2\nExplanation: The first occurrence of the pattern [1,1,0,1] is highlighted in the stream [1,0,1,1,0,1,...], which starts at index 2.\n\n\n \nConstraints:\n\n\n\t1 <= pattern.length <= 10⁴\n\tpattern consists only of 0 and 1.\n\tstream consists only of 0 and 1.\n\tThe input is generated such that the pattern's start index exists in the first 10⁵ bits of the stream.\n\n\n",
  "3038": "\n[3038] Maximum Number of Operations With the Same Score I is on the run...\n\n\nYou are given an array of integers nums. Consider the following operation:\n\n\n\tDelete the first two elements nums and define the score of the operation as the sum of these two elements.\n\n\nYou can perform this operation until nums contains fewer than two elements. Additionally, the same score must be achieved in all operations.\n\nReturn the maximum number of operations you can perform.\n\n \nExample 1:\n\n\nInput: nums = [3,2,1,4,5]\n\nOutput: 2\n\nExplanation:\n\n\n\tWe can perform the first operation with the score 3 + 2 = 5. After this operation, nums = [1,4,5].\n\tWe can perform the second operation as its score is 4 + 1 = 5, the same as the previous operation. After this operation, nums = [5].\n\tAs there are fewer than two elements, we can't perform more operations.\n\n\n\nExample 2:\n\n\nInput: nums = [1,5,3,3,4,1,3,2,2,3]\n\nOutput: 2\n\nExplanation:\n\n\n\tWe can perform the first operation with the score 1 + 5 = 6. After this operation, nums = [3,3,4,1,3,2,2,3].\n\tWe can perform the second operation as its score is 3 + 3 = 6, the same as the previous operation. After this operation, nums = [4,1,3,2,2,3].\n\tWe cannot perform the next operation as its score is 4 + 1 = 5, which is different from the previous scores.\n\n\n\nExample 3:\n\n\nInput: nums = [5,3]\n\nOutput: 1\n\n\n \nConstraints:\n\n\n\t2 <= nums.length <= 100\n\t1 <= nums[i] <= 1000\n\n\n",
  "3039": "\n[3039] Apply Operations to Make String Empty is on the run...\n\n\nYou are given a string s.\n\nConsider performing the following operation until s becomes empty:\n\n\n\tFor every alphabet character from 'a' to 'z', remove the first occurrence of that character in s (if it exists).\n\n\nFor example, let initially s = \"aabcbbca\". We do the following operations:\n\n\n\tRemove the underlined characters s = \"aabcbbca\". The resulting string is s = \"abbca\".\n\tRemove the underlined characters s = \"abbca\". The resulting string is s = \"ba\".\n\tRemove the underlined characters s = \"ba\". The resulting string is s = \"\".\n\n\nReturn the value of the string s right before applying the last operation. In the example above, answer is \"ba\".\n\n \nExample 1:\n\nInput: s = \"aabcbbca\"\nOutput: \"ba\"\nExplanation: Explained in the statement.\n\n\nExample 2:\n\nInput: s = \"abcd\"\nOutput: \"abcd\"\nExplanation: We do the following operation:\n- Remove the underlined characters s = \"abcd\". The resulting string is s = \"\".\nThe string just before the last operation is \"abcd\".\n\n\n \nConstraints:\n\n\n\t1 <= s.length <= 5 * 10⁵\n\ts consists only of lowercase English letters.\n\n\n",
  "3040": "\n[3040] Maximum Number of Operations With the Same Score II is on the run...\n\n\nGiven an array of integers called nums, you can perform any of the following operation while nums contains at least 2 elements:\n\n\n\tChoose the first two elements of nums and delete them.\n\tChoose the last two elements of nums and delete them.\n\tChoose the first and the last elements of nums and delete them.\n\n\nThe score of the operation is the sum of the deleted elements.\n\nYour task is to find the maximum number of operations that can be performed, such that all operations have the same score.\n\nReturn the maximum number of operations possible that satisfy the condition mentioned above.\n\n \nExample 1:\n\nInput: nums = [3,2,1,2,3,4]\nOutput: 3\nExplanation: We perform the following operations:\n- Delete the first two elements, with score 3 + 2 = 5, nums = [1,2,3,4].\n- Delete the first and the last elements, with score 1 + 4 = 5, nums = [2,3].\n- Delete the first and the last elements, with score 2 + 3 = 5, nums = [].\nWe are unable to perform any more operations as nums is empty.\n\n\nExample 2:\n\nInput: nums = [3,2,6,1,4]\nOutput: 2\nExplanation: We perform the following operations:\n- Delete the first two elements, with score 3 + 2 = 5, nums = [6,1,4].\n- Delete the last two elements, with score 1 + 4 = 5, nums = [6].\nIt can be proven that we can perform at most 2 operations.\n\n\n \nConstraints:\n\n\n\t2 <= nums.length <= 2000\n\t1 <= nums[i] <= 1000\n\n\n",
  "3041": "\n[3041] Maximize Consecutive Elements in an Array After Modification is on the run...\n\n\nYou are given a 0-indexed array nums consisting of positive integers.\n\nInitially, you can increase the value of any element in the array by at most 1.\n\nAfter that, you need to select one or more elements from the final array such that those elements are consecutive when sorted in increasing order. For example, the elements [3, 4, 5] are consecutive while [3, 4, 6] and [1, 1, 2, 3] are not.\n\nReturn the maximum number of elements that you can select.\n\n \nExample 1:\n\nInput: nums = [2,1,5,1,1]\nOutput: 3\nExplanation: We can increase the elements at indices 0 and 3. The resulting array is nums = [3,1,5,2,1].\nWe select the elements [3,1,5,2,1] and we sort them to obtain [1,2,3], which are consecutive.\nIt can be shown that we cannot select more than 3 consecutive elements.\n\nExample 2:\n\nInput: nums = [1,4,7,10]\nOutput: 1\nExplanation: The maximum consecutive elements that we can select is 1.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 10⁵\n\t1 <= nums[i] <= 10⁶\n\n\n",
  "3042": "\n[3042] Count Prefix and Suffix Pairs I is on the run...\n\n\nYou are given a 0-indexed string array words.\n\nLet's define a boolean function isPrefixAndSuffix that takes two strings, str1 and str2:\n\n\n\tisPrefixAndSuffix(str1, str2) returns true if str1 is both a prefix and a suffix of str2, and false otherwise.\n\n\nFor example, isPrefixAndSuffix(\"aba\", \"ababa\") is true because \"aba\" is a prefix of \"ababa\" and also a suffix, but isPrefixAndSuffix(\"abc\", \"abcd\") is false.\n\nReturn an integer denoting the number of index pairs (i, j) such that i < j, and isPrefixAndSuffix(words[i], words[j]) is true.\n\n \nExample 1:\n\nInput: words = [\"a\",\"aba\",\"ababa\",\"aa\"]\nOutput: 4\nExplanation: In this example, the counted index pairs are:\ni = 0 and j = 1 because isPrefixAndSuffix(\"a\", \"aba\") is true.\ni = 0 and j = 2 because isPrefixAndSuffix(\"a\", \"ababa\") is true.\ni = 0 and j = 3 because isPrefixAndSuffix(\"a\", \"aa\") is true.\ni = 1 and j = 2 because isPrefixAndSuffix(\"aba\", \"ababa\") is true.\nTherefore, the answer is 4.\n\nExample 2:\n\nInput: words = [\"pa\",\"papa\",\"ma\",\"mama\"]\nOutput: 2\nExplanation: In this example, the counted index pairs are:\ni = 0 and j = 1 because isPrefixAndSuffix(\"pa\", \"papa\") is true.\ni = 2 and j = 3 because isPrefixAndSuffix(\"ma\", \"mama\") is true.\nTherefore, the answer is 2.  \n\nExample 3:\n\nInput: words = [\"abab\",\"ab\"]\nOutput: 0\nExplanation: In this example, the only valid index pair is i = 0 and j = 1, and isPrefixAndSuffix(\"abab\", \"ab\") is false.\nTherefore, the answer is 0.\n\n \nConstraints:\n\n\n\t1 <= words.length <= 50\n\t1 <= words[i].length <= 10\n\twords[i] consists only of lowercase English letters.\n\n\n",
  "3043": "\n[3043] Find the Length of the Longest Common Prefix is on the run...\n\n\nYou are given two arrays with positive integers arr1 and arr2.\n\nA prefix of a positive integer is an integer formed by one or more of its digits, starting from its leftmost digit. For example, 123 is a prefix of the integer 12345, while 234 is not.\n\nA common prefix of two integers a and b is an integer c, such that c is a prefix of both a and b. For example, 5655359 and 56554 have common prefixes 565 and 5655 while 1223 and 43456 do not have a common prefix.\n\nYou need to find the length of the longest common prefix between all pairs of integers (x, y) such that x belongs to arr1 and y belongs to arr2.\n\nReturn the length of the longest common prefix among all pairs. If no common prefix exists among them, return 0.\n\n \nExample 1:\n\nInput: arr1 = [1,10,100], arr2 = [1000]\nOutput: 3\nExplanation: There are 3 pairs (arr1[i], arr2[j]):\n- The longest common prefix of (1, 1000) is 1.\n- The longest common prefix of (10, 1000) is 10.\n- The longest common prefix of (100, 1000) is 100.\nThe longest common prefix is 100 with a length of 3.\n\n\nExample 2:\n\nInput: arr1 = [1,2,3], arr2 = [4,4,4]\nOutput: 0\nExplanation: There exists no common prefix for any pair (arr1[i], arr2[j]), hence we return 0.\nNote that common prefixes between elements of the same array do not count.\n\n\n \nConstraints:\n\n\n\t1 <= arr1.length, arr2.length <= 5 * 10⁴\n\t1 <= arr1[i], arr2[i] <= 10⁸\n\n\n",
  "3044": "\n[3044] Most Frequent Prime is on the run...\n\n\nYou are given a m x n 0-indexed 2D matrix mat. From every cell, you can create numbers in the following way:\n\n\n\tThere could be at most 8 paths from the cells namely: east, south-east, south, south-west, west, north-west, north, and north-east.\n\tSelect a path from them and append digits in this path to the number being formed by traveling in this direction.\n\tNote that numbers are generated at every step, for example, if the digits along the path are 1, 9, 1, then there will be three numbers generated along the way: 1, 19, 191.\n\n\nReturn the most frequent prime number greater than 10 out of all the numbers created by traversing the matrix or -1 if no such prime number exists. If there are multiple prime numbers with the highest frequency, then return the largest among them.\n\nNote: It is invalid to change the direction during the move.\n\n \nExample 1:\n \n\n\nInput: mat = [[1,1],[9,9],[1,1]]\nOutput: 19\nExplanation: \nFrom cell (0,0) there are 3 possible directions and the numbers greater than 10 which can be created in those directions are:\nEast: [11], South-East: [19], South: [19,191].\nNumbers greater than 10 created from the cell (0,1) in all possible directions are: [19,191,19,11].\nNumbers greater than 10 created from the cell (1,0) in all possible directions are: [99,91,91,91,91].\nNumbers greater than 10 created from the cell (1,1) in all possible directions are: [91,91,99,91,91].\nNumbers greater than 10 created from the cell (2,0) in all possible directions are: [11,19,191,19].\nNumbers greater than 10 created from the cell (2,1) in all possible directions are: [11,19,19,191].\nThe most frequent prime number among all the created numbers is 19.\n\nExample 2:\n\nInput: mat = [[7]]\nOutput: -1\nExplanation: The only number which can be formed is 7. It is a prime number however it is not greater than 10, so return -1.\n\nExample 3:\n\nInput: mat = [[9,7,8],[4,6,5],[2,8,6]]\nOutput: 97\nExplanation: \nNumbers greater than 10 created from the cell (0,0) in all possible directions are: [97,978,96,966,94,942].\nNumbers greater than 10 created from the cell (0,1) in all possible directions are: [78,75,76,768,74,79].\nNumbers greater than 10 created from the cell (0,2) in all possible directions are: [85,856,86,862,87,879].\nNumbers greater than 10 created from the cell (1,0) in all possible directions are: [46,465,48,42,49,47].\nNumbers greater than 10 created from the cell (1,1) in all possible directions are: [65,66,68,62,64,69,67,68].\nNumbers greater than 10 created from the cell (1,2) in all possible directions are: [56,58,56,564,57,58].\nNumbers greater than 10 created from the cell (2,0) in all possible directions are: [28,286,24,249,26,268].\nNumbers greater than 10 created from the cell (2,1) in all possible directions are: [86,82,84,86,867,85].\nNumbers greater than 10 created from the cell (2,2) in all possible directions are: [68,682,66,669,65,658].\nThe most frequent prime number among all the created numbers is 97.\n\n\n \nConstraints:\n\n\n\tm == mat.length\n\tn == mat[i].length\n\t1 <= m, n <= 6\n\t1 <= mat[i][j] <= 9\n\n\n",
  "3045": "\n[3045] Count Prefix and Suffix Pairs II is on the run...\n\n\nYou are given a 0-indexed string array words.\n\nLet's define a boolean function isPrefixAndSuffix that takes two strings, str1 and str2:\n\n\n\tisPrefixAndSuffix(str1, str2) returns true if str1 is both a prefix and a suffix of str2, and false otherwise.\n\n\nFor example, isPrefixAndSuffix(\"aba\", \"ababa\") is true because \"aba\" is a prefix of \"ababa\" and also a suffix, but isPrefixAndSuffix(\"abc\", \"abcd\") is false.\n\nReturn an integer denoting the number of index pairs (i, j) such that i < j, and isPrefixAndSuffix(words[i], words[j]) is true.\n\n \nExample 1:\n\nInput: words = [\"a\",\"aba\",\"ababa\",\"aa\"]\nOutput: 4\nExplanation: In this example, the counted index pairs are:\ni = 0 and j = 1 because isPrefixAndSuffix(\"a\", \"aba\") is true.\ni = 0 and j = 2 because isPrefixAndSuffix(\"a\", \"ababa\") is true.\ni = 0 and j = 3 because isPrefixAndSuffix(\"a\", \"aa\") is true.\ni = 1 and j = 2 because isPrefixAndSuffix(\"aba\", \"ababa\") is true.\nTherefore, the answer is 4.\n\nExample 2:\n\nInput: words = [\"pa\",\"papa\",\"ma\",\"mama\"]\nOutput: 2\nExplanation: In this example, the counted index pairs are:\ni = 0 and j = 1 because isPrefixAndSuffix(\"pa\", \"papa\") is true.\ni = 2 and j = 3 because isPrefixAndSuffix(\"ma\", \"mama\") is true.\nTherefore, the answer is 2.  \n\nExample 3:\n\nInput: words = [\"abab\",\"ab\"]\nOutput: 0\nExplanation: In this example, the only valid index pair is i = 0 and j = 1, and isPrefixAndSuffix(\"abab\", \"ab\") is false.\nTherefore, the answer is 0.\n\n \nConstraints:\n\n\n\t1 <= words.length <= 10⁵\n\t1 <= words[i].length <= 10⁵\n\twords[i] consists only of lowercase English letters.\n\tThe sum of the lengths of all words[i] does not exceed 5 * 10⁵.\n\n\n",
  "3046": "\n[3046] Split the Array is on the run...\n\n\nYou are given an integer array nums of even length. You have to split the array into two parts nums1 and nums2 such that:\n\n\n\tnums1.length == nums2.length == nums.length / 2.\n\tnums1 should contain distinct elements.\n\tnums2 should also contain distinct elements.\n\n\nReturn true if it is possible to split the array, and false otherwise.\n\n \nExample 1:\n\nInput: nums = [1,1,2,2,3,4]\nOutput: true\nExplanation: One of the possible ways to split nums is nums1 = [1,2,3] and nums2 = [1,2,4].\n\n\nExample 2:\n\nInput: nums = [1,1,1,1]\nOutput: false\nExplanation: The only possible way to split nums is nums1 = [1,1] and nums2 = [1,1]. Both nums1 and nums2 do not contain distinct elements. Therefore, we return false.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 100\n\tnums.length % 2 == 0 \n\t1 <= nums[i] <= 100\n\n\n",
  "3047": "\n[3047] Find the Largest Area of Square Inside Two Rectangles is on the run...\n\n\nThere exist n rectangles in a 2D plane with edges parallel to the x and y axis. You are given two 2D integer arrays bottomLeft and topRight where bottomLeft[i] = [a_i, b_i] and topRight[i] = [c_i, d_i] represent the bottom-left and top-right coordinates of the ith rectangle, respectively.\n\nYou need to find the maximum area of a square that can fit inside the intersecting region of at least two rectangles. Return 0 if such a square does not exist.\n\n \nExample 1:\n\nInput: bottomLeft = [[1,1],[2,2],[3,1]], topRight = [[3,3],[4,4],[6,6]]\n\nOutput: 1\n\nExplanation:\n\nA square with side length 1 can fit inside either the intersecting region of rectangles 0 and 1 or the intersecting region of rectangles 1 and 2. Hence the maximum area is 1. It can be shown that a square with a greater side length can not fit inside any intersecting region of two rectangles.\n\nExample 2:\n\nInput: bottomLeft = [[1,1],[1,3],[1,5]], topRight = [[5,5],[5,7],[5,9]]\n\nOutput: 4\n\nExplanation:\n\nA square with side length 2 can fit inside either the intersecting region of rectangles 0 and 1 or the intersecting region of rectangles 1 and 2. Hence the maximum area is 2 * 2 = 4. It can be shown that a square with a greater side length can not fit inside any intersecting region of two rectangles.\n\nExample 3:\n  \n\nInput: bottomLeft = [[1,1],[2,2],[1,2]], topRight = [[3,3],[4,4],[3,4]]\n\nOutput: 1\n\nExplanation:\n\nA square with side length 1 can fit inside the intersecting region of any two rectangles. Also, no larger square can, so the maximum area is 1. Note that the region can be formed by the intersection of more than 2 rectangles.\n\nExample 4:\n  \n\nInput: bottomLeft = [[1,1],[3,3],[3,1]], topRight = [[2,2],[4,4],[4,2]]\n\nOutput: 0\n\nExplanation:\n\nNo pair of rectangles intersect, hence, the answer is 0.\n\n \nConstraints:\n\n\n\tn == bottomLeft.length == topRight.length\n\t2 <= n <= 10³\n\tbottomLeft[i].length == topRight[i].length == 2\n\t1 <= bottomLeft[i][0], bottomLeft[i][1] <= 10⁷\n\t1 <= topRight[i][0], topRight[i][1] <= 10⁷\n\tbottomLeft[i][0] < topRight[i][0]\n\tbottomLeft[i][1] < topRight[i][1]\n\n\n",
  "3048": "\n[3048] Earliest Second to Mark Indices I is on the run...\n\n\nYou are given two 1-indexed integer arrays, nums and, changeIndices, having lengths n and m, respectively.\n\nInitially, all indices in nums are unmarked. Your task is to mark all indices in nums.\n\nIn each second, s, in order from 1 to m (inclusive), you can perform one of the following operations:\n\n\n\tChoose an index i in the range [1, n] and decrement nums[i] by 1.\n\tIf nums[changeIndices[s]] is equal to 0, mark the index changeIndices[s].\n\tDo nothing.\n\n\nReturn an integer denoting the earliest second in the range [1, m] when all indices in nums can be marked by choosing operations optimally, or -1 if it is impossible.\n\n \nExample 1:\n\nInput: nums = [2,2,0], changeIndices = [2,2,2,2,3,2,2,1]\nOutput: 8\nExplanation: In this example, we have 8 seconds. The following operations can be performed to mark all indices:\nSecond 1: Choose index 1 and decrement nums[1] by one. nums becomes [1,2,0].\nSecond 2: Choose index 1 and decrement nums[1] by one. nums becomes [0,2,0].\nSecond 3: Choose index 2 and decrement nums[2] by one. nums becomes [0,1,0].\nSecond 4: Choose index 2 and decrement nums[2] by one. nums becomes [0,0,0].\nSecond 5: Mark the index changeIndices[5], which is marking index 3, since nums[3] is equal to 0.\nSecond 6: Mark the index changeIndices[6], which is marking index 2, since nums[2] is equal to 0.\nSecond 7: Do nothing.\nSecond 8: Mark the index changeIndices[8], which is marking index 1, since nums[1] is equal to 0.\nNow all indices have been marked.\nIt can be shown that it is not possible to mark all indices earlier than the 8th second.\nHence, the answer is 8.\n\n\nExample 2:\n\nInput: nums = [1,3], changeIndices = [1,1,1,2,1,1,1]\nOutput: 6\nExplanation: In this example, we have 7 seconds. The following operations can be performed to mark all indices:\nSecond 1: Choose index 2 and decrement nums[2] by one. nums becomes [1,2].\nSecond 2: Choose index 2 and decrement nums[2] by one. nums becomes [1,1].\nSecond 3: Choose index 2 and decrement nums[2] by one. nums becomes [1,0].\nSecond 4: Mark the index changeIndices[4], which is marking index 2, since nums[2] is equal to 0.\nSecond 5: Choose index 1 and decrement nums[1] by one. nums becomes [0,0].\nSecond 6: Mark the index changeIndices[6], which is marking index 1, since nums[1] is equal to 0.\nNow all indices have been marked.\nIt can be shown that it is not possible to mark all indices earlier than the 6th second.\nHence, the answer is 6.\n\n\nExample 3:\n\nInput: nums = [0,1], changeIndices = [2,2,2]\nOutput: -1\nExplanation: In this example, it is impossible to mark all indices because index 1 isn't in changeIndices.\nHence, the answer is -1.\n\n\n \nConstraints:\n\n\n\t1 <= n == nums.length <= 2000\n\t0 <= nums[i] <= 10⁹\n\t1 <= m == changeIndices.length <= 2000\n\t1 <= changeIndices[i] <= n\n\n\n",
  "3049": "\n[3049] Earliest Second to Mark Indices II is on the run...\n\n\nYou are given two 1-indexed integer arrays, nums and, changeIndices, having lengths n and m, respectively.\n\nInitially, all indices in nums are unmarked. Your task is to mark all indices in nums.\n\nIn each second, s, in order from 1 to m (inclusive), you can perform one of the following operations:\n\n\n\tChoose an index i in the range [1, n] and decrement nums[i] by 1.\n\tSet nums[changeIndices[s]] to any non-negative value.\n\tChoose an index i in the range [1, n], where nums[i] is equal to 0, and mark index i.\n\tDo nothing.\n\n\nReturn an integer denoting the earliest second in the range [1, m] when all indices in nums can be marked by choosing operations optimally, or -1 if it is impossible.\n\n \nExample 1:\n\nInput: nums = [3,2,3], changeIndices = [1,3,2,2,2,2,3]\nOutput: 6\nExplanation: In this example, we have 7 seconds. The following operations can be performed to mark all indices:\nSecond 1: Set nums[changeIndices[1]] to 0. nums becomes [0,2,3].\nSecond 2: Set nums[changeIndices[2]] to 0. nums becomes [0,2,0].\nSecond 3: Set nums[changeIndices[3]] to 0. nums becomes [0,0,0].\nSecond 4: Mark index 1, since nums[1] is equal to 0.\nSecond 5: Mark index 2, since nums[2] is equal to 0.\nSecond 6: Mark index 3, since nums[3] is equal to 0.\nNow all indices have been marked.\nIt can be shown that it is not possible to mark all indices earlier than the 6th second.\nHence, the answer is 6.\n\n\nExample 2:\n\nInput: nums = [0,0,1,2], changeIndices = [1,2,1,2,1,2,1,2]\nOutput: 7\nExplanation: In this example, we have 8 seconds. The following operations can be performed to mark all indices:\nSecond 1: Mark index 1, since nums[1] is equal to 0.\nSecond 2: Mark index 2, since nums[2] is equal to 0.\nSecond 3: Decrement index 4 by one. nums becomes [0,0,1,1].\nSecond 4: Decrement index 4 by one. nums becomes [0,0,1,0].\nSecond 5: Decrement index 3 by one. nums becomes [0,0,0,0].\nSecond 6: Mark index 3, since nums[3] is equal to 0.\nSecond 7: Mark index 4, since nums[4] is equal to 0.\nNow all indices have been marked.\nIt can be shown that it is not possible to mark all indices earlier than the 7th second.\nHence, the answer is 7.\n\n\nExample 3:\n\nInput: nums = [1,2,3], changeIndices = [1,2,3]\nOutput: -1\nExplanation: In this example, it can be shown that it is impossible to mark all indices, as we don't have enough seconds. \nHence, the answer is -1.\n\n\n \nConstraints:\n\n\n\t1 <= n == nums.length <= 5000\n\t0 <= nums[i] <= 10⁹\n\t1 <= m == changeIndices.length <= 5000\n\t1 <= changeIndices[i] <= n\n\n\n",
  "3050": "\n[3050] Pizza Toppings Cost Analysis is on the run...\n\n\n",
  "3051": "\n[3051] Find Candidates for Data Scientist Position is on the run...\n\n\n",
  "3052": "\n[3052] Maximize Items is on the run...\n\n\n",
  "3053": "\n[3053] Classifying Triangles by Lengths is on the run...\n\n\n",
  "3054": "\n[3054] Binary Tree Nodes is on the run...\n\n\n",
  "3055": "\n[3055] Top Percentile Fraud is on the run...\n\n\n",
  "3056": "\n[3056] Snaps Analysis is on the run...\n\n\n",
  "3057": "\n[3057] Employees Project Allocation is on the run...\n\n\n",
  "3058": "\n[3058] Friends With No Mutual Friends is on the run...\n\n\n",
  "3059": "\n[3059] Find All Unique Email Domains is on the run...\n\n\n",
  "3060": "\n[3060] User Activities within Time Bounds is on the run...\n\n\n",
  "3061": "\n[3061] Calculate Trapping Rain Water is on the run...\n\n\n",
  "3062": "\n[3062] Winner of the Linked List Game is on the run...\n\n\nYou are given the head of a linked list of even length containing integers.\n\nEach odd-indexed node contains an odd integer and each even-indexed node contains an even integer.\n\nWe call each even-indexed node and its next node a pair, e.g., the nodes with indices 0 and 1 are a pair, the nodes with indices 2 and 3 are a pair, and so on.\n\nFor every pair, we compare the values of the nodes in the pair:\n\n\n\tIf the odd-indexed node is higher, the \"Odd\" team gets a point.\n\tIf the even-indexed node is higher, the \"Even\" team gets a point.\n\n\nReturn the name of the team with the higher points, if the points are equal, return \"Tie\".\n\n \nExample 1: \n\n\nInput:   head = [2,1] \n\nOutput:   \"Even\" \n\nExplanation:  There is only one pair in this linked list and that is (2,1). Since 2 > 1, the Even team gets the point.\n\nHence, the answer would be \"Even\".\n\n\nExample 2: \n\n\nInput:   head = [2,5,4,7,20,5] \n\nOutput:   \"Odd\" \n\nExplanation:  There are 3 pairs in this linked list. Let's investigate each pair individually:\n\n(2,5) -> Since 2 < 5, The Odd team gets the point.\n\n(4,7) -> Since 4 < 7, The Odd team gets the point.\n\n(20,5) -> Since 20 > 5, The Even team gets the point.\n\nThe Odd team earned 2 points while the Even team got 1 point and the Odd team has the higher points.\n\nHence, the answer would be \"Odd\".\n\n\nExample 3: \n\n\nInput:   head = [4,5,2,1] \n\nOutput:   \"Tie\" \n\nExplanation:  There are 2 pairs in this linked list. Let's investigate each pair individually:\n\n(4,5) -> Since 4 < 5, the Odd team gets the point.\n\n(2,1) -> Since 2 > 1, the Even team gets the point.\n\nBoth teams earned 1 point.\n\nHence, the answer would be \"Tie\".\n\n\n \nConstraints:\n\n\n\tThe number of nodes in the list is in the range [2, 100].\n\tThe number of nodes in the list is even.\n\t1 <= Node.val <= 100\n\tThe value of each odd-indexed node is odd.\n\tThe value of each even-indexed node is even.\n\n\n",
  "3063": "\n[3063] Linked List Frequency is on the run...\n\n\nGiven the head of a linked list containing k distinct elements, return the head to a linked list of length k containing the frequency of each distinct element in the given linked list in any order.\n\n \nExample 1: \n\n\nInput:   head = [1,1,2,1,2,3] \n\nOutput:   [3,2,1] \n\nExplanation:  There are 3 distinct elements in the list. The frequency of 1 is 3, the frequency of 2 is 2 and the frequency of 3 is 1. Hence, we return 3 -> 2 -> 1.\n\nNote that 1 -> 2 -> 3, 1 -> 3 -> 2, 2 -> 1 -> 3, 2 -> 3 -> 1, and 3 -> 1 -> 2 are also valid answers.\n\n\nExample 2: \n\n\nInput:   head = [1,1,2,2,2] \n\nOutput:   [2,3] \n\nExplanation:  There are 2 distinct elements in the list. The frequency of 1 is 2 and the frequency of 2 is 3. Hence, we return 2 -> 3.\n\n\nExample 3: \n\n\nInput:   head = [6,5,4,3,2,1] \n\nOutput:   [1,1,1,1,1,1] \n\nExplanation:  There are 6 distinct elements in the list. The frequency of each of them is 1. Hence, we return 1 -> 1 -> 1 -> 1 -> 1 -> 1.\n\n\n \nConstraints:\n\n\n\tThe number of nodes in the list is in the range [1, 10⁵].\n\t1 <= Node.val <= 10⁵\n\n\n",
  "3064": "\n[3064] Guess the Number Using Bitwise Questions I is on the run...\n\n\nThere is a number n that you have to find.\n\nThere is also a pre-defined API int commonSetBits(int num), which returns the number of bits where both n and num are 1 in that position of their binary representation. In other words, it returns the number of set bits in n & num, where & is the bitwise AND operator.\n\nReturn the number n.\n\n \nExample 1: \n\n\nInput:   n = 31 \n\nOutput:   31 \n\nExplanation:  It can be proven that it's possible to find 31 using the provided API.\n\n\nExample 2: \n\n\nInput:   n = 33 \n\nOutput:   33 \n\nExplanation:  It can be proven that it's possible to find 33 using the provided API.\n\n\n \nConstraints:\n\n\n\t1 <= n <= 2³⁰ - 1\n\t0 <= num <= 2³⁰ - 1\n\tIf you ask for some num out of the given range, the output wouldn't be reliable.\n\n\n",
  "3065": "\n[3065] Minimum Operations to Exceed Threshold Value I is on the run...\n\n\nYou are given a 0-indexed integer array nums, and an integer k.\n\nIn one operation, you can remove one occurrence of the smallest element of nums.\n\nReturn the minimum number of operations needed so that all elements of the array are greater than or equal to k.\n\n \nExample 1:\n\nInput: nums = [2,11,10,1,3], k = 10\nOutput: 3\nExplanation: After one operation, nums becomes equal to [2, 11, 10, 3].\nAfter two operations, nums becomes equal to [11, 10, 3].\nAfter three operations, nums becomes equal to [11, 10].\nAt this stage, all the elements of nums are greater than or equal to 10 so we can stop.\nIt can be shown that 3 is the minimum number of operations needed so that all elements of the array are greater than or equal to 10.\n\n\nExample 2:\n\nInput: nums = [1,1,2,4,9], k = 1\nOutput: 0\nExplanation: All elements of the array are greater than or equal to 1 so we do not need to apply any operations on nums.\n\nExample 3:\n\nInput: nums = [1,1,2,4,9], k = 9\nOutput: 4\nExplanation: only a single element of nums is greater than or equal to 9 so we need to apply the operations 4 times on nums.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 50\n\t1 <= nums[i] <= 10⁹\n\t1 <= k <= 10⁹\n\tThe input is generated such that there is at least one index i such that nums[i] >= k.\n\n\n",
  "3066": "\n[3066] Minimum Operations to Exceed Threshold Value II is on the run...\n\n\nYou are given a 0-indexed integer array nums, and an integer k.\n\nYou are allowed to perform some operations on nums, where in a single operation, you can:\n\n\n\tSelect the two smallest integers x and y from nums.\n\tRemove x and y from nums.\n\tInsert (min(x, y) * 2 + max(x, y)) at any position in the array.\n\n\nNote that you can only apply the described operation if nums contains at least two elements.\n\nReturn the minimum number of operations needed so that all elements of the array are greater than or equal to k.\n\n \nExample 1:\n\n\nInput: nums = [2,11,10,1,3], k = 10\n\nOutput: 2\n\nExplanation:\n\n\n\tIn the first operation, we remove elements 1 and 2, then add 1 * 2 + 2 to nums. nums becomes equal to [4, 11, 10, 3].\n\tIn the second operation, we remove elements 3 and 4, then add 3 * 2 + 4 to nums. nums becomes equal to [10, 11, 10].\n\n\nAt this stage, all the elements of nums are greater than or equal to 10 so we can stop. \n\nIt can be shown that 2 is the minimum number of operations needed so that all elements of the array are greater than or equal to 10.\n\n\nExample 2:\n\n\nInput: nums = [1,1,2,4,9], k = 20\n\nOutput: 4\n\nExplanation:\n\n\n\tAfter one operation, nums becomes equal to [2, 4, 9, 3]. \n\tAfter two operations, nums becomes equal to [7, 4, 9]. \n\tAfter three operations, nums becomes equal to [15, 9]. \n\tAfter four operations, nums becomes equal to [33].\n\n\nAt this stage, all the elements of nums are greater than 20 so we can stop. \n\nIt can be shown that 4 is the minimum number of operations needed so that all elements of the array are greater than or equal to 20.\n\n\n \nConstraints:\n\n\n\t2 <= nums.length <= 2 * 10⁵\n\t1 <= nums[i] <= 10⁹\n\t1 <= k <= 10⁹\n\tThe input is generated such that an answer always exists. That is, after performing some number of operations, all elements of the array are greater than or equal to k.\n\n\n",
  "3067": "\n[3067] Count Pairs of Connectable Servers in a Weighted Tree Network is on the run...\n\n\nYou are given an unrooted weighted tree with n vertices representing servers numbered from 0 to n - 1, an array edges where edges[i] = [ai, bi, weighti] represents a bidirectional edge between vertices ai and bi of weight weighti. You are also given an integer signalSpeed.\n\nTwo servers a and b are connectable through a server c if:\n\n\n\ta < b, a != c and b != c.\n\tThe distance from c to a is divisible by signalSpeed.\n\tThe distance from c to b is divisible by signalSpeed.\n\tThe path from c to b and the path from c to a do not share any edges.\n\n\nReturn an integer array count of length n where count[i] is the number of server pairs that are connectable through the server i.\n\n \nExample 1:\n\nInput: edges = [[0,1,1],[1,2,5],[2,3,13],[3,4,9],[4,5,2]], signalSpeed = 1\nOutput: [0,4,6,6,4,0]\nExplanation: Since signalSpeed is 1, count[c] is equal to the number of pairs of paths that start at c and do not share any edges.\nIn the case of the given path graph, count[c] is equal to the number of servers to the left of c multiplied by the servers to the right of c.\n\n\nExample 2:\n\nInput: edges = [[0,6,3],[6,5,3],[0,3,1],[3,2,7],[3,1,6],[3,4,2]], signalSpeed = 3\nOutput: [2,0,0,0,0,0,2]\nExplanation: Through server 0, there are 2 pairs of connectable servers: (4, 5) and (4, 6).\nThrough server 6, there are 2 pairs of connectable servers: (4, 5) and (0, 5).\nIt can be shown that no two servers are connectable through servers other than 0 and 6.\n\n\n \nConstraints:\n\n\n\t2 <= n <= 1000\n\tedges.length == n - 1\n\tedges[i].length == 3\n\t0 <= ai, bi < n\n\tedges[i] = [ai, bi, weighti]\n\t1 <= weighti <= 10⁶\n\t1 <= signalSpeed <= 10⁶\n\tThe input is generated such that edges represents a valid tree.\n\n\n",
  "3068": "\n[3068] Find the Maximum Sum of Node Values is on the run...\n\n\nThere exists an undirected tree with n nodes numbered 0 to n - 1. You are given a 0-indexed 2D integer array edges of length n - 1, where edges[i] = [ui, vi] indicates that there is an edge between nodes ui and vi in the tree. You are also given a positive integer k, and a 0-indexed array of non-negative integers nums of length n, where nums[i] represents the value of the node numbered i.\n\nAlice wants the sum of values of tree nodes to be maximum, for which Alice can perform the following operation any number of times (including zero) on the tree:\n\n\n\tChoose any edge [u, v] connecting the nodes u and v, and update their values as follows:\n\n\t\n\t\tnums[u] = nums[u] XOR k\n\t\tnums[v] = nums[v] XOR k\n\t\n\t\n\n\nReturn the maximum possible sum of the values Alice can achieve by performing the operation any number of times.\n\n \nExample 1:\n\nInput: nums = [1,2,1], k = 3, edges = [[0,1],[0,2]]\nOutput: 6\nExplanation: Alice can achieve the maximum sum of 6 using a single operation:\n- Choose the edge [0,2]. nums[0] and nums[2] become: 1 XOR 3 = 2, and the array nums becomes: [1,2,1] -> [2,2,2].\nThe total sum of values is 2 + 2 + 2 = 6.\nIt can be shown that 6 is the maximum achievable sum of values.\n\n\nExample 2:\n\nInput: nums = [2,3], k = 7, edges = [[0,1]]\nOutput: 9\nExplanation: Alice can achieve the maximum sum of 9 using a single operation:\n- Choose the edge [0,1]. nums[0] becomes: 2 XOR 7 = 5 and nums[1] become: 3 XOR 7 = 4, and the array nums becomes: [2,3] -> [5,4].\nThe total sum of values is 5 + 4 = 9.\nIt can be shown that 9 is the maximum achievable sum of values.\n\n\nExample 3:\n\nInput: nums = [7,7,7,7,7,7], k = 3, edges = [[0,1],[0,2],[0,3],[0,4],[0,5]]\nOutput: 42\nExplanation: The maximum achievable sum is 42 which can be achieved by Alice performing no operations.\n\n\n \nConstraints:\n\n\n\t2 <= n == nums.length <= 2 * 10⁴\n\t1 <= k <= 10⁹\n\t0 <= nums[i] <= 10⁹\n\tedges.length == n - 1\n\tedges[i].length == 2\n\t0 <= edges[i][0], edges[i][1] <= n - 1\n\tThe input is generated such that edges represent a valid tree.\n\n\n",
  "3069": "\n[3069] Distribute Elements Into Two Arrays I is on the run...\n\n\nYou are given a 1-indexed array of distinct integers nums of length n.\n\nYou need to distribute all the elements of nums between two arrays arr1 and arr2 using n operations. In the first operation, append nums[1] to arr1. In the second operation, append nums[2] to arr2. Afterwards, in the ith operation:\n\n\n\tIf the last element of arr1 is greater than the last element of arr2, append nums[i] to arr1. Otherwise, append nums[i] to arr2.\n\n\nThe array result is formed by concatenating the arrays arr1 and arr2. For example, if arr1 == [1,2,3] and arr2 == [4,5,6], then result = [1,2,3,4,5,6].\n\nReturn the array result.\n\n \nExample 1:\n\nInput: nums = [2,1,3]\nOutput: [2,3,1]\nExplanation: After the first 2 operations, arr1 = [2] and arr2 = [1].\nIn the 3rd operation, as the last element of arr1 is greater than the last element of arr2 (2 > 1), append nums[3] to arr1.\nAfter 3 operations, arr1 = [2,3] and arr2 = [1].\nHence, the array result formed by concatenation is [2,3,1].\n\n\nExample 2:\n\nInput: nums = [5,4,3,8]\nOutput: [5,3,4,8]\nExplanation: After the first 2 operations, arr1 = [5] and arr2 = [4].\nIn the 3rd operation, as the last element of arr1 is greater than the last element of arr2 (5 > 4), append nums[3] to arr1, hence arr1 becomes [5,3].\nIn the 4th operation, as the last element of arr2 is greater than the last element of arr1 (4 > 3), append nums[4] to arr2, hence arr2 becomes [4,8].\nAfter 4 operations, arr1 = [5,3] and arr2 = [4,8].\nHence, the array result formed by concatenation is [5,3,4,8].\n\n\n \nConstraints:\n\n\n\t3 <= n <= 50\n\t1 <= nums[i] <= 100\n\tAll elements in nums are distinct.\n\n\n",
  "3070": "\n[3070] Count Submatrices with Top-Left Element and Sum Less Than k is on the run...\n\n\nYou are given a 0-indexed integer matrix grid and an integer k.\n\nReturn the number of submatrices that contain the top-left element of the grid, and have a sum less than or equal to k.\n\n \nExample 1:\n\nInput: grid = [[7,6,3],[6,6,1]], k = 18\nOutput: 4\nExplanation: There are only 4 submatrices, shown in the image above, that contain the top-left element of grid, and have a sum less than or equal to 18.\n\nExample 2:\n\nInput: grid = [[7,2,9],[1,5,0],[2,6,6]], k = 20\nOutput: 6\nExplanation: There are only 6 submatrices, shown in the image above, that contain the top-left element of grid, and have a sum less than or equal to 20.\n\n\n \nConstraints:\n\n\n\tm == grid.length \n\tn == grid[i].length\n\t1 <= n, m <= 1000 \n\t0 <= grid[i][j] <= 1000\n\t1 <= k <= 10⁹\n\n\n",
  "3071": "\n[3071] Minimum Operations to Write the Letter Y on a Grid is on the run...\n\n\nYou are given a 0-indexed n x n grid where n is odd, and grid[r][c] is 0, 1, or 2.\n\nWe say that a cell belongs to the Letter Y if it belongs to one of the following:\n\n\n\tThe diagonal starting at the top-left cell and ending at the center cell of the grid.\n\tThe diagonal starting at the top-right cell and ending at the center cell of the grid.\n\tThe vertical line starting at the center cell and ending at the bottom border of the grid.\n\n\nThe Letter Y is written on the grid if and only if:\n\n\n\tAll values at cells belonging to the Y are equal.\n\tAll values at cells not belonging to the Y are equal.\n\tThe values at cells belonging to the Y are different from the values at cells not belonging to the Y.\n\n\nReturn the minimum number of operations needed to write the letter Y on the grid given that in one operation you can change the value at any cell to 0, 1, or 2.\n\n \nExample 1:\n\nInput: grid = [[1,2,2],[1,1,0],[0,1,0]]\nOutput: 3\nExplanation: We can write Y on the grid by applying the changes highlighted in blue in the image above. After the operations, all cells that belong to Y, denoted in bold, have the same value of 1 while those that do not belong to Y are equal to 0.\nIt can be shown that 3 is the minimum number of operations needed to write Y on the grid.\n\n\nExample 2:\n\nInput: grid = [[0,1,0,1,0],[2,1,0,1,2],[2,2,2,0,1],[2,2,2,2,2],[2,1,2,2,2]]\nOutput: 12\nExplanation: We can write Y on the grid by applying the changes highlighted in blue in the image above. After the operations, all cells that belong to Y, denoted in bold, have the same value of 0 while those that do not belong to Y are equal to 2. \nIt can be shown that 12 is the minimum number of operations needed to write Y on the grid.\n\n \nConstraints:\n\n\n\t3 <= n <= 49 \n\tn == grid.length == grid[i].length\n\t0 <= grid[i][j] <= 2\n\tn is odd.\n\n\n",
  "3072": "\n[3072] Distribute Elements Into Two Arrays II is on the run...\n\n\nYou are given a 1-indexed array of integers nums of length n.\n\nWe define a function greaterCount such that greaterCount(arr, val) returns the number of elements in arr that are strictly greater than val.\n\nYou need to distribute all the elements of nums between two arrays arr1 and arr2 using n operations. In the first operation, append nums[1] to arr1. In the second operation, append nums[2] to arr2. Afterwards, in the ith operation:\n\n\n\tIf greaterCount(arr1, nums[i]) > greaterCount(arr2, nums[i]), append nums[i] to arr1.\n\tIf greaterCount(arr1, nums[i]) < greaterCount(arr2, nums[i]), append nums[i] to arr2.\n\tIf greaterCount(arr1, nums[i]) == greaterCount(arr2, nums[i]), append nums[i] to the array with a lesser number of elements.\n\tIf there is still a tie, append nums[i] to arr1.\n\n\nThe array result is formed by concatenating the arrays arr1 and arr2. For example, if arr1 == [1,2,3] and arr2 == [4,5,6], then result = [1,2,3,4,5,6].\n\nReturn the integer array result.\n\n \nExample 1:\n\nInput: nums = [2,1,3,3]\nOutput: [2,3,1,3]\nExplanation: After the first 2 operations, arr1 = [2] and arr2 = [1].\nIn the 3rd operation, the number of elements greater than 3 is zero in both arrays. Also, the lengths are equal, hence, append nums[3] to arr1.\nIn the 4th operation, the number of elements greater than 3 is zero in both arrays. As the length of arr2 is lesser, hence, append nums[4] to arr2.\nAfter 4 operations, arr1 = [2,3] and arr2 = [1,3].\nHence, the array result formed by concatenation is [2,3,1,3].\n\n\nExample 2:\n\nInput: nums = [5,14,3,1,2]\nOutput: [5,3,1,2,14]\nExplanation: After the first 2 operations, arr1 = [5] and arr2 = [14].\nIn the 3rd operation, the number of elements greater than 3 is one in both arrays. Also, the lengths are equal, hence, append nums[3] to arr1.\nIn the 4th operation, the number of elements greater than 1 is greater in arr1 than arr2 (2 > 1). Hence, append nums[4] to arr1.\nIn the 5th operation, the number of elements greater than 2 is greater in arr1 than arr2 (2 > 1). Hence, append nums[5] to arr1.\nAfter 5 operations, arr1 = [5,3,1,2] and arr2 = [14].\nHence, the array result formed by concatenation is [5,3,1,2,14].\n\n\nExample 3:\n\nInput: nums = [3,3,3,3]\nOutput: [3,3,3,3]\nExplanation: At the end of 4 operations, arr1 = [3,3] and arr2 = [3,3].\nHence, the array result formed by concatenation is [3,3,3,3].\n\n\n \nConstraints:\n\n\n\t3 <= n <= 10⁵\n\t1 <= nums[i] <= 10⁹\n\n\n",
  "3073": "\n[3073] Maximum Increasing Triplet Value is on the run...\n\n\nGiven an array nums, return the maximum value of a triplet (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k].\n\nThe value of a triplet (i, j, k) is nums[i] - nums[j] + nums[k].\n\n\n \n\n\n \nExample 1: \n\n\nInput:  nums = [5,6,9] \n\nOutput:  8 \n\nExplanation:  We only have one choice for an increasing triplet and that is choosing all three elements. The value of this triplet would be 5 - 6 + 9 = 8.\n\n\nExample 2: \n\n\nInput:  nums = [1,5,3,6] \n\nOutput:  4 \n\nExplanation:  There are only two increasing triplets:\n\n(0, 1, 3): The value of this triplet is nums[0] - nums[1] + nums[3] = 1 - 5 + 6 = 2.\n\n(0, 2, 3): The value of this triplet is nums[0] - nums[2] + nums[3] = 1 - 3 + 6 = 4.\n\nThus the answer would be 4.\n\n\n \nConstraints:\n\n\n\t3 <= nums.length <= 10⁵\n\t1 <= nums[i] <= 10⁹\n\tThe input is generated such that at least one triplet meets the given condition.\n\n\n",
  "3074": "\n[3074] Apple Redistribution into Boxes is on the run...\n\n\nYou are given an array apple of size n and an array capacity of size m.\n\nThere are n packs where the ith pack contains apple[i] apples. There are m boxes as well, and the ith box has a capacity of capacity[i] apples.\n\nReturn the minimum number of boxes you need to select to redistribute these n packs of apples into boxes.\n\nNote that, apples from the same pack can be distributed into different boxes.\n\n \nExample 1:\n\nInput: apple = [1,3,2], capacity = [4,3,1,5,2]\nOutput: 2\nExplanation: We will use boxes with capacities 4 and 5.\nIt is possible to distribute the apples as the total capacity is greater than or equal to the total number of apples.\n\n\nExample 2:\n\nInput: apple = [5,5,5], capacity = [2,4,2,7]\nOutput: 4\nExplanation: We will need to use all the boxes.\n\n\n \nConstraints:\n\n\n\t1 <= n == apple.length <= 50\n\t1 <= m == capacity.length <= 50\n\t1 <= apple[i], capacity[i] <= 50\n\tThe input is generated such that it's possible to redistribute packs of apples into boxes.\n\n\n",
  "3075": "\n[3075] Maximize Happiness of Selected Children is on the run...\n\n\nYou are given an array happiness of length n, and a positive integer k.\n\nThere are n children standing in a queue, where the ith child has happiness value happiness[i]. You want to select k children from these n children in k turns.\n\nIn each turn, when you select a child, the happiness value of all the children that have not been selected till now decreases by 1. Note that the happiness value cannot become negative and gets decremented only if it is positive.\n\nReturn the maximum sum of the happiness values of the selected children you can achieve by selecting k children.\n\n \nExample 1:\n\nInput: happiness = [1,2,3], k = 2\nOutput: 4\nExplanation: We can pick 2 children in the following way:\n- Pick the child with the happiness value == 3. The happiness value of the remaining children becomes [0,1].\n- Pick the child with the happiness value == 1. The happiness value of the remaining child becomes [0]. Note that the happiness value cannot become less than 0.\nThe sum of the happiness values of the selected children is 3 + 1 = 4.\n\n\nExample 2:\n\nInput: happiness = [1,1,1,1], k = 2\nOutput: 1\nExplanation: We can pick 2 children in the following way:\n- Pick any child with the happiness value == 1. The happiness value of the remaining children becomes [0,0,0].\n- Pick the child with the happiness value == 0. The happiness value of the remaining child becomes [0,0].\nThe sum of the happiness values of the selected children is 1 + 0 = 1.\n\n\nExample 3:\n\nInput: happiness = [2,3,4,5], k = 1\nOutput: 5\nExplanation: We can pick 1 child in the following way:\n- Pick the child with the happiness value == 5. The happiness value of the remaining children becomes [1,2,3].\nThe sum of the happiness values of the selected children is 5.\n\n\n \nConstraints:\n\n\n\t1 <= n == happiness.length <= 2 * 10⁵\n\t1 <= happiness[i] <= 10⁸\n\t1 <= k <= n\n\n\n",
  "3076": "\n[3076] Shortest Uncommon Substring in an Array is on the run...\n\n\nYou are given an array arr of size n consisting of non-empty strings.\n\nFind a string array answer of size n such that:\n\n\n\tanswer[i] is the shortest substring of arr[i] that does not occur as a substring in any other string in arr. If multiple such substrings exist, answer[i] should be the lexicographically smallest. And if no such substring exists, answer[i] should be an empty string.\n\n\nReturn the array answer.\n\n \nExample 1:\n\nInput: arr = [\"cab\",\"ad\",\"bad\",\"c\"]\nOutput: [\"ab\",\"\",\"ba\",\"\"]\nExplanation: We have the following:\n- For the string \"cab\", the shortest substring that does not occur in any other string is either \"ca\" or \"ab\", we choose the lexicographically smaller substring, which is \"ab\".\n- For the string \"ad\", there is no substring that does not occur in any other string.\n- For the string \"bad\", the shortest substring that does not occur in any other string is \"ba\".\n- For the string \"c\", there is no substring that does not occur in any other string.\n\n\nExample 2:\n\nInput: arr = [\"abc\",\"bcd\",\"abcd\"]\nOutput: [\"\",\"\",\"abcd\"]\nExplanation: We have the following:\n- For the string \"abc\", there is no substring that does not occur in any other string.\n- For the string \"bcd\", there is no substring that does not occur in any other string.\n- For the string \"abcd\", the shortest substring that does not occur in any other string is \"abcd\".\n\n\n \nConstraints:\n\n\n\tn == arr.length\n\t2 <= n <= 100\n\t1 <= arr[i].length <= 20\n\tarr[i] consists only of lowercase English letters.\n\n\n",
  "3077": "\n[3077] Maximum Strength of K Disjoint Subarrays is on the run...\n\n\nYou are given an array of integers nums with length n, and a positive odd integer k.\n\nSelect exactly k disjoint subarrays sub₁, sub₂, ..., subk from nums such that the last element of subi appears before the first element of sub{i+1} for all 1 <= i <= k-1. The goal is to maximize their combined strength.\n\nThe strength of the selected subarrays is defined as:\n\nstrength = k * sum(sub₁)- (k - 1) * sum(sub₂) + (k - 2) * sum(sub₃) - ... - 2 * sum(sub{k-1}) + sum(subk)\n\nwhere sum(subi) is the sum of the elements in the i-th subarray.\n\nReturn the maximum possible strength that can be obtained from selecting exactly k disjoint subarrays from nums.\n\nNote that the chosen subarrays don't need to cover the entire array.\n\n \nExample 1:\n\nInput: nums = [1,2,3,-1,2], k = 3\n\nOutput: 22\n\nExplanation:\n\nThe best possible way to select 3 subarrays is: nums[0..2], nums[3..3], and nums[4..4]. The strength is calculated as follows:\n\nstrength = 3 * (1 + 2 + 3) - 2 * (-1) + 2 = 22\n\n \n\nExample 2:\n\nInput: nums = [12,-2,-2,-2,-2], k = 5\n\nOutput: 64\n\nExplanation:\n\nThe only possible way to select 5 disjoint subarrays is: nums[0..0], nums[1..1], nums[2..2], nums[3..3], and nums[4..4]. The strength is calculated as follows:\n\nstrength = 5 * 12 - 4 * (-2) + 3 * (-2) - 2 * (-2) + (-2) = 64\n\nExample 3:\n\nInput: nums = [-1,-2,-3], k = 1\n\nOutput: -1\n\nExplanation:\n\nThe best possible way to select 1 subarray is: nums[0..0]. The strength is -1.\n\n \nConstraints:\n\n\n\t1 <= n <= 10⁴\n\t-10⁹ <= nums[i] <= 10⁹\n\t1 <= k <= n\n\t1 <= n * k <= 10⁶\n\tk is odd.\n\n\n",
  "3078": "\n[3078] Match Alphanumerical Pattern in Matrix I is on the run...\n\n\nYou are given a 2D integer matrix board and a 2D character matrix pattern. Where 0 <= board[r][c] <= 9 and each element of pattern is either a digit or a lowercase English letter.\n\nYour task is to find a submatrix of board that matches pattern.\n\nAn integer matrix part matches pattern if we can replace cells containing letters in pattern with some digits (each distinct letter with a unique digit) in such a way that the resulting matrix becomes identical to the integer matrix part. In other words,\n\n\n\tThe matrices have identical dimensions.\n\tIf pattern[r][c] is a digit, then part[r][c] must be the same digit.\n\tIf pattern[r][c] is a letter x:\n\t\n\t\tFor every pattern[i][j] == x, part[i][j] must be the same as part[r][c].\n\t\tFor every pattern[i][j] != x, part[i][j] must be different than part[r][c]. \n\t\n\t\n\n\nReturn an array of length 2 containing the row number and column number of the upper-left corner of a submatrix of board which matches pattern. If there is more than one such submatrix, return the coordinates of the submatrix with the lowest row index, and in case there is still a tie, return the coordinates of the submatrix with the lowest column index. If there are no suitable answers, return [-1, -1].\n\n \nExample 1:\n\n\n\n\t\n\t\t\n\t\t\t1\n\t\t\t2\n\t\t\t2\n\t\t\n\t\t\n\t\t\t2\n\t\t\t2\n\t\t\t3\n\t\t\n\t\t\n\t\t\t2\n\t\t\t3\n\t\t\t3\n\t\t\n\t\n\n\n\n\t\n\t\t\n\t\t\ta\n\t\t\tb\n\t\t\n\t\t\n\t\t\tb\n\t\t\tb\n\t\t\n\t\n\n\n\n\nInput: board = [[1,2,2],[2,2,3],[2,3,3]], pattern = [\"ab\",\"bb\"]\n\nOutput: [0,0]\n\nExplanation: If we consider this mapping: \"a\" -> 1 and \"b\" -> 2; the submatrix with the upper-left corner (0,0) is a match as outlined in the matrix above.\n\nNote that the submatrix with the upper-left corner (1,1) is also a match but since it comes after the other one, we return [0,0].\n\n\nExample 2:\n\n\n\n\t\n\t\t\n\t\t\t1\n\t\t\t1\n\t\t\t2\n\t\t\n\t\t\n\t\t\t3\n\t\t\t3\n\t\t\t4\n\t\t\n\t\t\n\t\t\t6\n\t\t\t6\n\t\t\t6\n\t\t\n\t\n\n\n\n\t\n\t\t\n\t\t\ta\n\t\t\tb\n\t\t\n\t\t\n\t\t\t6\n\t\t\t6\n\t\t\n\t\n\n\n\n\nInput: board = [[1,1,2],[3,3,4],[6,6,6]], pattern = [\"ab\",\"66\"]\n\nOutput: [1,1]\n\nExplanation: If we consider this mapping: \"a\" -> 3 and \"b\" -> 4; the submatrix with the upper-left corner (1,1) is a match as outlined in the matrix above.\n\nNote that since the corresponding values of \"a\" and \"b\" must differ, the submatrix with the upper-left corner (1,0) is not a match. Hence, we return [1,1].\n\n\nExample 3:\n\n\n\n\t\n\t\t\n\t\t\t1\n\t\t\t2\n\t\t\n\t\t\n\t\t\t2\n\t\t\t1\n\t\t\n\t\n\n\n\n\t\n\t\t\n\t\t\tx\n\t\t\tx\n\t\t\n\t\n\n\n\n\nInput: board = [[1,2],[2,1]], pattern = [\"xx\"]\n\nOutput: [-1,-1]\n\nExplanation: Since the values of the matched submatrix must be the same, there is no match. Hence, we return [-1,-1].\n\n\n \nConstraints:\n\n\n\t1 <= board.length <= 50\n\t1 <= board[i].length <= 50\n\t0 <= board[i][j] <= 9\n\t1 <= pattern.length <= 50\n\t1 <= pattern[i].length <= 50\n\tpattern[i][j] is either a digit represented as a string or a lowercase English letter.\n\n\n",
  "3079": "\n[3079] Find the Sum of Encrypted Integers is on the run...\n\n\nYou are given an integer array nums containing positive integers. We define a function encrypt such that encrypt(x) replaces every digit in x with the largest digit in x. For example, encrypt(523) = 555 and encrypt(213) = 333.\n\nReturn the sum of encrypted elements.\n\n \nExample 1:\n\n\nInput: nums = [1,2,3]\n\nOutput: 6\n\nExplanation: The encrypted elements are [1,2,3]. The sum of encrypted elements is 1 + 2 + 3 == 6.\n\n\nExample 2:\n\n\nInput: nums = [10,21,31]\n\nOutput: 66\n\nExplanation: The encrypted elements are [11,22,33]. The sum of encrypted elements is 11 + 22 + 33 == 66.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 50\n\t1 <= nums[i] <= 1000\n\n\n",
  "3080": "\n[3080] Mark Elements on Array by Performing Queries is on the run...\n\n\nYou are given a 0-indexed array nums of size n consisting of positive integers.\n\nYou are also given a 2D array queries of size m where queries[i] = [indexi, ki].\n\nInitially all elements of the array are unmarked.\n\nYou need to apply m queries on the array in order, where on the ith query you do the following:\n\n\n\tMark the element at index indexi if it is not already marked.\n\tThen mark ki unmarked elements in the array with the smallest values. If multiple such elements exist, mark the ones with the smallest indices. And if less than ki unmarked elements exist, then mark all of them.\n\n\nReturn an array answer of size m where answer[i] is the sum of unmarked elements in the array after the ith query.\n\n \nExample 1:\n\n\nInput: nums = [1,2,2,1,2,3,1], queries = [[1,2],[3,3],[4,2]]\n\nOutput: [8,3,0]\n\nExplanation:\n\nWe do the following queries on the array:\n\n\n\tMark the element at index 1, and 2 of the smallest unmarked elements with the smallest indices if they exist, the marked elements now are nums = [1,2,2,1,2,3,1]. The sum of unmarked elements is 2 + 2 + 3 + 1 = 8.\n\tMark the element at index 3, since it is already marked we skip it. Then we mark 3 of the smallest unmarked elements with the smallest indices, the marked elements now are nums = [1,2,2,1,2,3,1]. The sum of unmarked elements is 3.\n\tMark the element at index 4, since it is already marked we skip it. Then we mark 2 of the smallest unmarked elements with the smallest indices if they exist, the marked elements now are nums = [1,2,2,1,2,3,1]. The sum of unmarked elements is 0.\n\n\n\nExample 2:\n\n\nInput: nums = [1,4,2,3], queries = [[0,1]]\n\nOutput: [7]\n\nExplanation:  We do one query which is mark the element at index 0 and mark the smallest element among unmarked elements. The marked elements will be nums = [1,4,2,3], and the sum of unmarked elements is 4 + 3 = 7.\n\n\n \nConstraints:\n\n\n\tn == nums.length\n\tm == queries.length\n\t1 <= m <= n <= 10⁵\n\t1 <= nums[i] <= 10⁵\n\tqueries[i].length == 2\n\t0 <= indexi, ki <= n - 1\n\n\n",
  "3081": "\n[3081] Replace Question Marks in String to Minimize Its Value is on the run...\n\n\nYou are given a string s. s[i] is either a lowercase English letter or '?'.\n\nFor a string t having length m containing only lowercase English letters, we define the function cost(i) for an index i as the number of characters equal to t[i] that appeared before it, i.e. in the range [0, i - 1].\n\nThe value of t is the sum of cost(i) for all indices i.\n\nFor example, for the string t = \"aab\":\n\n\n\tcost(0) = 0\n\tcost(1) = 1\n\tcost(2) = 0\n\tHence, the value of \"aab\" is 0 + 1 + 0 = 1.\n\n\nYour task is to replace all occurrences of '?' in s with any lowercase English letter so that the value of s is minimized.\n\nReturn a string denoting the modified string with replaced occurrences of '?'. If there are multiple strings resulting in the minimum value, return the lexicographically smallest one.\n\n \nExample 1:\n\n\nInput:   s = \"???\" \n\nOutput:   \"abc\" \n\nExplanation:  In this example, we can replace the occurrences of '?' to make s equal to \"abc\".\n\nFor \"abc\", cost(0) = 0, cost(1) = 0, and cost(2) = 0.\n\nThe value of \"abc\" is 0.\n\nSome other modifications of s that have a value of 0 are \"cba\", \"abz\", and, \"hey\".\n\nAmong all of them, we choose the lexicographically smallest.\n\n\nExample 2:\n\n\nInput:  s = \"a?a?\"\n\nOutput:  \"abac\"\n\nExplanation:  In this example, the occurrences of '?' can be replaced to make s equal to \"abac\".\n\nFor \"abac\", cost(0) = 0, cost(1) = 0, cost(2) = 1, and cost(3) = 0.\n\nThe value of \"abac\" is 1.\n\n\n \nConstraints:\n\n\n\t1 <= s.length <= 10⁵\n\ts[i] is either a lowercase English letter or '?'.\n\n\n",
  "3082": "\n[3082] Find the Sum of the Power of All Subsequences is on the run...\n\n\nYou are given an integer array nums of length n and a positive integer k.\n\nThe power of an array of integers is defined as the number of subsequences with their sum equal to k.\n\nReturn the sum of power of all subsequences of nums.\n\nSince the answer may be very large, return it modulo 10⁹ + 7.\n\n \nExample 1:\n\n\nInput:   nums = [1,2,3], k = 3 \n\nOutput:   6 \n\nExplanation:\n\nThere are 5 subsequences of nums with non-zero power:\n\n\n\tThe subsequence [1,2,3] has 2 subsequences with sum == 3: [1,2,3] and [1,2,3].\n\tThe subsequence [1,2,3] has 1 subsequence with sum == 3: [1,2,3].\n\tThe subsequence [1,2,3] has 1 subsequence with sum == 3: [1,2,3].\n\tThe subsequence [1,2,3] has 1 subsequence with sum == 3: [1,2,3].\n\tThe subsequence [1,2,3] has 1 subsequence with sum == 3: [1,2,3].\n\n\nHence the answer is 2 + 1 + 1 + 1 + 1 = 6.\n\n\nExample 2:\n\n\nInput:   nums = [2,3,3], k = 5 \n\nOutput:   4 \n\nExplanation:\n\nThere are 3 subsequences of nums with non-zero power:\n\n\n\tThe subsequence [2,3,3] has 2 subsequences with sum == 5: [2,3,3] and [2,3,3].\n\tThe subsequence [2,3,3] has 1 subsequence with sum == 5: [2,3,3].\n\tThe subsequence [2,3,3] has 1 subsequence with sum == 5: [2,3,3].\n\n\nHence the answer is 2 + 1 + 1 = 4.\n\n\nExample 3:\n\n\nInput:   nums = [1,2,3], k = 7 \n\nOutput:   0 \n\nExplanation: There exists no subsequence with sum 7. Hence all subsequences of nums have power = 0.\n\n\n \nConstraints:\n\n\n\t1 <= n <= 100\n\t1 <= nums[i] <= 10⁴\n\t1 <= k <= 100\n\n\n",
  "3083": "\n[3083] Existence of a Substring in a String and Its Reverse is on the run...\n\n\nGiven a string s, find any substring of length 2 which is also present in the reverse of s.\n\nReturn true if such a substring exists, and false otherwise.\n\n \nExample 1:\n\n\nInput: s = \"leetcode\"\n\nOutput: true\n\nExplanation: Substring \"ee\" is of length 2 which is also present in reverse(s) == \"edocteel\".\n\n\nExample 2:\n\n\nInput: s = \"abcba\"\n\nOutput: true\n\nExplanation: All of the substrings of length 2 \"ab\", \"bc\", \"cb\", \"ba\" are also present in reverse(s) == \"abcba\".\n\n\nExample 3:\n\n\nInput: s = \"abcd\"\n\nOutput: false\n\nExplanation: There is no substring of length 2 in s, which is also present in the reverse of s.\n\n\n \nConstraints:\n\n\n\t1 <= s.length <= 100\n\ts consists only of lowercase English letters.\n\n\n",
  "3084": "\n[3084] Count Substrings Starting and Ending with Given Character is on the run...\n\n\nYou are given a string s and a character c. Return the total number of substrings of s that start and end with c.\n\n \nExample 1:\n\n\nInput: s = \"abada\", c = \"a\"\n\nOutput: 6\n\nExplanation: Substrings starting and ending with \"a\" are: \"abada\", \"abada\", \"abada\", \"abada\", \"abada\", \"abada\".\n\n\nExample 2:\n\n\nInput: s = \"zzz\", c = \"z\"\n\nOutput: 6\n\nExplanation: There are a total of 6 substrings in s and all start and end with \"z\".\n\n\n \nConstraints:\n\n\n\t1 <= s.length <= 10⁵\n\ts and c consist only of lowercase English letters.\n\n\n",
  "3085": "\n[3085] Minimum Deletions to Make String K-Special is on the run...\n\n\nYou are given a string word and an integer k.\n\nWe consider word to be k-special if |freq(word[i]) - freq(word[j])| <= k for all indices i and j in the string.\n\nHere, freq(x) denotes the frequency of the character x in word, and |y| denotes the absolute value of y.\n\nReturn the minimum number of characters you need to delete to make word k-special.\n\n \nExample 1:\n\n\nInput: word = \"aabcaba\", k = 0\n\nOutput: 3\n\nExplanation: We can make word 0-special by deleting 2 occurrences of \"a\" and 1 occurrence of \"c\". Therefore, word becomes equal to \"baba\" where freq('a') == freq('b') == 2.\n\n\nExample 2:\n\n\nInput: word = \"dabdcbdcdcd\", k = 2\n\nOutput: 2\n\nExplanation: We can make word 2-special by deleting 1 occurrence of \"a\" and 1 occurrence of \"d\". Therefore, word becomes equal to \"bdcbdcdcd\" where freq('b') == 2, freq('c') == 3, and freq('d') == 4.\n\n\nExample 3:\n\n\nInput: word = \"aaabaaa\", k = 2\n\nOutput: 1\n\nExplanation: We can make word 2-special by deleting 1 occurrence of \"b\". Therefore, word becomes equal to \"aaaaaa\" where each letter's frequency is now uniformly 6.\n\n\n \nConstraints:\n\n\n\t1 <= word.length <= 10⁵\n\t0 <= k <= 10⁵\n\tword consists only of lowercase English letters.\n\n\n",
  "3086": "\n[3086] Minimum Moves to Pick K Ones is on the run...\n\n\nYou are given a binary array nums of length n, a positive integer k and a non-negative integer maxChanges.\n\nAlice plays a game, where the goal is for Alice to pick up k ones from nums using the minimum number of moves. When the game starts, Alice picks up any index aliceIndex in the range [0, n - 1] and stands there. If nums[aliceIndex] == 1 , Alice picks up the one and nums[aliceIndex] becomes 0(this does not count as a move). After this, Alice can make any number of moves (including zero) where in each move Alice must perform exactly one of the following actions:\n\n\n\tSelect any index j != aliceIndex such that nums[j] == 0 and set nums[j] = 1. This action can be performed at most maxChanges times.\n\tSelect any two adjacent indices x and y (|x - y| == 1) such that nums[x] == 1, nums[y] == 0, then swap their values (set nums[y] = 1 and nums[x] = 0). If y == aliceIndex, Alice picks up the one after this move and nums[y] becomes 0.\n\n\nReturn the minimum number of moves required by Alice to pick exactly k ones.\n\n \nExample 1:\n\n\nInput: nums = [1,1,0,0,0,1,1,0,0,1], k = 3, maxChanges = 1\n\nOutput: 3\n\nExplanation: Alice can pick up 3 ones in 3 moves, if Alice performs the following actions in each move when standing at aliceIndex == 1:\n\n\n\tAt the start of the game Alice picks up the one and nums[1] becomes 0. nums becomes [1,0,0,0,0,1,1,0,0,1].\n\tSelect j == 2 and perform an action of the first type. nums becomes [1,0,1,0,0,1,1,0,0,1]\n\tSelect x == 2 and y == 1, and perform an action of the second type. nums becomes [1,1,0,0,0,1,1,0,0,1]. As y == aliceIndex, Alice picks up the one and nums becomes [1,0,0,0,0,1,1,0,0,1].\n\tSelect x == 0 and y == 1, and perform an action of the second type. nums becomes [0,1,0,0,0,1,1,0,0,1]. As y == aliceIndex, Alice picks up the one and nums becomes [0,0,0,0,0,1,1,0,0,1].\n\n\nNote that it may be possible for Alice to pick up 3 ones using some other sequence of 3 moves.\n\n\nExample 2:\n\n\nInput: nums = [0,0,0,0], k = 2, maxChanges = 3\n\nOutput: 4\n\nExplanation: Alice can pick up 2 ones in 4 moves, if Alice performs the following actions in each move when standing at aliceIndex == 0:\n\n\n\tSelect j == 1 and perform an action of the first type. nums becomes [0,1,0,0].\n\tSelect x == 1 and y == 0, and perform an action of the second type. nums becomes [1,0,0,0]. As y == aliceIndex, Alice picks up the one and nums becomes [0,0,0,0].\n\tSelect j == 1 again and perform an action of the first type. nums becomes [0,1,0,0].\n\tSelect x == 1 and y == 0 again, and perform an action of the second type. nums becomes [1,0,0,0]. As y == aliceIndex, Alice picks up the one and nums becomes [0,0,0,0].\n\n\n\n \nConstraints:\n\n\n\t2 <= n <= 10⁵\n\t0 <= nums[i] <= 1\n\t1 <= k <= 10⁵\n\t0 <= maxChanges <= 10⁵\n\tmaxChanges + sum(nums) >= k\n\n\n",
  "3087": "\n[3087] Find Trending Hashtags is on the run...\n\n\n",
  "3088": "\n[3088] Make String Anti-palindrome is on the run...\n\n\nWe call a string s of even length n an anti-palindrome if for each index 0 <= i < n, s[i] != s[n - i - 1].\n\nGiven a string s, your task is to make s an anti-palindrome by doing any number of operations (including zero).\n\nIn one operation, you can select two characters from s and swap them.\n\nReturn the resulting string. If multiple strings meet the conditions, return the lexicographically smallest one. If it can't be made into an anti-palindrome, return \"-1\".\n\n \nExample 1:\n\n\nInput: s = \"abca\"\n\nOutput: \"aabc\"\n\nExplanation:\n\n\"aabc\" is an anti-palindrome string since s[0] != s[3] and s[1] != s[2]. Also, it is a rearrangement of \"abca\".\n\n\nExample 2:\n\n\nInput: s = \"abba\"\n\nOutput: \"aabb\"\n\nExplanation:\n\n\"aabb\" is an anti-palindrome string since s[0] != s[3] and s[1] != s[2]. Also, it is a rearrangement of \"abba\".\n\n\nExample 3:\n\n\nInput: s = \"cccd\"\n\nOutput: \"-1\"\n\nExplanation:\n\nYou can see that no matter how you rearrange the characters of \"cccd\", either s[0] == s[3] or s[1] == s[2]. So it can not form an anti-palindrome string.\n\n\n \nConstraints:\n\n\n\t2 <= s.length <= 10⁵\n\ts.length % 2 == 0\n\ts consists only of lowercase English letters.\n\n\n",
  "3089": "\n[3089] Find Bursty Behavior is on the run...\n\n\n",
  "3090": "\n[3090] Maximum Length Substring With Two Occurrences is on the run...\n\n\nGiven a string s, return the maximum length of a substring such that it contains at most two occurrences of each character.\n \nExample 1:\n\n\nInput: s = \"bcbbbcba\"\n\nOutput: 4\n\nExplanation:\nThe following substring has a length of 4 and contains at most two occurrences of each character: \"bcbbbcba\".\n\nExample 2:\n\n\nInput: s = \"aaaa\"\n\nOutput: 2\n\nExplanation:\nThe following substring has a length of 2 and contains at most two occurrences of each character: \"aaaa\".\n\n \nConstraints:\n\n\n\t2 <= s.length <= 100\n\ts consists only of lowercase English letters.\n\n\n",
  "3091": "\n[3091] Apply Operations to Make Sum of Array Greater Than or Equal to k is on the run...\n\n\nYou are given a positive integer k. Initially, you have an array nums = [1].\n\nYou can perform any of the following operations on the array any number of times (possibly zero):\n\n\n\tChoose any element in the array and increase its value by 1.\n\tDuplicate any element in the array and add it to the end of the array.\n\n\nReturn the minimum number of operations required to make the sum of elements of the final array greater than or equal to k.\n\n \nExample 1:\n\n\nInput: k = 11\n\nOutput: 5\n\nExplanation:\n\nWe can do the following operations on the array nums = [1]:\n\n\n\tIncrease the element by 1 three times. The resulting array is nums = [4].\n\tDuplicate the element two times. The resulting array is nums = [4,4,4].\n\n\nThe sum of the final array is 4 + 4 + 4 = 12 which is greater than or equal to k = 11.\nThe total number of operations performed is 3 + 2 = 5.\n\n\nExample 2:\n\n\nInput: k = 1\n\nOutput: 0\n\nExplanation:\n\nThe sum of the original array is already greater than or equal to 1, so no operations are needed.\n\n\n \nConstraints:\n\n\n\t1 <= k <= 10⁵\n\n\n",
  "3092": "\n[3092] Most Frequent IDs is on the run...\n\n\nThe problem involves tracking the frequency of IDs in a collection that changes over time. You have two integer arrays, nums and freq, of equal length n. Each element in nums represents an ID, and the corresponding element in freq indicates how many times that ID should be added to or removed from the collection at each step.\n\n\n\tAddition of IDs: If freq[i] is positive, it means freq[i] IDs with the value nums[i] are added to the collection at step i.\n\tRemoval of IDs: If freq[i] is negative, it means -freq[i] IDs with the value nums[i] are removed from the collection at step i.\n\n\nReturn an array ans of length n, where ans[i] represents the count of the most frequent ID in the collection after the ith step. If the collection is empty at any step, ans[i] should be 0 for that step.\n\n \nExample 1:\n\n\nInput: nums = [2,3,2,1], freq = [3,2,-3,1]\n\nOutput: [3,3,2,2]\n\nExplanation:\n\nAfter step 0, we have 3 IDs with the value of 2. So ans[0] = 3.\nAfter step 1, we have 3 IDs with the value of 2 and 2 IDs with the value of 3. So ans[1] = 3.\nAfter step 2, we have 2 IDs with the value of 3. So ans[2] = 2.\nAfter step 3, we have 2 IDs with the value of 3 and 1 ID with the value of 1. So ans[3] = 2.\n\n\nExample 2:\n\n\nInput: nums = [5,5,3], freq = [2,-2,1]\n\nOutput: [2,0,1]\n\nExplanation:\n\nAfter step 0, we have 2 IDs with the value of 5. So ans[0] = 2.\nAfter step 1, there are no IDs. So ans[1] = 0.\nAfter step 2, we have 1 ID with the value of 3. So ans[2] = 1.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length == freq.length <= 10⁵\n\t1 <= nums[i] <= 10⁵\n\t-10⁵ <= freq[i] <= 10⁵\n\tfreq[i] != 0\n\tThe input is generated such that the occurrences of an ID will not be negative in any step.\n\n\n",
  "3093": "\n[3093] Longest Common Suffix Queries is on the run...\n\n\nYou are given two arrays of strings wordsContainer and wordsQuery.\n\nFor each wordsQuery[i], you need to find a string from wordsContainer that has the longest common suffix with wordsQuery[i]. If there are two or more strings in wordsContainer that share the longest common suffix, find the string that is the smallest in length. If there are two or more such strings that have the same smallest length, find the one that occurred earlier in wordsContainer.\n\nReturn an array of integers ans, where ans[i] is the index of the string in wordsContainer that has the longest common suffix with wordsQuery[i].\n\n \nExample 1:\n\n\nInput: wordsContainer = [\"abcd\",\"bcd\",\"xbcd\"], wordsQuery = [\"cd\",\"bcd\",\"xyz\"]\n\nOutput: [1,1,1]\n\nExplanation:\n\nLet's look at each wordsQuery[i] separately:\n\n\n\tFor wordsQuery[0] = \"cd\", strings from wordsContainer that share the longest common suffix \"cd\" are at indices 0, 1, and 2. Among these, the answer is the string at index 1 because it has the shortest length of 3.\n\tFor wordsQuery[1] = \"bcd\", strings from wordsContainer that share the longest common suffix \"bcd\" are at indices 0, 1, and 2. Among these, the answer is the string at index 1 because it has the shortest length of 3.\n\tFor wordsQuery[2] = \"xyz\", there is no string from wordsContainer that shares a common suffix. Hence the longest common suffix is \"\", that is shared with strings at index 0, 1, and 2. Among these, the answer is the string at index 1 because it has the shortest length of 3.\n\n\n\nExample 2:\n\n\nInput: wordsContainer = [\"abcdefgh\",\"poiuygh\",\"ghghgh\"], wordsQuery = [\"gh\",\"acbfgh\",\"acbfegh\"]\n\nOutput: [2,0,2]\n\nExplanation:\n\nLet's look at each wordsQuery[i] separately:\n\n\n\tFor wordsQuery[0] = \"gh\", strings from wordsContainer that share the longest common suffix \"gh\" are at indices 0, 1, and 2. Among these, the answer is the string at index 2 because it has the shortest length of 6.\n\tFor wordsQuery[1] = \"acbfgh\", only the string at index 0 shares the longest common suffix \"fgh\". Hence it is the answer, even though the string at index 2 is shorter.\n\tFor wordsQuery[2] = \"acbfegh\", strings from wordsContainer that share the longest common suffix \"gh\" are at indices 0, 1, and 2. Among these, the answer is the string at index 2 because it has the shortest length of 6.\n\n\n\n \nConstraints:\n\n\n\t1 <= wordsContainer.length, wordsQuery.length <= 10⁴\n\t1 <= wordsContainer[i].length <= 5 * 10³\n\t1 <= wordsQuery[i].length <= 5 * 10³\n\twordsContainer[i] consists only of lowercase English letters.\n\twordsQuery[i] consists only of lowercase English letters.\n\tSum of wordsContainer[i].length is at most 5 * 10⁵.\n\tSum of wordsQuery[i].length is at most 5 * 10⁵.\n\n\n",
  "3094": "\n[3094] Guess the Number Using Bitwise Questions II is on the run...\n\n\nThere is a number n between 0 and 2³⁰ - 1 (both inclusive) that you have to find.\n\nThere is a pre-defined API int commonBits(int num) that helps you with your mission. But here is the challenge, every time you call this function, n changes in some way. But keep in mind, that you have to find the initial value of n.\n\ncommonBits(int num) acts as follows:\n\n\n\tCalculate count which is the number of bits where both n and num have the same value in that position of their binary representation.\n\tn = n XOR num\n\tReturn count.\n\n\nReturn the number n.\n\nNote: In this world, all numbers are between 0 and 2³⁰ - 1 (both inclusive), thus for counting common bits, we see only the first 30 bits of those numbers.\n\n \nConstraints:\n\n\n\t0 <= n <= 2³⁰ - 1\n\t0 <= num <= 2³⁰ - 1\n\tIf you ask for some num out of the given range, the output wouldn't be reliable.\n\n\n",
  "3095": "\n[3095] Shortest Subarray With OR at Least K I is on the run...\n\n\nYou are given an array nums of non-negative integers and an integer k.\n\nAn array is called special if the bitwise OR of all of its elements is at least k.\n\nReturn the length of the shortest special non-empty subarray of nums, or return -1 if no special subarray exists.\n\n \nExample 1:\n\n\nInput: nums = [1,2,3], k = 2\n\nOutput: 1\n\nExplanation:\n\nThe subarray [3] has OR value of 3. Hence, we return 1.\n\nNote that [2] is also a special subarray.\n\n\nExample 2:\n\n\nInput: nums = [2,1,8], k = 10\n\nOutput: 3\n\nExplanation:\n\nThe subarray [2,1,8] has OR value of 11. Hence, we return 3.\n\n\nExample 3:\n\n\nInput: nums = [1,2], k = 0\n\nOutput: 1\n\nExplanation:\n\nThe subarray [1] has OR value of 1. Hence, we return 1.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 50\n\t0 <= nums[i] <= 50\n\t0 <= k < 64\n\n\n",
  "3096": "\n[3096] Minimum Levels to Gain More Points is on the run...\n\n\nYou are given a binary array possible of length n.\n\nAlice and Bob are playing a game that consists of n levels. Some of the levels in the game are impossible to clear while others can always be cleared. In particular, if possible[i] == 0, then the ith level is impossible to clear for both the players. A player gains 1 point on clearing a level and loses 1 point if the player fails to clear it.\n\nAt the start of the game, Alice will play some levels in the given order starting from the 0th level, after which Bob will play for the rest of the levels.\n\nAlice wants to know the minimum number of levels she should play to gain more points than Bob, if both players play optimally to maximize their points.\n\nReturn the minimum number of levels Alice should play to gain more points. If this is not possible, return -1.\n\nNote that each player must play at least 1 level.\n\n \nExample 1:\n\n\nInput: possible = [1,0,1,0]\n\nOutput: 1\n\nExplanation:\n\nLet's look at all the levels that Alice can play up to:\n\n\n\tIf Alice plays only level 0 and Bob plays the rest of the levels, Alice has 1 point, while Bob has -1 + 1 - 1 = -1 point.\n\tIf Alice plays till level 1 and Bob plays the rest of the levels, Alice has 1 - 1 = 0 points, while Bob has 1 - 1 = 0 points.\n\tIf Alice plays till level 2 and Bob plays the rest of the levels, Alice has 1 - 1 + 1 = 1 point, while Bob has -1 point.\n\n\nAlice must play a minimum of 1 level to gain more points.\n\n\nExample 2:\n\n\nInput: possible = [1,1,1,1,1]\n\nOutput: 3\n\nExplanation:\n\nLet's look at all the levels that Alice can play up to:\n\n\n\tIf Alice plays only level 0 and Bob plays the rest of the levels, Alice has 1 point, while Bob has 4 points.\n\tIf Alice plays till level 1 and Bob plays the rest of the levels, Alice has 2 points, while Bob has 3 points.\n\tIf Alice plays till level 2 and Bob plays the rest of the levels, Alice has 3 points, while Bob has 2 points.\n\tIf Alice plays till level 3 and Bob plays the rest of the levels, Alice has 4 points, while Bob has 1 point.\n\n\nAlice must play a minimum of 3 levels to gain more points.\n\n\nExample 3:\n\n\nInput: possible = [0,0]\n\nOutput: -1\n\nExplanation:\n\nThe only possible way is for both players to play 1 level each. Alice plays level 0 and loses 1 point. Bob plays level 1 and loses 1 point. As both players have equal points, Alice can't gain more points than Bob.\n\n\n \nConstraints:\n\n\n\t2 <= n == possible.length <= 10⁵\n\tpossible[i] is either 0 or 1.\n\n\n",
  "3097": "\n[3097] Shortest Subarray With OR at Least K II is on the run...\n\n\nYou are given an array nums of non-negative integers and an integer k.\n\nAn array is called special if the bitwise OR of all of its elements is at least k.\n\nReturn the length of the shortest special non-empty subarray of nums, or return -1 if no special subarray exists.\n\n \nExample 1:\n\n\nInput: nums = [1,2,3], k = 2\n\nOutput: 1\n\nExplanation:\n\nThe subarray [3] has OR value of 3. Hence, we return 1.\n\n\nExample 2:\n\n\nInput: nums = [2,1,8], k = 10\n\nOutput: 3\n\nExplanation:\n\nThe subarray [2,1,8] has OR value of 11. Hence, we return 3.\n\n\nExample 3:\n\n\nInput: nums = [1,2], k = 0\n\nOutput: 1\n\nExplanation:\n\nThe subarray [1] has OR value of 1. Hence, we return 1.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 2 * 10⁵\n\t0 <= nums[i] <= 10⁹\n\t0 <= k <= 10⁹\n\n\n",
  "3098": "\n[3098] Find the Sum of Subsequence Powers is on the run...\n\n\nYou are given an integer array nums of length n, and a positive integer k.\n\nThe power of a subsequence is defined as the minimum absolute difference between any two elements in the subsequence.\n\nReturn the sum of powers of all subsequences of nums which have length equal to k.\n\nSince the answer may be large, return it modulo 109 + 7.\n\n \nExample 1:\n\n\nInput: nums = [1,2,3,4], k = 3\n\nOutput: 4\n\nExplanation:\n\nThere are 4 subsequences in nums which have length 3: [1,2,3], [1,3,4], [1,2,4], and [2,3,4]. The sum of powers is |2 - 3| + |3 - 4| + |2 - 1| + |3 - 4| = 4.\n\n\nExample 2:\n\n\nInput: nums = [2,2], k = 2\n\nOutput: 0\n\nExplanation:\n\nThe only subsequence in nums which has length 2 is [2,2]. The sum of powers is |2 - 2| = 0.\n\n\nExample 3:\n\n\nInput: nums = [4,3,-1], k = 2\n\nOutput: 10\n\nExplanation:\n\nThere are 3 subsequences in nums which have length 2: [4,3], [4,-1], and [3,-1]. The sum of powers is |4 - 3| + |4 - (-1)| + |3 - (-1)| = 10.\n\n\n \nConstraints:\n\n\n\t2 <= n == nums.length <= 50\n\t-10⁸ <= nums[i] <= 10⁸ \n\t2 <= k <= n\n\n\n",
  "3099": "\n[3099] Harshad Number is on the run...\n\n\nAn integer divisible by the sum of its digits is said to be a Harshad number. You are given an integer x. Return the sum of the digits of x if x is a Harshad number, otherwise, return -1.\n\n \nExample 1:\n\n\nInput: x = 18\n\nOutput: 9\n\nExplanation:\n\nThe sum of digits of x is 9. 18 is divisible by 9. So 18 is a Harshad number and the answer is 9.\n\n\nExample 2:\n\n\nInput: x = 23\n\nOutput: -1\n\nExplanation:\n\nThe sum of digits of x is 5. 23 is not divisible by 5. So 23 is not a Harshad number and the answer is -1.\n\n\n \nConstraints:\n\n\n\t1 <= x <= 100\n\n\n"
}