{
  "3100": {
    "question_number": "3100",
    "question_title": "Water Bottles II is on the run...",
    "question_description": "You are given two integers numBottles and numExchange.\n\nnumBottles represents the number of full water bottles that you initially have. In one operation, you can perform one of the following operations:\n\n\n\tDrink any number of full water bottles turning them into empty bottles.\n\tExchange numExchange empty bottles with one full water bottle. Then, increase numExchange by one.\n\n\nNote that you cannot exchange multiple batches of empty bottles for the same value of numExchange. For example, if numBottles == 3 and numExchange == 1, you cannot exchange 3 empty water bottles for 3 full bottles.\n\nReturn the maximum number of water bottles you can drink.\n\n \nExample 1:\n\nInput: numBottles = 13, numExchange = 6\nOutput: 15\nExplanation: The table above shows the number of full water bottles, empty water bottles, the value of numExchange, and the number of bottles drunk.\n\n\nExample 2:\n\nInput: numBottles = 10, numExchange = 3\nOutput: 13\nExplanation: The table above shows the number of full water bottles, empty water bottles, the value of numExchange, and the number of bottles drunk.\n\n\n \nConstraints:\n\n\n\t1 <= numBottles <= 100 \n\t1 <= numExchange <= 100",
    "function_signature": "class Solution:\n    def maxBottlesDrunk(self, numBottles: int, numExchange: int) -> int:\n        \n"
  },
  "3101": {
    "question_number": "3101",
    "question_title": "Count Alternating Subarrays is on the run...",
    "question_description": "You are given a binary array nums.\n\nWe call a subarray alternating if no two adjacent elements in the subarray have the same value.\n\nReturn the number of alternating subarrays in nums.\n\n \nExample 1:\n\n\nInput: nums = [0,1,1,1]\n\nOutput: 5\n\nExplanation:\n\nThe following subarrays are alternating: [0], [1], [1], [1], and [0,1].\n\n\nExample 2:\n\n\nInput: nums = [1,0,1,0]\n\nOutput: 10\n\nExplanation:\n\nEvery subarray of the array is alternating. There are 10 possible subarrays that we can choose.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 10⁵\n\tnums[i] is either 0 or 1.",
    "function_signature": "class Solution:\n    def countAlternatingSubarrays(self, nums: List[int]) -> int:\n        \n"
  },
  "3102": {
    "question_number": "3102",
    "question_title": "Minimize Manhattan Distances is on the run...",
    "question_description": "You are given an array points representing integer coordinates of some points on a 2D plane, where points[i] = [xi, yi].\n\nThe distance between two points is defined as their Manhattan distance.\n\nReturn the minimum possible value for maximum distance between any two points by removing exactly one point.\n\n \nExample 1:\n\n\nInput: points = [[3,10],[5,15],[10,2],[4,4]]\n\nOutput: 12\n\nExplanation:\n\nThe maximum distance after removing each point is the following:\n\n\n\tAfter removing the 0th point the maximum distance is between points (5, 15) and (10, 2), which is |5 - 10| + |15 - 2| = 18.\n\tAfter removing the 1st point the maximum distance is between points (3, 10) and (10, 2), which is |3 - 10| + |10 - 2| = 15.\n\tAfter removing the 2nd point the maximum distance is between points (5, 15) and (4, 4), which is |5 - 4| + |15 - 4| = 12.\n\tAfter removing the 3rd point the maximum distance is between points (5, 15) and (10, 2), which is |5 - 10| + |15 - 2| = 18.\n\n\n12 is the minimum possible maximum distance between any two points after removing exactly one point.\n\n\nExample 2:\n\n\nInput: points = [[1,1],[1,1],[1,1]]\n\nOutput: 0\n\nExplanation:\n\nRemoving any of the points results in the maximum distance between any two points of 0.\n\n\n \nConstraints:\n\n\n\t3 <= points.length <= 10⁵\n\tpoints[i].length == 2\n\t1 <= points[i][0], points[i][1] <= 10⁸",
    "function_signature": "class Solution:\n    def minimumDistance(self, points: List[List[int]]) -> int:\n        \n"
  },
  "3104": {
    "question_number": "3104",
    "question_title": "Find Longest Self-Contained Substring is on the run...",
    "question_description": "Given a string s, your task is to find the length of the longest self-contained substring of s.\n\nA substring t of a string s is called self-contained if t != s and for every character in t, it doesn't exist in the rest of s.\n\nReturn the length of the longest self-contained substring of s if it exists, otherwise, return -1.\n\n \nExample 1:\n\n\nInput: s = \"abba\"\n\nOutput: 2\n\nExplanation:\nLet's check the substring \"bb\". You can see that no other \"b\" is outside of this substring. Hence the answer is 2.\n\n\nExample 2:\n\n\nInput: s = \"abab\"\n\nOutput: -1\n\nExplanation:\nEvery substring we choose does not satisfy the described property (there is some character which is inside and outside of that substring). So the answer would be -1.\n\n\nExample 3:\n\n\nInput: s = \"abacd\"\n\nOutput: 4\n\nExplanation:\nLet's check the substring \"abac\". There is only one character outside of this substring and that is \"d\". There is no \"d\" inside the chosen substring, so it satisfies the condition and the answer is 4.\n\n\n \nConstraints:\n\n\n\t2 <= s.length <= 5 * 10⁴\n\ts consists only of lowercase English letters.",
    "function_signature": "class Solution:\n    def maxSubstringLength(self, s: str) -> int:\n        \n"
  },
  "3105": {
    "question_number": "3105",
    "question_title": "Longest Strictly Increasing or Strictly Decreasing Subarray is on the run...",
    "question_description": "You are given an array of integers nums. Return the length of the longest subarray of nums which is either strictly increasing or strictly decreasing.\n\n \nExample 1:\n\n\nInput: nums = [1,4,3,3,2]\n\nOutput: 2\n\nExplanation:\n\nThe strictly increasing subarrays of nums are [1], [2], [3], [3], [4], and [1,4].\n\nThe strictly decreasing subarrays of nums are [1], [2], [3], [3], [4], [3,2], and [4,3].\n\nHence, we return 2.\n\n\nExample 2:\n\n\nInput: nums = [3,3,3,3]\n\nOutput: 1\n\nExplanation:\n\nThe strictly increasing subarrays of nums are [3], [3], [3], and [3].\n\nThe strictly decreasing subarrays of nums are [3], [3], [3], and [3].\n\nHence, we return 1.\n\n\nExample 3:\n\n\nInput: nums = [3,2,1]\n\nOutput: 3\n\nExplanation:\n\nThe strictly increasing subarrays of nums are [3], [2], and [1].\n\nThe strictly decreasing subarrays of nums are [3], [2], [1], [3,2], [2,1], and [3,2,1].\n\nHence, we return 3.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 50\n\t1 <= nums[i] <= 50",
    "function_signature": "class Solution:\n    def longestMonotonicSubarray(self, nums: List[int]) -> int:\n        \n"
  },
  "3106": {
    "question_number": "3106",
    "question_title": "Lexicographically Smallest String After Operations With Constraint is on the run...",
    "question_description": "You are given a string s and an integer k.\n\nDefine a function distance(s₁, s₂) between two strings s₁ and s₂ of the same length n as:\n\n\n\tThe sum of the minimum distance between s₁[i] and s₂[i] when the characters from 'a' to 'z' are placed in a cyclic order, for all i in the range [0, n - 1].\n\n\nFor example, distance(\"ab\", \"cd\") == 4, and distance(\"a\", \"z\") == 1.\n\nYou can change any letter of s to any other lowercase English letter, any number of times.\n\nReturn a string denoting the lexicographically smallest string t you can get after some changes, such that distance(s, t) <= k.\n\n \nExample 1:\n\n\nInput: s = \"zbbz\", k = 3\n\nOutput: \"aaaz\"\n\nExplanation:\n\nChange s to \"aaaz\". The distance between \"zbbz\" and \"aaaz\" is equal to k = 3.\n\n\nExample 2:\n\n\nInput: s = \"xaxcd\", k = 4\n\nOutput: \"aawcd\"\n\nExplanation:\n\nThe distance between \"xaxcd\" and \"aawcd\" is equal to k = 4.\n\n\nExample 3:\n\n\nInput: s = \"lol\", k = 0\n\nOutput: \"lol\"\n\nExplanation:\n\nIt's impossible to change any character as k = 0.\n\n\n \nConstraints:\n\n\n\t1 <= s.length <= 100\n\t0 <= k <= 2000\n\ts consists only of lowercase English letters.",
    "function_signature": "class Solution:\n    def getSmallestString(self, s: str, k: int) -> str:\n        \n"
  },
  "3107": {
    "question_number": "3107",
    "question_title": "Minimum Operations to Make Median of Array Equal to K is on the run...",
    "question_description": "You are given an integer array nums and a non-negative integer k. In one operation, you can increase or decrease any element by 1.\n\nReturn the minimum number of operations needed to make the median of nums equal to k.\n\nThe median of an array is defined as the middle element of the array when it is sorted in non-decreasing order. If there are two choices for a median, the larger of the two values is taken.\n\n \nExample 1:\n\n\nInput: nums = [2,5,6,8,5], k = 4\n\nOutput: 2\n\nExplanation:\n\nWe can subtract one from nums[1] and nums[4] to obtain [2, 4, 6, 8, 4]. The median of the resulting array is equal to k.\n\n\nExample 2:\n\n\nInput: nums = [2,5,6,8,5], k = 7\n\nOutput: 3\n\nExplanation:\n\nWe can add one to nums[1] twice and add one to nums[2] once to obtain [2, 7, 7, 8, 5].\n\n\nExample 3:\n\n\nInput: nums = [1,2,3,4,5,6], k = 4\n\nOutput: 0\n\nExplanation:\n\nThe median of the array is already equal to k.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 2 * 10⁵\n\t1 <= nums[i] <= 10⁹\n\t1 <= k <= 10⁹",
    "function_signature": "class Solution:\n    def minOperationsToMakeMedianK(self, nums: List[int], k: int) -> int:\n        \n"
  },
  "3108": {
    "question_number": "3108",
    "question_title": "Minimum Cost Walk in Weighted Graph is on the run...",
    "question_description": "There is an undirected weighted graph with n vertices labeled from 0 to n - 1.\n\nYou are given the integer n and an array edges, where edges[i] = [ui, vi, wi] indicates that there is an edge between vertices ui and vi with a weight of wi.\n\nA walk on a graph is a sequence of vertices and edges. The walk starts and ends with a vertex, and each edge connects the vertex that comes before it and the vertex that comes after it. It's important to note that a walk may visit the same edge or vertex more than once.\n\nThe cost of a walk starting at node u and ending at node v is defined as the bitwise AND of the weights of the edges traversed during the walk. In other words, if the sequence of edge weights encountered during the walk is w₀, w₁, w₂, ..., wk, then the cost is calculated as w₀ & w₁ & w₂ & ... & wk, where & denotes the bitwise AND operator.\n\nYou are also given a 2D array query, where query[i] = [si, ti]. For each query, you need to find the minimum cost of the walk starting at vertex si and ending at vertex ti. If there exists no such walk, the answer is -1.\n\nReturn the array answer, where answer[i] denotes the minimum cost of a walk for query i.\n\n \nExample 1:\n\n\nInput: n = 5, edges = [[0,1,7],[1,3,7],[1,2,1]], query = [[0,3],[3,4]]\n\nOutput: [1,-1]\n\nExplanation:\n\nTo achieve the cost of 1 in the first query, we need to move on the following edges: 0->1 (weight 7), 1->2 (weight 1), 2->1 (weight 1), 1->3 (weight 7).\n\nIn the second query, there is no walk between nodes 3 and 4, so the answer is -1.\n\nExample 2:\n\n\n\nInput: n = 3, edges = [[0,2,7],[0,1,15],[1,2,6],[1,2,1]], query = [[1,2]]\n\nOutput: [0]\n\nExplanation:\n\nTo achieve the cost of 0 in the first query, we need to move on the following edges: 1->2 (weight 1), 2->1 (weight 6), 1->2 (weight 1).\n\n\n \nConstraints:\n\n\n\t2 <= n <= 10⁵\n\t0 <= edges.length <= 10⁵\n\tedges[i].length == 3\n\t0 <= ui, vi <= n - 1\n\tui != vi\n\t0 <= wi <= 10⁵\n\t1 <= query.length <= 10⁵\n\tquery[i].length == 2\n\t0 <= si, ti <= n - 1\n\tsi != ti",
    "function_signature": "class Solution:\n    def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:\n        \n"
  },
  "3109": {
    "question_number": "3109",
    "question_title": "Find the Index of Permutation is on the run...",
    "question_description": "Given an array perm of length n which is a permutation of [1, 2, ..., n], return the index of perm in the lexicographically sorted array of all of the permutations of [1, 2, ..., n].\n\nSince the answer may be very large, return it modulo 10⁹ + 7.\n\n \nExample 1:\n\n\nInput: perm = [1,2]\n\nOutput: 0\n\nExplanation:\n\nThere are only two permutations in the following order:\n\n[1,2], [2,1]\n\nAnd [1,2] is at index 0.\n\n\nExample 2:\n\n\nInput: perm = [3,1,2]\n\nOutput: 4\n\nExplanation:\n\nThere are only six permutations in the following order:\n\n[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]\n\nAnd [3,1,2] is at index 4.\n\n\n \nConstraints:\n\n\n\t1 <= n == perm.length <= 10⁵\n\tperm is a permutation of [1, 2, ..., n].",
    "function_signature": "class Solution:\n    def getPermutationIndex(self, perm: List[int]) -> int:\n        \n"
  },
  "3110": {
    "question_number": "3110",
    "question_title": "Score of a String is on the run...",
    "question_description": "You are given a string s. The score of a string is defined as the sum of the absolute difference between the ASCII values of adjacent characters.\n\nReturn the score of s.\n\n \nExample 1:\n\n\nInput: s = \"hello\"\n\nOutput: 13\n\nExplanation:\n\nThe ASCII values of the characters in s are: 'h' = 104, 'e' = 101, 'l' = 108, 'o' = 111. So, the score of s would be |104 - 101| + |101 - 108| + |108 - 108| + |108 - 111| = 3 + 7 + 0 + 3 = 13.\n\n\nExample 2:\n\n\nInput: s = \"zaz\"\n\nOutput: 50\n\nExplanation:\n\nThe ASCII values of the characters in s are: 'z' = 122, 'a' = 97. So, the score of s would be |122 - 97| + |97 - 122| = 25 + 25 = 50.\n\n\n \nConstraints:\n\n\n\t2 <= s.length <= 100\n\ts consists only of lowercase English letters.",
    "function_signature": "class Solution:\n    def scoreOfString(self, s: str) -> int:\n        \n"
  },
  "3111": {
    "question_number": "3111",
    "question_title": "Minimum Rectangles to Cover Points is on the run...",
    "question_description": "You are given a 2D integer array points, where points[i] = [xi, yi]. You are also given an integer w. Your task is to cover all the given points with rectangles.\n\nEach rectangle has its lower end at some point (x₁, 0) and its upper end at some point (x₂, y₂), where x₁ <= x₂, y₂ >= 0, and the condition x₂ - x₁ <= w must be satisfied for each rectangle.\n\nA point is considered covered by a rectangle if it lies within or on the boundary of the rectangle.\n\nReturn an integer denoting the minimum number of rectangles needed so that each point is covered by at least one rectangle.\n\nNote: A point may be covered by more than one rectangle.\n\n \nExample 1:\n\n\n\n\nInput: points = [[2,1],[1,0],[1,4],[1,8],[3,5],[4,6]], w = 1\n\nOutput: 2\n\nExplanation: \n\nThe image above shows one possible placement of rectangles to cover the points:\n\n\n\tA rectangle with a lower end at (1, 0) and its upper end at (2, 8)\n\tA rectangle with a lower end at (3, 0) and its upper end at (4, 8)\n\n\n\nExample 2:\n\n\n\n\nInput: points = [[0,0],[1,1],[2,2],[3,3],[4,4],[5,5],[6,6]], w = 2\n\nOutput: 3\n\nExplanation: \n\nThe image above shows one possible placement of rectangles to cover the points:\n\n\n\tA rectangle with a lower end at (0, 0) and its upper end at (2, 2)\n\tA rectangle with a lower end at (3, 0) and its upper end at (5, 5)\n\tA rectangle with a lower end at (6, 0) and its upper end at (6, 6)\n\n\n\nExample 3:\n\n\n\n\nInput: points = [[2,3],[1,2]], w = 0\n\nOutput: 2\n\nExplanation: \n\nThe image above shows one possible placement of rectangles to cover the points:\n\n\n\tA rectangle with a lower end at (1, 0) and its upper end at (1, 2)\n\tA rectangle with a lower end at (2, 0) and its upper end at (2, 3)\n\n\n\n \nConstraints:\n\n\n\t1 <= points.length <= 10⁵\n\tpoints[i].length == 2\n\t0 <= xi == points[i][0] <= 10⁹\n\t0 <= yi == points[i][1] <= 10⁹\n\t0 <= w <= 10⁹\n\tAll pairs (xi, yi) are distinct.",
    "function_signature": "class Solution:\n    def minRectanglesToCoverPoints(self, points: List[List[int]], w: int) -> int:\n        \n"
  },
  "3112": {
    "question_number": "3112",
    "question_title": "Minimum Time to Visit Disappearing Nodes is on the run...",
    "question_description": "There is an undirected graph of n nodes. You are given a 2D array edges, where edges[i] = [ui, vi, lengthi] describes an edge between node ui and node vi with a traversal time of lengthi units.\n\nAdditionally, you are given an array disappear, where disappear[i] denotes the time when the node i disappears from the graph and you won't be able to visit it.\n\nNote that the graph might be disconnected and might contain multiple edges.\n\nReturn the array answer, with answer[i] denoting the minimum units of time required to reach node i from node 0. If node i is unreachable from node 0 then answer[i] is -1.\n\n \nExample 1:\n\n\nInput: n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,1,5]\n\nOutput: [0,-1,4]\n\nExplanation:\n\n\n\nWe are starting our journey from node 0, and our goal is to find the minimum time required to reach each node before it disappears.\n\n\n\tFor node 0, we don't need any time as it is our starting point.\n\tFor node 1, we need at least 2 units of time to traverse edges[0]. Unfortunately, it disappears at that moment, so we won't be able to visit it.\n\tFor node 2, we need at least 4 units of time to traverse edges[2].\n\n\n\nExample 2:\n\n\nInput: n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,3,5]\n\nOutput: [0,2,3]\n\nExplanation:\n\n\n\nWe are starting our journey from node 0, and our goal is to find the minimum time required to reach each node before it disappears.\n\n\n\tFor node 0, we don't need any time as it is the starting point.\n\tFor node 1, we need at least 2 units of time to traverse edges[0].\n\tFor node 2, we need at least 3 units of time to traverse edges[0] and edges[1].\n\n\n\nExample 3:\n\n\nInput: n = 2, edges = [[0,1,1]], disappear = [1,1]\n\nOutput: [0,-1]\n\nExplanation:\n\nExactly when we reach node 1, it disappears.\n\n\n \nConstraints:\n\n\n\t1 <= n <= 5 * 10⁴\n\t0 <= edges.length <= 10⁵\n\tedges[i] == [ui, vi, lengthi]\n\t0 <= ui, vi <= n - 1\n\t1 <= lengthi <= 10⁵\n\tdisappear.length == n\n\t1 <= disappear[i] <= 10⁵",
    "function_signature": "class Solution:\n    def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n        \n"
  },
  "3113": {
    "question_number": "3113",
    "question_title": "Find the Number of Subarrays Where Boundary Elements Are Maximum is on the run...",
    "question_description": "You are given an array of positive integers nums.\n\nReturn the number of subarrays of nums, where the first and the last elements of the subarray are equal to the largest element in the subarray.\n\n \nExample 1:\n\n\nInput: nums = [1,4,3,3,2]\n\nOutput: 6\n\nExplanation:\n\nThere are 6 subarrays which have the first and the last elements equal to the largest element of the subarray:\n\n\n\tsubarray [1,4,3,3,2], with its largest element 1. The first element is 1 and the last element is also 1.\n\tsubarray [1,4,3,3,2], with its largest element 4. The first element is 4 and the last element is also 4.\n\tsubarray [1,4,3,3,2], with its largest element 3. The first element is 3 and the last element is also 3.\n\tsubarray [1,4,3,3,2], with its largest element 3. The first element is 3 and the last element is also 3.\n\tsubarray [1,4,3,3,2], with its largest element 2. The first element is 2 and the last element is also 2.\n\tsubarray [1,4,3,3,2], with its largest element 3. The first element is 3 and the last element is also 3.\n\n\nHence, we return 6.\n\n\nExample 2:\n\n\nInput: nums = [3,3,3]\n\nOutput: 6\n\nExplanation:\n\nThere are 6 subarrays which have the first and the last elements equal to the largest element of the subarray:\n\n\n\tsubarray [3,3,3], with its largest element 3. The first element is 3 and the last element is also 3.\n\tsubarray [3,3,3], with its largest element 3. The first element is 3 and the last element is also 3.\n\tsubarray [3,3,3], with its largest element 3. The first element is 3 and the last element is also 3.\n\tsubarray [3,3,3], with its largest element 3. The first element is 3 and the last element is also 3.\n\tsubarray [3,3,3], with its largest element 3. The first element is 3 and the last element is also 3.\n\tsubarray [3,3,3], with its largest element 3. The first element is 3 and the last element is also 3.\n\n\nHence, we return 6.\n\n\nExample 3:\n\n\nInput: nums = [1]\n\nOutput: 1\n\nExplanation:\n\nThere is a single subarray of nums which is [1], with its largest element 1. The first element is 1 and the last element is also 1.\n\nHence, we return 1.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 10⁵\n\t1 <= nums[i] <= 10⁹",
    "function_signature": "class Solution:\n    def numberOfSubarrays(self, nums: List[int]) -> int:\n        \n"
  },
  "3114": {
    "question_number": "3114",
    "question_title": "Latest Time You Can Obtain After Replacing Characters is on the run...",
    "question_description": "You are given a string s representing a 12-hour format time where some of the digits (possibly none) are replaced with a \"?\".\n\n12-hour times are formatted as \"HH:MM\", where HH is between 00 and 11, and MM is between 00 and 59. The earliest 12-hour time is 00:00, and the latest is 11:59.\n\nYou have to replace all the \"?\" characters in s with digits such that the time we obtain by the resulting string is a valid 12-hour format time and is the latest possible.\n\nReturn the resulting string.\n\n \nExample 1:\n\n\nInput: s = \"1?:?4\"\n\nOutput: \"11:54\"\n\nExplanation: The latest 12-hour format time we can achieve by replacing \"?\" characters is \"11:54\".\n\n\nExample 2:\n\n\nInput: s = \"0?:5?\"\n\nOutput: \"09:59\"\n\nExplanation: The latest 12-hour format time we can achieve by replacing \"?\" characters is \"09:59\".\n\n\n \nConstraints:\n\n\n\ts.length == 5\n\ts[2] is equal to the character \":\".\n\tAll characters except s[2] are digits or \"?\" characters.\n\tThe input is generated such that there is at least one time between \"00:00\" and \"11:59\" that you can obtain after replacing the \"?\" characters.",
    "function_signature": "class Solution:\n    def findLatestTime(self, s: str) -> str:\n        \n"
  },
  "3115": {
    "question_number": "3115",
    "question_title": "Maximum Prime Difference is on the run...",
    "question_description": "You are given an integer array nums.\n\nReturn an integer that is the maximum distance between the indices of two (not necessarily different) prime numbers in nums.\n\n \nExample 1:\n\n\nInput: nums = [4,2,9,5,3]\n\nOutput: 3\n\nExplanation: nums[1], nums[3], and nums[4] are prime. So the answer is |4 - 1| = 3.\n\n\nExample 2:\n\n\nInput: nums = [4,8,2,8]\n\nOutput: 0\n\nExplanation: nums[2] is prime. Because there is just one prime number, the answer is |2 - 2| = 0.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 3 * 10⁵\n\t1 <= nums[i] <= 100\n\tThe input is generated such that the number of prime numbers in the nums is at least one.",
    "function_signature": "class Solution:\n    def maximumPrimeDifference(self, nums: List[int]) -> int:\n        \n"
  },
  "3116": {
    "question_number": "3116",
    "question_title": "Kth Smallest Amount With Single Denomination Combination is on the run...",
    "question_description": "You are given an integer array coins representing coins of different denominations and an integer k.\n\nYou have an infinite number of coins of each denomination. However, you are not allowed to combine coins of different denominations.\n\nReturn the kth smallest amount that can be made using these coins.\n\n \nExample 1:\n\n\nInput: coins = [3,6,9], k = 3\n\nOutput:  9\n\nExplanation: The given coins can make the following amounts:\nCoin 3 produces multiples of 3: 3, 6, 9, 12, 15, etc.\nCoin 6 produces multiples of 6: 6, 12, 18, 24, etc.\nCoin 9 produces multiples of 9: 9, 18, 27, 36, etc.\nAll of the coins combined produce: 3, 6, 9, 12, 15, etc.\n\n\nExample 2:\n\n\nInput: coins = [5,2], k = 7\n\nOutput: 12 \n\nExplanation: The given coins can make the following amounts:\nCoin 5 produces multiples of 5: 5, 10, 15, 20, etc.\nCoin 2 produces multiples of 2: 2, 4, 6, 8, 10, 12, etc.\nAll of the coins combined produce: 2, 4, 5, 6, 8, 10, 12, 14, 15, etc.\n\n\n \nConstraints:\n\n\n\t1 <= coins.length <= 15\n\t1 <= coins[i] <= 25\n\t1 <= k <= 2 * 10⁹\n\tcoins contains pairwise distinct integers.",
    "function_signature": "class Solution:\n    def findKthSmallest(self, coins: List[int], k: int) -> int:\n        \n"
  },
  "3117": {
    "question_number": "3117",
    "question_title": "Minimum Sum of Values by Dividing Array is on the run...",
    "question_description": "You are given two arrays nums and andValues of length n and m respectively.\n\nThe value of an array is equal to the last element of that array.\n\nYou have to divide nums into m disjoint contiguous subarrays such that for the ith subarray [li, ri], the bitwise AND of the subarray elements is equal to andValues[i], in other words, nums[li] & nums[li + 1] & ... & nums[ri] == andValues[i] for all 1 <= i <= m, where & represents the bitwise AND operator.\n\nReturn the minimum possible sum of the values of the m subarrays nums is divided into. If it is not possible to divide nums into m subarrays satisfying these conditions, return -1.\n\n \nExample 1:\n\n\nInput: nums = [1,4,3,3,2], andValues = [0,3,3,2]\n\nOutput: 12\n\nExplanation:\n\nThe only possible way to divide nums is:\n\n\n\t[1,4] as 1 & 4 == 0.\n\t[3] as the bitwise AND of a single element subarray is that element itself.\n\t[3] as the bitwise AND of a single element subarray is that element itself.\n\t[2] as the bitwise AND of a single element subarray is that element itself.\n\n\nThe sum of the values for these subarrays is 4 + 3 + 3 + 2 = 12.\n\n\nExample 2:\n\n\nInput: nums = [2,3,5,7,7,7,5], andValues = [0,7,5]\n\nOutput: 17\n\nExplanation:\n\nThere are three ways to divide nums:\n\n\n\t[[2,3,5],[7,7,7],[5]] with the sum of the values 5 + 7 + 5 == 17.\n\t[[2,3,5,7],[7,7],[5]] with the sum of the values 7 + 7 + 5 == 19.\n\t[[2,3,5,7,7],[7],[5]] with the sum of the values 7 + 7 + 5 == 19.\n\n\nThe minimum possible sum of the values is 17.\n\n\nExample 3:\n\n\nInput: nums = [1,2,3,4], andValues = [2]\n\nOutput: -1\n\nExplanation:\n\nThe bitwise AND of the entire array nums is 0. As there is no possible way to divide nums into a single subarray to have the bitwise AND of elements 2, return -1.\n\n\n \nConstraints:\n\n\n\t1 <= n == nums.length <= 10⁴\n\t1 <= m == andValues.length <= min(n, 10)\n\t1 <= nums[i] < 10⁵\n\t0 <= andValues[j] < 10⁵",
    "function_signature": "class Solution:\n    def minimumValueSum(self, nums: List[int], andValues: List[int]) -> int:\n        \n"
  },
  "3119": {
    "question_number": "3119",
    "question_title": "Maximum Number of Potholes That Can Be Fixed is on the run...",
    "question_description": "You are given a string road, consisting only of characters \"x\" and \".\", where each \"x\" denotes a pothole and each \".\" denotes a smooth road, and an integer budget.\n\nIn one repair operation, you can repair n consecutive potholes for a price of n + 1.\n\nReturn the maximum number of potholes that can be fixed such that the sum of the prices of all of the fixes doesn't go over the given budget.\n\n \nExample 1:\n\n\nInput: road = \"..\", budget = 5\n\nOutput: 0\n\nExplanation:\n\nThere are no potholes to be fixed.\n\n\nExample 2:\n\n\nInput: road = \"..xxxxx\", budget = 4\n\nOutput: 3\n\nExplanation:\n\nWe fix the first three potholes (they are consecutive). The budget needed for this task is 3 + 1 = 4.\n\n\nExample 3:\n\n\nInput: road = \"x.x.xxx...x\", budget = 14\n\nOutput: 6\n\nExplanation:\n\nWe can fix all the potholes. The total cost would be (1 + 1) + (1 + 1) + (3 + 1) + (1 + 1) = 10 which is within our budget of 14.\n\n\n \nConstraints:\n\n\n\t1 <= road.length <= 10⁵\n\t1 <= budget <= 10⁵ + 1\n\troad consists only of characters '.' and 'x'.",
    "function_signature": "class Solution:\n    def maxPotholes(self, road: str, budget: int) -> int:\n        \n"
  },
  "3120": {
    "question_number": "3120",
    "question_title": "Count the Number of Special Characters I is on the run...",
    "question_description": "You are given a string word. A letter is called special if it appears both in lowercase and uppercase in word.\n\nReturn the number of special letters in word.\n\n \nExample 1:\n\n\nInput: word = \"aaAbcBC\"\n\nOutput: 3\n\nExplanation:\n\nThe special characters in word are 'a', 'b', and 'c'.\n\n\nExample 2:\n\n\nInput: word = \"abc\"\n\nOutput: 0\n\nExplanation:\n\nNo character in word appears in uppercase.\n\n\nExample 3:\n\n\nInput: word = \"abBCab\"\n\nOutput: 1\n\nExplanation:\n\nThe only special character in word is 'b'.\n\n\n \nConstraints:\n\n\n\t1 <= word.length <= 50\n\tword consists of only lowercase and uppercase English letters.",
    "function_signature": "class Solution:\n    def numberOfSpecialChars(self, word: str) -> int:\n        \n"
  },
  "3121": {
    "question_number": "3121",
    "question_title": "Count the Number of Special Characters II is on the run...",
    "question_description": "You are given a string word. A letter c is called special if it appears both in lowercase and uppercase in word, and every lowercase occurrence of c appears before the first uppercase occurrence of c.\n\nReturn the number of special letters in word.\n\n \nExample 1:\n\n\nInput: word = \"aaAbcBC\"\n\nOutput: 3\n\nExplanation:\n\nThe special characters are 'a', 'b', and 'c'.\n\n\nExample 2:\n\n\nInput: word = \"abc\"\n\nOutput: 0\n\nExplanation:\n\nThere are no special characters in word.\n\n\nExample 3:\n\n\nInput: word = \"AbBCab\"\n\nOutput: 0\n\nExplanation:\n\nThere are no special characters in word.\n\n\n \nConstraints:\n\n\n\t1 <= word.length <= 2 * 10⁵\n\tword consists of only lowercase and uppercase English letters.",
    "function_signature": "class Solution:\n    def numberOfSpecialChars(self, word: str) -> int:\n        \n"
  },
  "3122": {
    "question_number": "3122",
    "question_title": "Minimum Number of Operations to Satisfy Conditions is on the run...",
    "question_description": "You are given a 2D matrix grid of size m x n. In one operation, you can change the value of any cell to any non-negative number. You need to perform some operations such that each cell grid[i][j] is:\n\n\n\tEqual to the cell below it, i.e. grid[i][j] == grid[i + 1][j] (if it exists).\n\tDifferent from the cell to its right, i.e. grid[i][j] != grid[i][j + 1] (if it exists).\n\n\nReturn the minimum number of operations needed.\n\n \nExample 1:\n\n\nInput: grid = [[1,0,2],[1,0,2]]\n\nOutput: 0\n\nExplanation:\n\n\n\nAll the cells in the matrix already satisfy the properties.\n\n\nExample 2:\n\n\nInput: grid = [[1,1,1],[0,0,0]]\n\nOutput: 3\n\nExplanation:\n\n\n\nThe matrix becomes [[1,0,1],[1,0,1]] which satisfies the properties, by doing these 3 operations:\n\n\n\tChange grid[1][0] to 1.\n\tChange grid[0][1] to 0.\n\tChange grid[1][2] to 1.\n\n\n\nExample 3:\n\n\nInput: grid = [[1],[2],[3]]\n\nOutput: 2\n\nExplanation:\n\n\n\nThere is a single column. We can change the value to 1 in each cell using 2 operations.\n\n\n \nConstraints:\n\n\n\t1 <= n, m <= 1000\n\t0 <= grid[i][j] <= 9",
    "function_signature": "class Solution:\n    def minimumOperations(self, grid: List[List[int]]) -> int:\n        \n"
  },
  "3123": {
    "question_number": "3123",
    "question_title": "Find Edges in Shortest Paths is on the run...",
    "question_description": "You are given an undirected weighted graph of n nodes numbered from 0 to n - 1. The graph consists of m edges represented by a 2D array edges, where edges[i] = [ai, bi, wi] indicates that there is an edge between nodes ai and bi with weight wi.\n\nConsider all the shortest paths from node 0 to node n - 1 in the graph. You need to find a boolean array answer where answer[i] is true if the edge edges[i] is part of at least one shortest path. Otherwise, answer[i] is false.\n\nReturn the array answer.\n\nNote that the graph may not be connected.\n\n \nExample 1:\n\n\nInput: n = 6, edges = [[0,1,4],[0,2,1],[1,3,2],[1,4,3],[1,5,1],[2,3,1],[3,5,3],[4,5,2]]\n\nOutput: [true,true,true,false,true,true,true,false]\n\nExplanation:\n\nThe following are all the shortest paths between nodes 0 and 5:\n\n\n\tThe path 0 -> 1 -> 5: The sum of weights is 4 + 1 = 5.\n\tThe path 0 -> 2 -> 3 -> 5: The sum of weights is 1 + 1 + 3 = 5.\n\tThe path 0 -> 2 -> 3 -> 1 -> 5: The sum of weights is 1 + 1 + 2 + 1 = 5.\n\n\n\nExample 2:\n\n\nInput: n = 4, edges = [[2,0,1],[0,1,1],[0,3,4],[3,2,2]]\n\nOutput: [true,false,false,true]\n\nExplanation:\n\nThere is one shortest path between nodes 0 and 3, which is the path 0 -> 2 -> 3 with the sum of weights 1 + 2 = 3.\n\n\n \nConstraints:\n\n\n\t2 <= n <= 5 * 10⁴\n\tm == edges.length\n\t1 <= m <= min(5 * 10⁴, n * (n - 1) / 2)\n\t0 <= ai, bi < n\n\tai != bi\n\t1 <= wi <= 10⁵\n\tThere are no repeated edges.",
    "function_signature": "class Solution:\n    def findAnswer(self, n: int, edges: List[List[int]]) -> List[bool]:\n        \n"
  },
  "3125": {
    "question_number": "3125",
    "question_title": "Maximum Number That Makes Result of Bitwise AND Zero is on the run...",
    "question_description": "Given an integer n, return the maximum integer x such that x <= n, and the bitwise AND of all the numbers in the range [x, n] is 0.\n \nExample 1:\n\n\nInput: n = 7\n\nOutput: 3\n\nExplanation:\n\nThe bitwise AND of [6, 7] is 6.\nThe bitwise AND of [5, 6, 7] is 4.\nThe bitwise AND of [4, 5, 6, 7] is 4.\nThe bitwise AND of [3, 4, 5, 6, 7] is 0.\n\n\nExample 2:\n\n\nInput: n = 9\n\nOutput: 7\n\nExplanation:\n\nThe bitwise AND of [7, 8, 9] is 0.\n\n\nExample 3:\n\n\nInput: n = 17\n\nOutput: 15\n\nExplanation:\n\nThe bitwise AND of [15, 16, 17] is 0.\n\n\n \nConstraints:\n\n\n\t1 <= n <= 10¹⁵",
    "function_signature": "class Solution:\n    def maxNumber(self, n: int) -> int:\n        \n"
  },
  "3127": {
    "question_number": "3127",
    "question_title": "Make a Square with the Same Color is on the run...",
    "question_description": "You are given a 2D matrix grid of size 3 x 3 consisting only of characters 'B' and 'W'. Character 'W' represents the white color, and character 'B' represents the black color.\n\nYour task is to change the color of at most one cell so that the matrix has a 2 x 2 square where all cells are of the same color.\n\nReturn true if it is possible to create a 2 x 2 square of the same color, otherwise, return false.\n\n \n.grid-container {\n  display: grid;\n  grid-template-columns: 30px 30px 30px;\n  padding: 10px;\n}\n.grid-item {\n  background-color: black;\n  border: 1px solid gray;\n  height: 30px;\n  font-size: 30px;\n  text-align: center;\n}\n.grid-item-white {\n  background-color: white;\n}\n\n\n\nExample 1:\n\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n\n\nInput: grid = [[\"B\",\"W\",\"B\"],[\"B\",\"W\",\"W\"],[\"B\",\"W\",\"B\"]]\n\nOutput: true\n\nExplanation:\n\nIt can be done by changing the color of the grid[0][2].\n\n\nExample 2:\n\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n\n\nInput: grid = [[\"B\",\"W\",\"B\"],[\"W\",\"B\",\"W\"],[\"B\",\"W\",\"B\"]]\n\nOutput: false\n\nExplanation:\n\nIt cannot be done by changing at most one cell.\n\n\nExample 3:\n\n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n \n\n\n\nInput: grid = [[\"B\",\"W\",\"B\"],[\"B\",\"W\",\"W\"],[\"B\",\"W\",\"W\"]]\n\nOutput: true\n\nExplanation:\n\nThe grid already contains a 2 x 2 square of the same color.\n\n\n \nConstraints:\n\n\n\tgrid.length == 3\n\tgrid[i].length == 3\n\tgrid[i][j] is either 'W' or 'B'.",
    "function_signature": "class Solution:\n    def canMakeSquare(self, grid: List[List[str]]) -> bool:\n        \n"
  },
  "3128": {
    "question_number": "3128",
    "question_title": "Right Triangles is on the run...",
    "question_description": "You are given a 2D boolean matrix grid.\n\nA collection of 3 elements of grid is a right triangle if one of its elements is in the same row with another element and in the same column with the third element. The 3 elements may not be next to each other.\n\nReturn an integer that is the number of right triangles that can be made with 3 elements of grid such that all of them have a value of 1.\n\n \nExample 1:\n\n\n\n\t\n\t\t\n\t\t\t0\n\t\t\t1\n\t\t\t0\n\t\t\n\t\t\n\t\t\t0\n\t\t\t1\n\t\t\t1\n\t\t\n\t\t\n\t\t\t0\n\t\t\t1\n\t\t\t0\n\t\t\n\t\n\n\n\n\t\n\t\t\n\t\t\t0\n\t\t\t1\n\t\t\t0\n\t\t\n\t\t\n\t\t\t0\n\t\t\t1\n\t\t\t1\n\t\t\n\t\t\n\t\t\t0\n\t\t\t1\n\t\t\t0\n\t\t\n\t\n\n\n\n\t\n\t\t\n\t\t\t0\n\t\t\t1\n\t\t\t0\n\t\t\n\t\t\n\t\t\t0\n\t\t\t1\n\t\t\t1\n\t\t\n\t\t\n\t\t\t0\n\t\t\t1\n\t\t\t0\n\t\t\n\t\n\n\n\n\nInput: grid = [[0,1,0],[0,1,1],[0,1,0]]\n\nOutput: 2\n\nExplanation:\n\nThere are two right triangles with elements of the value 1. Notice that the blue ones do not form a right triangle because the 3 elements are in the same column.\n\n\nExample 2:\n\n\n\n\t\n\t\t\n\t\t\t1\n\t\t\t0\n\t\t\t0\n\t\t\t0\n\t\t\n\t\t\n\t\t\t0\n\t\t\t1\n\t\t\t0\n\t\t\t1\n\t\t\n\t\t\n\t\t\t1\n\t\t\t0\n\t\t\t0\n\t\t\t0\n\t\t\n\t\n\n\n\n\nInput: grid = [[1,0,0,0],[0,1,0,1],[1,0,0,0]]\n\nOutput: 0\n\nExplanation:\n\nThere are no right triangles with elements of the value 1.  Notice that the blue ones do not form a right triangle.\n\n\nExample 3:\n\n\n\n\t\n\t\t\n\t\t\t1\n\t\t\t0\n\t\t\t1\n\t\t\n\t\t\n\t\t\t1\n\t\t\t0\n\t\t\t0\n\t\t\n\t\t\n\t\t\t1\n\t\t\t0\n\t\t\t0\n\t\t\n\t\n\n\n\n\t\n\t\t\n\t\t\t1\n\t\t\t0\n\t\t\t1\n\t\t\n\t\t\n\t\t\t1\n\t\t\t0\n\t\t\t0\n\t\t\n\t\t\n\t\t\t1\n\t\t\t0\n\t\t\t0\n\t\t\n\t\n\n\n\n\nInput: grid = [[1,0,1],[1,0,0],[1,0,0]]\n\nOutput: 2\n\nExplanation:\n\nThere are two right triangles with elements of the value 1.\n\n\n \nConstraints:\n\n\n\t1 <= grid.length <= 1000\n\t1 <= grid[i].length <= 1000\n\t0 <= grid[i][j] <= 1",
    "function_signature": "class Solution:\n    def numberOfRightTriangles(self, grid: List[List[int]]) -> int:\n        \n"
  },
  "3129": {
    "question_number": "3129",
    "question_title": "Find All Possible Stable Binary Arrays I is on the run...",
    "question_description": "You are given 3 positive integers zero, one, and limit.\n\nA binary array arr is called stable if:\n\n\n\tThe number of occurrences of 0 in arr is exactly zero.\n\tThe number of occurrences of 1 in arr is exactly one.\n\tEach subarray of arr with a size greater than limit must contain both 0 and 1.\n\n\nReturn the total number of stable binary arrays.\n\nSince the answer may be very large, return it modulo 10⁹ + 7.\n\n \nExample 1:\n\n\nInput: zero = 1, one = 1, limit = 2\n\nOutput: 2\n\nExplanation:\n\nThe two possible stable binary arrays are [1,0] and [0,1], as both arrays have a single 0 and a single 1, and no subarray has a length greater than 2.\n\n\nExample 2:\n\n\nInput: zero = 1, one = 2, limit = 1\n\nOutput: 1\n\nExplanation:\n\nThe only possible stable binary array is [1,0,1].\n\nNote that the binary arrays [1,1,0] and [0,1,1] have subarrays of length 2 with identical elements, hence, they are not stable.\n\n\nExample 3:\n\n\nInput: zero = 3, one = 3, limit = 2\n\nOutput: 14\n\nExplanation:\n\nAll the possible stable binary arrays are [0,0,1,0,1,1], [0,0,1,1,0,1], [0,1,0,0,1,1], [0,1,0,1,0,1], [0,1,0,1,1,0], [0,1,1,0,0,1], [0,1,1,0,1,0], [1,0,0,1,0,1], [1,0,0,1,1,0], [1,0,1,0,0,1], [1,0,1,0,1,0], [1,0,1,1,0,0], [1,1,0,0,1,0], and [1,1,0,1,0,0].\n\n\n \nConstraints:\n\n\n\t1 <= zero, one, limit <= 200",
    "function_signature": "class Solution:\n    def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:\n        \n"
  },
  "3130": {
    "question_number": "3130",
    "question_title": "Find All Possible Stable Binary Arrays II is on the run...",
    "question_description": "You are given 3 positive integers zero, one, and limit.\n\nA binary array arr is called stable if:\n\n\n\tThe number of occurrences of 0 in arr is exactly zero.\n\tThe number of occurrences of 1 in arr is exactly one.\n\tEach subarray of arr with a size greater than limit must contain both 0 and 1.\n\n\nReturn the total number of stable binary arrays.\n\nSince the answer may be very large, return it modulo 10⁹ + 7.\n\n \nExample 1:\n\n\nInput: zero = 1, one = 1, limit = 2\n\nOutput: 2\n\nExplanation:\n\nThe two possible stable binary arrays are [1,0] and [0,1].\n\n\nExample 2:\n\n\nInput: zero = 1, one = 2, limit = 1\n\nOutput: 1\n\nExplanation:\n\nThe only possible stable binary array is [1,0,1].\n\n\nExample 3:\n\n\nInput: zero = 3, one = 3, limit = 2\n\nOutput: 14\n\nExplanation:\n\nAll the possible stable binary arrays are [0,0,1,0,1,1], [0,0,1,1,0,1], [0,1,0,0,1,1], [0,1,0,1,0,1], [0,1,0,1,1,0], [0,1,1,0,0,1], [0,1,1,0,1,0], [1,0,0,1,0,1], [1,0,0,1,1,0], [1,0,1,0,0,1], [1,0,1,0,1,0], [1,0,1,1,0,0], [1,1,0,0,1,0], and [1,1,0,1,0,0].\n\n\n \nConstraints:\n\n\n\t1 <= zero, one, limit <= 1000",
    "function_signature": "class Solution:\n    def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:\n        \n"
  },
  "3131": {
    "question_number": "3131",
    "question_title": "Find the Integer Added to Array I is on the run...",
    "question_description": "You are given two arrays of equal length, nums1 and nums2.\n\nEach element in nums1 has been increased (or decreased in the case of negative) by an integer, represented by the variable x.\n\nAs a result, nums1 becomes equal to nums2. Two arrays are considered equal when they contain the same integers with the same frequencies.\n\nReturn the integer x.\n\n \nExample 1:\n\n\nInput: nums1 = [2,6,4], nums2 = [9,7,5]\n\nOutput: 3\n\nExplanation:\n\nThe integer added to each element of nums1 is 3.\n\n\nExample 2:\n\n\nInput: nums1 = [10], nums2 = [5]\n\nOutput: -5\n\nExplanation:\n\nThe integer added to each element of nums1 is -5.\n\n\nExample 3:\n\n\nInput: nums1 = [1,1,1,1], nums2 = [1,1,1,1]\n\nOutput: 0\n\nExplanation:\n\nThe integer added to each element of nums1 is 0.\n\n\n \nConstraints:\n\n\n\t1 <= nums1.length == nums2.length <= 100\n\t0 <= nums1[i], nums2[i] <= 1000\n\tThe test cases are generated in a way that there is an integer x such that nums1 can become equal to nums2 by adding x to each element of nums1.",
    "function_signature": "class Solution:\n    def addedInteger(self, nums1: List[int], nums2: List[int]) -> int:\n        \n"
  },
  "3132": {
    "question_number": "3132",
    "question_title": "Find the Integer Added to Array II is on the run...",
    "question_description": "You are given two integer arrays nums1 and nums2.\n\nFrom nums1 two elements have been removed, and all other elements have been increased (or decreased in the case of negative) by an integer, represented by the variable x.\n\nAs a result, nums1 becomes equal to nums2. Two arrays are considered equal when they contain the same integers with the same frequencies.\n\nReturn the minimum possible integer x that achieves this equivalence.\n\n \nExample 1:\n\n\nInput: nums1 = [4,20,16,12,8], nums2 = [14,18,10]\n\nOutput: -2\n\nExplanation:\n\nAfter removing elements at indices [0,4] and adding -2, nums1 becomes [18,14,10].\n\n\nExample 2:\n\n\nInput: nums1 = [3,5,5,3], nums2 = [7,7]\n\nOutput: 2\n\nExplanation:\n\nAfter removing elements at indices [0,3] and adding 2, nums1 becomes [7,7].\n\n\n \nConstraints:\n\n\n\t3 <= nums1.length <= 200\n\tnums2.length == nums1.length - 2\n\t0 <= nums1[i], nums2[i] <= 1000\n\tThe test cases are generated in a way that there is an integer x such that nums1 can become equal to nums2 by removing two elements and adding x to each element of nums1.",
    "function_signature": "class Solution:\n    def minimumAddedInteger(self, nums1: List[int], nums2: List[int]) -> int:\n        \n"
  },
  "3133": {
    "question_number": "3133",
    "question_title": "Minimum Array End is on the run...",
    "question_description": "You are given two integers n and x. You have to construct an array of positive integers nums of size n where for every 0 <= i < n - 1, nums[i + 1] is greater than nums[i], and the result of the bitwise AND operation between all elements of nums is x.\n\nReturn the minimum possible value of nums[n - 1].\n\n \nExample 1:\n\n\nInput: n = 3, x = 4\n\nOutput: 6\n\nExplanation:\n\nnums can be [4,5,6] and its last element is 6.\n\n\nExample 2:\n\n\nInput: n = 2, x = 7\n\nOutput: 15\n\nExplanation:\n\nnums can be [7,15] and its last element is 15.\n\n\n \nConstraints:\n\n\n\t1 <= n, x <= 10⁸",
    "function_signature": "class Solution:\n    def minEnd(self, n: int, x: int) -> int:\n        \n"
  },
  "3134": {
    "question_number": "3134",
    "question_title": "Find the Median of the Uniqueness Array is on the run...",
    "question_description": "You are given an integer array nums. The uniqueness array of nums is the sorted array that contains the number of distinct elements of all the subarrays of nums. In other words, it is a sorted array consisting of distinct(nums[i..j]), for all 0 <= i <= j < nums.length.\n\nHere, distinct(nums[i..j]) denotes the number of distinct elements in the subarray that starts at index i and ends at index j.\n\nReturn the median of the uniqueness array of nums.\n\nNote that the median of an array is defined as the middle element of the array when it is sorted in non-decreasing order. If there are two choices for a median, the smaller of the two values is taken.\n\n \nExample 1:\n\n\nInput: nums = [1,2,3]\n\nOutput: 1\n\nExplanation:\n\nThe uniqueness array of nums is [distinct(nums[0..0]), distinct(nums[1..1]), distinct(nums[2..2]), distinct(nums[0..1]), distinct(nums[1..2]), distinct(nums[0..2])] which is equal to [1, 1, 1, 2, 2, 3]. The uniqueness array has a median of 1. Therefore, the answer is 1.\n\n\nExample 2:\n\n\nInput: nums = [3,4,3,4,5]\n\nOutput: 2\n\nExplanation:\n\nThe uniqueness array of nums is [1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3]. The uniqueness array has a median of 2. Therefore, the answer is 2.\n\n\nExample 3:\n\n\nInput: nums = [4,3,5,4]\n\nOutput: 2\n\nExplanation:\n\nThe uniqueness array of nums is [1, 1, 1, 1, 2, 2, 2, 3, 3, 3]. The uniqueness array has a median of 2. Therefore, the answer is 2.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 10⁵\n\t1 <= nums[i] <= 10⁵",
    "function_signature": "class Solution:\n    def medianOfUniquenessArray(self, nums: List[int]) -> int:\n        \n"
  },
  "3135": {
    "question_number": "3135",
    "question_title": "Equalize Strings by Adding or Removing Characters at Ends is on the run...",
    "question_description": "Given two strings initial and target, your task is to modify initial by performing a series of operations to make it equal to target.\n\nIn one operation, you can add or remove one character only at the beginning or the end of the string initial.\n\nReturn the minimum number of operations required to transform initial into target.\n\n \nExample 1:\n\n\nInput: initial = \"abcde\", target = \"cdef\"\n\nOutput: 3\n\nExplanation:\n\nRemove 'a' and 'b' from the beginning of initial, then add 'f' to the end.\n\n\nExample 2:\n\n\nInput: initial = \"axxy\", target = \"yabx\"\n\nOutput: 6\n\nExplanation:\n\n\n\t\n\t\t\n\t\t\tOperation\n\t\t\tResulting String\n\t\t\n\t\t\n\t\t\tAdd 'y' to the beginning\n\t\t\t\"yaxxy\"\n\t\t\n\t\t\n\t\t\tRemove from end\n\t\t\t\"yaxx\"\n\t\t\n\t\t\n\t\t\tRemove from end\n\t\t\t\"yax\"\n\t\t\n\t\t\n\t\t\tRemove from end\n\t\t\t\"ya\"\n\t\t\n\t\t\n\t\t\tAdd 'b' to the end\n\t\t\t\"yab\"\n\t\t\n\t\t\n\t\t\tAdd 'x' to the end\n\t\t\t\"yabx\"\n\t\t\n\t\n\n\n\nExample 3:\n\n\nInput: initial = \"xyz\", target = \"xyz\"\n\nOutput: 0\n\nExplanation:\n\nNo operations are needed as the strings are already equal.\n\n\n \nConstraints:\n\n\n\t1 <= initial.length, target.length <= 1000\n\tinitial and target consist only of lowercase English letters.",
    "function_signature": "class Solution:\n    def minOperations(self, initial: str, target: str) -> int:\n        \n"
  },
  "3136": {
    "question_number": "3136",
    "question_title": "Valid Word is on the run...",
    "question_description": "A word is considered valid if:\n\n\n\tIt contains a minimum of 3 characters.\n\tIt contains only digits (0-9), and English letters (uppercase and lowercase).\n\tIt includes at least one vowel.\n\tIt includes at least one consonant.\n\n\nYou are given a string word.\n\nReturn true if word is valid, otherwise, return false.\n\nNotes:\n\n\n\t'a', 'e', 'i', 'o', 'u', and their uppercases are vowels.\n\tA consonant is an English letter that is not a vowel.\n\n\n \nExample 1:\n\n\nInput: word = \"234Adas\"\n\nOutput: true\n\nExplanation:\n\nThis word satisfies the conditions.\n\n\nExample 2:\n\n\nInput: word = \"b3\"\n\nOutput: false\n\nExplanation:\n\nThe length of this word is fewer than 3, and does not have a vowel.\n\n\nExample 3:\n\n\nInput: word = \"a3$e\"\n\nOutput: false\n\nExplanation:\n\nThis word contains a '$' character and does not have a consonant.\n\n\n \nConstraints:\n\n\n\t1 <= word.length <= 20\n\tword consists of English uppercase and lowercase letters, digits, '@', '#', and '$'.",
    "function_signature": "class Solution:\n    def isValid(self, word: str) -> bool:\n        \n"
  },
  "3137": {
    "question_number": "3137",
    "question_title": "Minimum Number of Operations to Make Word K-Periodic is on the run...",
    "question_description": "You are given a string word of size n, and an integer k such that k divides n.\n\nIn one operation, you can pick any two indices i and j, that are divisible by k, then replace the substring of length k starting at i with the substring of length k starting at j. That is, replace the substring word[i..i + k - 1] with the substring word[j..j + k - 1].\n\nReturn the minimum number of operations required to make word k-periodic.\n\nWe say that word is k-periodic if there is some string s of length k such that word can be obtained by concatenating s an arbitrary number of times. For example, if word == “ababab”, then word is 2-periodic for s = \"ab\".\n\n \nExample 1:\n\n\nInput: word = \"leetcodeleet\", k = 4\n\nOutput: 1\n\nExplanation:\n\nWe can obtain a 4-periodic string by picking i = 4 and j = 0. After this operation, word becomes equal to \"leetleetleet\".\n\n\nExample 2:\n\n\nInput: word = \"leetcoleet\", k = 2\n\nOutput: 3\n\nExplanation:\n\nWe can obtain a 2-periodic string by applying the operations in the table below.\n\n\n\t\n\t\t\n\t\t\ti\n\t\t\tj\n\t\t\tword\n\t\t\n\t\t\n\t\t\t0\n\t\t\t2\n\t\t\tetetcoleet\n\t\t\n\t\t\n\t\t\t4\n\t\t\t0\n\t\t\tetetetleet\n\t\t\n\t\t\n\t\t\t6\n\t\t\t0\n\t\t\tetetetetet\n\t\t\n\t\n\n\n\n\n \n\n\n \nConstraints:\n\n\n\t1 <= n == word.length <= 10⁵\n\t1 <= k <= word.length\n\tk divides word.length.\n\tword consists only of lowercase English letters.",
    "function_signature": "class Solution:\n    def minimumOperationsToMakeKPeriodic(self, word: str, k: int) -> int:\n        \n"
  },
  "3138": {
    "question_number": "3138",
    "question_title": "Minimum Length of Anagram Concatenation is on the run...",
    "question_description": "You are given a string s, which is known to be a concatenation of anagrams of some string t.\n\nReturn the minimum possible length of the string t.\n\nAn anagram is formed by rearranging the letters of a string. For example, \"aab\", \"aba\", and, \"baa\" are anagrams of \"aab\".\n\n \nExample 1:\n\n\nInput: s = \"abba\"\n\nOutput: 2\n\nExplanation:\n\nOne possible string t could be \"ba\".\n\n\nExample 2:\n\n\nInput: s = \"cdef\"\n\nOutput: 4\n\nExplanation:\n\nOne possible string t could be \"cdef\", notice that t can be equal to s.\n\n\nExample 2:\n\n\nInput: s = \"abcbcacabbaccba\"\n\nOutput: 3\n\n\n \nConstraints:\n\n\n\t1 <= s.length <= 10⁵\n\ts consist only of lowercase English letters.",
    "function_signature": "class Solution:\n    def minAnagramLength(self, s: str) -> int:\n        \n"
  },
  "3139": {
    "question_number": "3139",
    "question_title": "Minimum Cost to Equalize Array is on the run...",
    "question_description": "You are given an integer array nums and two integers cost1 and cost2. You are allowed to perform either of the following operations any number of times:\n\n\n\tChoose an index i from nums and increase nums[i] by 1 for a cost of cost1.\n\tChoose two different indices i, j, from nums and increase nums[i] and nums[j] by 1 for a cost of cost2.\n\n\nReturn the minimum cost required to make all elements in the array equal. \n\nSince the answer may be very large, return it modulo 10⁹ + 7.\n\n \nExample 1:\n\n\nInput: nums = [4,1], cost1 = 5, cost2 = 2\n\nOutput: 15\n\nExplanation: \n\nThe following operations can be performed to make the values equal:\n\n\n\tIncrease nums[1] by 1 for a cost of 5. nums becomes [4,2].\n\tIncrease nums[1] by 1 for a cost of 5. nums becomes [4,3].\n\tIncrease nums[1] by 1 for a cost of 5. nums becomes [4,4].\n\n\nThe total cost is 15.\n\n\nExample 2:\n\n\nInput: nums = [2,3,3,3,5], cost1 = 2, cost2 = 1\n\nOutput: 6\n\nExplanation: \n\nThe following operations can be performed to make the values equal:\n\n\n\tIncrease nums[0] and nums[1] by 1 for a cost of 1. nums becomes [3,4,3,3,5].\n\tIncrease nums[0] and nums[2] by 1 for a cost of 1. nums becomes [4,4,4,3,5].\n\tIncrease nums[0] and nums[3] by 1 for a cost of 1. nums becomes [5,4,4,4,5].\n\tIncrease nums[1] and nums[2] by 1 for a cost of 1. nums becomes [5,5,5,4,5].\n\tIncrease nums[3] by 1 for a cost of 2. nums becomes [5,5,5,5,5].\n\n\nThe total cost is 6.\n\n\nExample 3:\n\n\nInput: nums = [3,5,3], cost1 = 1, cost2 = 3\n\nOutput: 4\n\nExplanation:\n\nThe following operations can be performed to make the values equal:\n\n\n\tIncrease nums[0] by 1 for a cost of 1. nums becomes [4,5,3].\n\tIncrease nums[0] by 1 for a cost of 1. nums becomes [5,5,3].\n\tIncrease nums[2] by 1 for a cost of 1. nums becomes [5,5,4].\n\tIncrease nums[2] by 1 for a cost of 1. nums becomes [5,5,5].\n\n\nThe total cost is 4.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 10⁵\n\t1 <= nums[i] <= 10⁶\n\t1 <= cost1 <= 10⁶\n\t1 <= cost2 <= 10⁶",
    "function_signature": "class Solution:\n    def minCostToEqualizeArray(self, nums: List[int], cost1: int, cost2: int) -> int:\n        \n"
  },
  "3141": {
    "question_number": "3141",
    "question_title": "Maximum Hamming Distances is on the run...",
    "question_description": "Given an array nums and an integer m, with each element nums[i] satisfying 0 <= nums[i] < 2m, return an array answer. The answer array should be of the same length as nums, where each element answer[i] represents the maximum Hamming distance between nums[i] and any other element nums[j] in the array.\n\nThe Hamming distance between two binary integers is defined as the number of positions at which the corresponding bits differ (add leading zeroes if needed).\n\n \nExample 1:\n\n\nInput: nums = [9,12,9,11], m = 4\n\nOutput: [2,3,2,3]\n\nExplanation:\n\nThe binary representation of nums = [1001,1100,1001,1011].\n\nThe maximum hamming distances for each index are:\n\n\n\tnums[0]: 1001 and 1100 have a distance of 2.\n\tnums[1]: 1100 and 1011 have a distance of 3.\n\tnums[2]: 1001 and 1100 have a distance of 2.\n\tnums[3]: 1011 and 1100 have a distance of 3.\n\n\n\nExample 2:\n\n\nInput: nums = [3,4,6,10], m = 4\n\nOutput: [3,3,2,3]\n\nExplanation:\n\nThe binary representation of nums = [0011,0100,0110,1010].\n\nThe maximum hamming distances for each index are:\n\n\n\tnums[0]: 0011 and 0100 have a distance of 3.\n\tnums[1]: 0100 and 0011 have a distance of 3.\n\tnums[2]: 0110 and 1010 have a distance of 2.\n\tnums[3]: 1010 and 0100 have a distance of 3.\n\n\n\n \nConstraints:\n\n\n\t1 <= m <= 17\n\t2 <= nums.length <= 2m\n\t0 <= nums[i] < 2m",
    "function_signature": "class Solution:\n    def maxHammingDistances(self, nums: List[int], m: int) -> List[int]:\n        \n"
  },
  "3142": {
    "question_number": "3142",
    "question_title": "Check if Grid Satisfies Conditions is on the run...",
    "question_description": "You are given a 2D matrix grid of size m x n. You need to check if each cell grid[i][j] is:\n\n\n\tEqual to the cell below it, i.e. grid[i][j] == grid[i + 1][j] (if it exists).\n\tDifferent from the cell to its right, i.e. grid[i][j] != grid[i][j + 1] (if it exists).\n\n\nReturn true if all the cells satisfy these conditions, otherwise, return false.\n\n \nExample 1:\n\n\nInput: grid = [[1,0,2],[1,0,2]]\n\nOutput: true\n\nExplanation:\n\n\n\nAll the cells in the grid satisfy the conditions.\n\n\nExample 2:\n\n\nInput: grid = [[1,1,1],[0,0,0]]\n\nOutput: false\n\nExplanation:\n\n\n\nAll cells in the first row are equal.\n\n\nExample 3:\n\n\nInput: grid = [[1],[2],[3]]\n\nOutput: false\n\nExplanation:\n\n\n\nCells in the first column have different values.\n\n\n \nConstraints:\n\n\n\t1 <= n, m <= 10\n\t0 <= grid[i][j] <= 9",
    "function_signature": "class Solution:\n    def satisfiesConditions(self, grid: List[List[int]]) -> bool:\n        \n"
  },
  "3143": {
    "question_number": "3143",
    "question_title": "Maximum Points Inside the Square is on the run...",
    "question_description": "You are given a 2D array points and a string s where, points[i] represents the coordinates of point i, and s[i] represents the tag of point i.\n\nA valid square is a square centered at the origin (0, 0), has edges parallel to the axes, and does not contain two points with the same tag.\n\nReturn the maximum number of points contained in a valid square.\n\nNote:\n\n\n\tA point is considered to be inside the square if it lies on or within the square's boundaries.\n\tThe side length of the square can be zero.\n\n\n \nExample 1:\n\n\n\n\nInput: points = [[2,2],[-1,-2],[-4,4],[-3,1],[3,-3]], s = \"abdca\"\n\nOutput: 2\n\nExplanation:\n\nThe square of side length 4 covers two points points[0] and points[1].\n\n\nExample 2:\n\n\n\n\nInput: points = [[1,1],[-2,-2],[-2,2]], s = \"abb\"\n\nOutput: 1\n\nExplanation:\n\nThe square of side length 2 covers one point, which is points[0].\n\n\nExample 3:\n\n\nInput: points = [[1,1],[-1,-1],[2,-2]], s = \"ccd\"\n\nOutput: 0\n\nExplanation:\n\nIt's impossible to make any valid squares centered at the origin such that it covers only one point among points[0] and points[1].\n\n\n \nConstraints:\n\n\n\t1 <= s.length, points.length <= 10⁵\n\tpoints[i].length == 2\n\t-10⁹ <= points[i][0], points[i][1] <= 10⁹\n\ts.length == points.length\n\tpoints consists of distinct coordinates.\n\ts consists only of lowercase English letters.",
    "function_signature": "class Solution:\n    def maxPointsInsideSquare(self, points: List[List[int]], s: str) -> int:\n        \n"
  },
  "3144": {
    "question_number": "3144",
    "question_title": "Minimum Substring Partition of Equal Character Frequency is on the run...",
    "question_description": "Given a string s, you need to partition it into one or more balanced substrings. For example, if s == \"ababcc\" then (\"abab\", \"c\", \"c\"), (\"ab\", \"abc\", \"c\"), and (\"ababcc\") are all valid partitions, but (\"a\", \"bab\", \"cc\"), (\"aba\", \"bc\", \"c\"), and (\"ab\", \"abcc\") are not. The unbalanced substrings are bolded.\n\nReturn the minimum number of substrings that you can partition s into.\n\nNote: A balanced string is a string where each character in the string occurs the same number of times.\n\n \nExample 1:\n\n\nInput: s = \"fabccddg\"\n\nOutput: 3\n\nExplanation:\n\nWe can partition the string s into 3 substrings in one of the following ways: (\"fab, \"ccdd\", \"g\"), or (\"fabc\", \"cd\", \"dg\").\n\n\nExample 2:\n\n\nInput: s = \"abababaccddb\"\n\nOutput: 2\n\nExplanation:\n\nWe can partition the string s into 2 substrings like so: (\"abab\", \"abaccddb\").\n\n\n \nConstraints:\n\n\n\t1 <= s.length <= 1000\n\ts consists only of English lowercase letters.",
    "function_signature": "class Solution:\n    def minimumSubstringsInPartition(self, s: str) -> int:\n        \n"
  },
  "3145": {
    "question_number": "3145",
    "question_title": "Find Products of Elements of Big Array is on the run...",
    "question_description": "The powerful array of a non-negative integer x is defined as the shortest sorted array of powers of two that sum up to x. The table below illustrates examples of how the powerful array is determined. It can be proven that the powerful array of x is unique.\n\n\n\t\n\t\t\n\t\t\tnum\n\t\t\tBinary Representation\n\t\t\tpowerful array\n\t\t\n\t\t\n\t\t\t1\n\t\t\t00001\n\t\t\t[1]\n\t\t\n\t\t\n\t\t\t8\n\t\t\t01000\n\t\t\t[8]\n\t\t\n\t\t\n\t\t\t10\n\t\t\t01010\n\t\t\t[2, 8]\n\t\t\n\t\t\n\t\t\t13\n\t\t\t01101\n\t\t\t[1, 4, 8]\n\t\t\n\t\t\n\t\t\t23\n\t\t\t10111\n\t\t\t[1, 2, 4, 16]\n\t\t\n\t\n\n\nThe array big_nums is created by concatenating the powerful arrays for every positive integer i in ascending order: 1, 2, 3, and so on. Thus, big_nums begins as [1, 2, 1, 2, 4, 1, 4, 2, 4, 1, 2, 4, 8, ...].\n\nYou are given a 2D integer matrix queries, where for queries[i] = [fromi, toi, modi] you should calculate (big_nums[fromi] * big_nums[fromi + 1] * ... * big_nums[toi]) % modi.\n\nReturn an integer array answer such that answer[i] is the answer to the ith query.\n\n \nExample 1:\n\n\nInput: queries = [[1,3,7]]\n\nOutput: [4]\n\nExplanation:\n\nThere is one query.\n\nbig_nums[1..3] = [2,1,2]. The product of them is 4. The result is 4 % 7 = 4.\n\n\nExample 2:\n\n\nInput: queries = [[2,5,3],[7,7,4]]\n\nOutput: [2,2]\n\nExplanation:\n\nThere are two queries.\n\nFirst query: big_nums[2..5] = [1,2,4,1]. The product of them is 8. The result is 8 % 3 = 2.\n\nSecond query: big_nums[7] = 2. The result is 2 % 4 = 2.\n\n\n \nConstraints:\n\n\n\t1 <= queries.length <= 500\n\tqueries[i].length == 3\n\t0 <= queries[i][0] <= queries[i][1] <= 10¹⁵\n\t1 <= queries[i][2] <= 10⁵",
    "function_signature": "class Solution:\n    def findProductsOfElements(self, queries: List[List[int]]) -> List[int]:\n        \n"
  },
  "3146": {
    "question_number": "3146",
    "question_title": "Permutation Difference between Two Strings is on the run...",
    "question_description": "You are given two strings s and t such that every character occurs at most once in s and t is a permutation of s.\n\nThe permutation difference between s and t is defined as the sum of the absolute difference between the index of the occurrence of each character in s and the index of the occurrence of the same character in t.\n\nReturn the permutation difference between s and t.\n\n \nExample 1:\n\n\nInput: s = \"abc\", t = \"bac\"\n\nOutput: 2\n\nExplanation:\n\nFor s = \"abc\" and t = \"bac\", the permutation difference of s and t is equal to the sum of:\n\n\n\tThe absolute difference between the index of the occurrence of \"a\" in s and the index of the occurrence of \"a\" in t.\n\tThe absolute difference between the index of the occurrence of \"b\" in s and the index of the occurrence of \"b\" in t.\n\tThe absolute difference between the index of the occurrence of \"c\" in s and the index of the occurrence of \"c\" in t.\n\n\nThat is, the permutation difference between s and t is equal to |0 - 1| + |1 - 0| + |2 - 2| = 2.\n\n\nExample 2:\n\n\nInput: s = \"abcde\", t = \"edbac\"\n\nOutput: 12\n\nExplanation: The permutation difference between s and t is equal to |0 - 3| + |1 - 2| + |2 - 4| + |3 - 1| + |4 - 0| = 12.\n\n\n \nConstraints:\n\n\n\t1 <= s.length <= 26\n\tEach character occurs at most once in s.\n\tt is a permutation of s.\n\ts consists only of lowercase English letters.",
    "function_signature": "class Solution:\n    def findPermutationDifference(self, s: str, t: str) -> int:\n        \n"
  },
  "3147": {
    "question_number": "3147",
    "question_title": "Taking Maximum Energy From the Mystic Dungeon is on the run...",
    "question_description": "In a mystic dungeon, n magicians are standing in a line. Each magician has an attribute that gives you energy. Some magicians can give you negative energy, which means taking energy from you.\n\nYou have been cursed in such a way that after absorbing energy from magician i, you will be instantly transported to magician (i + k). This process will be repeated until you reach the magician where (i + k) does not exist.\n\nIn other words, you will choose a starting point and then teleport with k jumps until you reach the end of the magicians' sequence, absorbing all the energy during the journey.\n\nYou are given an array energy and an integer k. Return the maximum possible energy you can gain.\n\nNote that when you are reach a magician, you must take energy from them, whether it is negative or positive energy.\n\n \nExample 1:\n\n\nInput:  energy = [5,2,-10,-5,1], k = 3\n\nOutput: 3\n\nExplanation: We can gain a total energy of 3 by starting from magician 1 absorbing 2 + 1 = 3.\n\n\nExample 2:\n\n\nInput: energy = [-2,-3,-1], k = 2\n\nOutput: -1\n\nExplanation: We can gain a total energy of -1 by starting from magician 2.\n\n\n \nConstraints:\n\n\n\t1 <= energy.length <= 10⁵\n\t-1000 <= energy[i] <= 1000\n\t1 <= k <= energy.length - 1\n\n\n \n​​​​​​",
    "function_signature": "class Solution:\n    def maximumEnergy(self, energy: List[int], k: int) -> int:\n        \n"
  },
  "3148": {
    "question_number": "3148",
    "question_title": "Maximum Difference Score in a Grid is on the run...",
    "question_description": "You are given an m x n matrix grid consisting of positive integers. You can move from a cell in the matrix to any other cell that is either to the bottom or to the right (not necessarily adjacent). The score of a move from a cell with the value c1 to a cell with the value c2 is c2 - c1.\n\nYou can start at any cell, and you have to make at least one move.\n\nReturn the maximum total score you can achieve.\n\n \nExample 1:\n\n\nInput: grid = [[9,5,7,3],[8,9,6,1],[6,7,14,3],[2,5,3,1]]\n\nOutput: 9\n\nExplanation: We start at the cell (0, 1), and we perform the following moves:\n- Move from the cell (0, 1) to (2, 1) with a score of 7 - 5 = 2.\n- Move from the cell (2, 1) to (2, 2) with a score of 14 - 7 = 7.\nThe total score is 2 + 7 = 9.\n\n\nExample 2:\n\n\n\n\nInput: grid = [[4,3,2],[3,2,1]]\n\nOutput: -1\n\nExplanation: We start at the cell (0, 0), and we perform one move: (0, 0) to (0, 1). The score is 3 - 4 = -1.\n\n\n \nConstraints:\n\n\n\tm == grid.length\n\tn == grid[i].length\n\t2 <= m, n <= 1000\n\t4 <= m * n <= 10⁵\n\t1 <= grid[i][j] <= 10⁵",
    "function_signature": "class Solution:\n    def maxScore(self, grid: List[List[int]]) -> int:\n        \n"
  },
  "3149": {
    "question_number": "3149",
    "question_title": "Find the Minimum Cost Array Permutation is on the run...",
    "question_description": "You are given an array nums which is a permutation of [0, 1, 2, ..., n - 1]. The score of any permutation of [0, 1, 2, ..., n - 1] named perm is defined as:\n\nscore(perm) = |perm[0] - nums[perm[1]]| + |perm[1] - nums[perm[2]]| + ... + |perm[n - 1] - nums[perm[0]]|\n\nReturn the permutation perm which has the minimum possible score. If multiple permutations exist with this score, return the one that is lexicographically smallest among them.\n\n \nExample 1:\n\n\nInput: nums = [1,0,2]\n\nOutput: [0,1,2]\n\nExplanation:\n\n\n\nThe lexicographically smallest permutation with minimum cost is [0,1,2]. The cost of this permutation is |0 - 0| + |1 - 2| + |2 - 1| = 2.\n\n\nExample 2:\n\n\nInput: nums = [0,2,1]\n\nOutput: [0,2,1]\n\nExplanation:\n\n\n\nThe lexicographically smallest permutation with minimum cost is [0,2,1]. The cost of this permutation is |0 - 1| + |2 - 2| + |1 - 0| = 2.\n\n\n \nConstraints:\n\n\n\t2 <= n == nums.length <= 14\n\tnums is a permutation of [0, 1, 2, ..., n - 1].",
    "function_signature": "class Solution:\n    def findPermutation(self, nums: List[int]) -> List[int]:\n        \n"
  },
  "3151": {
    "question_number": "3151",
    "question_title": "Special Array I is on the run...",
    "question_description": "An array is considered special if the parity of every pair of adjacent elements is different. In other words, one element in each pair must be even, and the other must be odd.\n\nYou are given an array of integers nums. Return true if nums is a special array, otherwise, return false.\n\n \nExample 1:\n\n\nInput: nums = [1]\n\nOutput: true\n\nExplanation:\n\nThere is only one element. So the answer is true.\n\n\nExample 2:\n\n\nInput: nums = [2,1,4]\n\nOutput: true\n\nExplanation:\n\nThere is only two pairs: (2,1) and (1,4), and both of them contain numbers with different parity. So the answer is true.\n\n\nExample 3:\n\n\nInput: nums = [4,3,1,6]\n\nOutput: false\n\nExplanation:\n\nnums[1] and nums[2] are both odd. So the answer is false.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 100\n\t1 <= nums[i] <= 100",
    "function_signature": "class Solution:\n    def isArraySpecial(self, nums: List[int]) -> bool:\n        \n"
  },
  "3152": {
    "question_number": "3152",
    "question_title": "Special Array II is on the run...",
    "question_description": "An array is considered special if every pair of its adjacent elements contains two numbers with different parity.\n\nYou are given an array of integer nums and a 2D integer matrix queries, where for queries[i] = [fromi, toi] your task is to check that subarray nums[fromi..toi] is special or not.\n\nReturn an array of booleans answer such that answer[i] is true if nums[fromi..toi] is special.\n\n \nExample 1:\n\n\nInput: nums = [3,4,1,2,6], queries = [[0,4]]\n\nOutput: [false]\n\nExplanation:\n\nThe subarray is [3,4,1,2,6]. 2 and 6 are both even.\n\n\nExample 2:\n\n\nInput: nums = [4,3,1,6], queries = [[0,2],[2,3]]\n\nOutput: [false,true]\n\nExplanation:\n\n\n\tThe subarray is [4,3,1]. 3 and 1 are both odd. So the answer to this query is false.\n\tThe subarray is [1,6]. There is only one pair: (1,6) and it contains numbers with different parity. So the answer to this query is true.\n\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 10⁵\n\t1 <= nums[i] <= 10⁵\n\t1 <= queries.length <= 10⁵\n\tqueries[i].length == 2\n\t0 <= queries[i][0] <= queries[i][1] <= nums.length - 1",
    "function_signature": "class Solution:\n    def isArraySpecial(self, nums: List[int], queries: List[List[int]]) -> List[bool]:\n        \n"
  },
  "3153": {
    "question_number": "3153",
    "question_title": "Sum of Digit Differences of All Pairs is on the run...",
    "question_description": "You are given an array nums consisting of positive integers where all integers have the same number of digits.\n\nThe digit difference between two integers is the count of different digits that are in the same position in the two integers.\n\nReturn the sum of the digit differences between all pairs of integers in nums.\n\n \nExample 1:\n\n\nInput: nums = [13,23,12]\n\nOutput: 4\n\nExplanation:\nWe have the following:\n- The digit difference between 13 and 23 is 1.\n- The digit difference between 13 and 12 is 1.\n- The digit difference between 23 and 12 is 2.\nSo the total sum of digit differences between all pairs of integers is 1 + 1 + 2 = 4.\n\n\nExample 2:\n\n\nInput: nums = [10,10,10,10]\n\nOutput: 0\n\nExplanation:\nAll the integers in the array are the same. So the total sum of digit differences between all pairs of integers will be 0.\n\n\n \nConstraints:\n\n\n\t2 <= nums.length <= 10⁵\n\t1 <= nums[i] < 10⁹\n\tAll integers in nums have the same number of digits.",
    "function_signature": "class Solution:\n    def sumDigitDifferences(self, nums: List[int]) -> int:\n        \n"
  },
  "3154": {
    "question_number": "3154",
    "question_title": "Find Number of Ways to Reach the K-th Stair is on the run...",
    "question_description": "You are given a non-negative integer k. There exists a staircase with an infinite number of stairs, with the lowest stair numbered 0.\n\nAlice has an integer jump, with an initial value of 0. She starts on stair 1 and wants to reach stair k using any number of operations. If she is on stair i, in one operation she can:\n\n\n\tGo down to stair i - 1. This operation cannot be used consecutively or on stair 0.\n\tGo up to stair i + 2jump. And then, jump becomes jump + 1.\n\n\nReturn the total number of ways Alice can reach stair k.\n\nNote that it is possible that Alice reaches the stair k, and performs some operations to reach the stair k again.\n\n \nExample 1:\n\n\nInput: k = 0\n\nOutput: 2\n\nExplanation:\n\nThe 2 possible ways of reaching stair 0 are:\n\n\n\tAlice starts at stair 1.\n\t\n\t\tUsing an operation of the first type, she goes down 1 stair to reach stair 0.\n\t\n\t\n\tAlice starts at stair 1.\n\t\n\t\tUsing an operation of the first type, she goes down 1 stair to reach stair 0.\n\t\tUsing an operation of the second type, she goes up 2⁰ stairs to reach stair 1.\n\t\tUsing an operation of the first type, she goes down 1 stair to reach stair 0.\n\t\n\t\n\n\n\nExample 2:\n\n\nInput: k = 1\n\nOutput: 4\n\nExplanation:\n\nThe 4 possible ways of reaching stair 1 are:\n\n\n\tAlice starts at stair 1. Alice is at stair 1.\n\tAlice starts at stair 1.\n\t\n\t\tUsing an operation of the first type, she goes down 1 stair to reach stair 0.\n\t\tUsing an operation of the second type, she goes up 2⁰ stairs to reach stair 1.\n\t\n\t\n\tAlice starts at stair 1.\n\t\n\t\tUsing an operation of the second type, she goes up 2⁰ stairs to reach stair 2.\n\t\tUsing an operation of the first type, she goes down 1 stair to reach stair 1.\n\t\n\t\n\tAlice starts at stair 1.\n\t\n\t\tUsing an operation of the first type, she goes down 1 stair to reach stair 0.\n\t\tUsing an operation of the second type, she goes up 2⁰ stairs to reach stair 1.\n\t\tUsing an operation of the first type, she goes down 1 stair to reach stair 0.\n\t\tUsing an operation of the second type, she goes up 2¹ stairs to reach stair 2.\n\t\tUsing an operation of the first type, she goes down 1 stair to reach stair 1.\n\t\n\t\n\n\n\n \nConstraints:\n\n\n\t0 <= k <= 10⁹",
    "function_signature": "class Solution:\n    def waysToReachStair(self, k: int) -> int:\n        \n"
  },
  "3155": {
    "question_number": "3155",
    "question_title": "Maximum Number of Upgradable Servers is on the run...",
    "question_description": "You have n data centers and need to upgrade their servers.\n\nYou are given four arrays count, upgrade, sell, and money of length n, which show:\n\n\n\tThe number of servers\n\tThe cost of upgrading a single server\n\tThe money you get by selling a server\n\tThe money you initially have\n\n\nfor each data center respectively.\n\nReturn an array answer, where for each data center, the corresponding element in answer represents the maximum number of servers that can be upgraded.\n\nNote that the money from one data center cannot be used for another data center.\n\n \nExample 1:\n\n\nInput: count = [4,3], upgrade = [3,5], sell = [4,2], money = [8,9]\n\nOutput: [3,2]\n\nExplanation:\n\nFor the first data center, if we sell one server, we'll have 8 + 4 = 12 units of money and we can upgrade the remaining 3 servers.\n\nFor the second data center, if we sell one server, we'll have 9 + 2 = 11 units of money and we can upgrade the remaining 2 servers.\n\n\nExample 2:\n\n\nInput: count = [1], upgrade = [2], sell = [1], money = [1]\n\nOutput: [0]\n\n\n \nConstraints:\n\n\n\t1 <= count.length == upgrade.length == sell.length == money.length <= 10⁵\n\t1 <= count[i], upgrade[i], sell[i], money[i] <= 10⁵",
    "function_signature": "class Solution:\n    def maxUpgrades(self, count: List[int], upgrade: List[int], sell: List[int], money: List[int]) -> List[int]:\n        \n"
  },
  "3157": {
    "question_number": "3157",
    "question_title": "Find the Level of Tree with Minimum Sum is on the run...",
    "question_description": "Given the root of a binary tree root where each node has a value, return the level of the tree that has the minimum sum of values among all the levels (in case of a tie, return the lowest level).\n\nNote that the root of the tree is at level 1 and the level of any other node is its distance from the root + 1.\n\n \nExample 1:\n\n\nInput: root = [50,6,2,30,80,7]\n\nOutput: 2\n\nExplanation:\n\n\n\n\nExample 2:\n\n\nInput: root = [36,17,10,null,null,24]\n\nOutput: 3\n\nExplanation:\n\n\n\n\nExample 3:\n\n\nInput: root = [5,null,5,null,5]\n\nOutput: 1\n\nExplanation:\n\n\n\n\n \nConstraints:\n\n\n\tThe number of nodes in the tree is in the range [1, 10⁵].\n\t1 <= Node.val <= 10⁹",
    "function_signature": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minimumLevel(self, root: Optional[TreeNode]) -> int:\n        \n"
  },
  "3158": {
    "question_number": "3158",
    "question_title": "Find the XOR of Numbers Which Appear Twice is on the run...",
    "question_description": "You are given an array nums, where each number in the array appears either once or twice.\n\nReturn the bitwise XOR of all the numbers that appear twice in the array, or 0 if no number appears twice.\n\n \nExample 1:\n\n\nInput: nums = [1,2,1,3]\n\nOutput: 1\n\nExplanation:\n\nThe only number that appears twice in nums is 1.\n\n\nExample 2:\n\n\nInput: nums = [1,2,3]\n\nOutput: 0\n\nExplanation:\n\nNo number appears twice in nums.\n\n\nExample 3:\n\n\nInput: nums = [1,2,2,1]\n\nOutput: 3\n\nExplanation:\n\nNumbers 1 and 2 appeared twice. 1 XOR 2 == 3.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 50\n\t1 <= nums[i] <= 50\n\tEach number in nums appears either once or twice.",
    "function_signature": "class Solution:\n    def duplicateNumbersXOR(self, nums: List[int]) -> int:\n        \n"
  },
  "3159": {
    "question_number": "3159",
    "question_title": "Find Occurrences of an Element in an Array is on the run...",
    "question_description": "You are given an integer array nums, an integer array queries, and an integer x.\n\nFor each queries[i], you need to find the index of the queries[i]th occurrence of x in the nums array. If there are fewer than queries[i] occurrences of x, the answer should be -1 for that query.\n\nReturn an integer array answer containing the answers to all queries.\n\n \nExample 1:\n\n\nInput: nums = [1,3,1,7], queries = [1,3,2,4], x = 1\n\nOutput: [0,-1,2,-1]\n\nExplanation:\n\n\n\tFor the 1st query, the first occurrence of 1 is at index 0.\n\tFor the 2nd query, there are only two occurrences of 1 in nums, so the answer is -1.\n\tFor the 3rd query, the second occurrence of 1 is at index 2.\n\tFor the 4th query, there are only two occurrences of 1 in nums, so the answer is -1.\n\n\n\nExample 2:\n\n\nInput: nums = [1,2,3], queries = [10], x = 5\n\nOutput: [-1]\n\nExplanation:\n\n\n\tFor the 1st query, 5 doesn't exist in nums, so the answer is -1.\n\n\n\n \nConstraints:\n\n\n\t1 <= nums.length, queries.length <= 10⁵\n\t1 <= queries[i] <= 10⁵\n\t1 <= nums[i], x <= 10⁴",
    "function_signature": "class Solution:\n    def occurrencesOfElement(self, nums: List[int], queries: List[int], x: int) -> List[int]:\n        \n"
  },
  "3160": {
    "question_number": "3160",
    "question_title": "Find the Number of Distinct Colors Among the Balls is on the run...",
    "question_description": "You are given an integer limit and a 2D array queries of size n x 2.\n\nThere are limit + 1 balls with distinct labels in the range [0, limit]. Initially, all balls are uncolored. For every query in queries that is of the form [x, y], you mark ball x with the color y. After each query, you need to find the number of colors among the balls.\n\nReturn an array result of length n, where result[i] denotes the number of colors after ith query.\n\nNote that when answering a query, lack of a color will not be considered as a color.\n\n \nExample 1:\n\n\nInput: limit = 4, queries = [[1,4],[2,5],[1,3],[3,4]]\n\nOutput: [1,2,2,3]\n\nExplanation:\n\n\n\n\n\tAfter query 0, ball 1 has color 4.\n\tAfter query 1, ball 1 has color 4, and ball 2 has color 5.\n\tAfter query 2, ball 1 has color 3, and ball 2 has color 5.\n\tAfter query 3, ball 1 has color 3, ball 2 has color 5, and ball 3 has color 4.\n\n\n\nExample 2:\n\n\nInput: limit = 4, queries = [[0,1],[1,2],[2,2],[3,4],[4,5]]\n\nOutput: [1,2,2,3,4]\n\nExplanation:\n\n\n\n\n\tAfter query 0, ball 0 has color 1.\n\tAfter query 1, ball 0 has color 1, and ball 1 has color 2.\n\tAfter query 2, ball 0 has color 1, and balls 1 and 2 have color 2.\n\tAfter query 3, ball 0 has color 1, balls 1 and 2 have color 2, and ball 3 has color 4.\n\tAfter query 4, ball 0 has color 1, balls 1 and 2 have color 2, ball 3 has color 4, and ball 4 has color 5.\n\n\n\n \nConstraints:\n\n\n\t1 <= limit <= 10⁹\n\t1 <= n == queries.length <= 10⁵\n\tqueries[i].length == 2\n\t0 <= queries[i][0] <= limit\n\t1 <= queries[i][1] <= 10⁹",
    "function_signature": "class Solution:\n    def queryResults(self, limit: int, queries: List[List[int]]) -> List[int]:\n        \n"
  },
  "3161": {
    "question_number": "3161",
    "question_title": "Block Placement Queries is on the run...",
    "question_description": "There exists an infinite number line, with its origin at 0 and extending towards the positive x-axis.\n\nYou are given a 2D array queries, which contains two types of queries:\n\n\n\tFor a query of type 1, queries[i] = [1, x]. Build an obstacle at distance x from the origin. It is guaranteed that there is no obstacle at distance x when the query is asked.\n\tFor a query of type 2, queries[i] = [2, x, sz]. Check if it is possible to place a block of size sz anywhere in the range [0, x] on the line, such that the block entirely lies in the range [0, x]. A block cannot be placed if it intersects with any obstacle, but it may touch it. Note that you do not actually place the block. Queries are separate.\n\n\nReturn a boolean array results, where results[i] is true if you can place the block specified in the ith query of type 2, and false otherwise.\n\n \nExample 1:\n\n\nInput: queries = [[1,2],[2,3,3],[2,3,1],[2,2,2]]\n\nOutput: [false,true,true]\n\nExplanation:\n\n\n\nFor query 0, place an obstacle at x = 2. A block of size at most 2 can be placed before x = 3.\n\n\nExample 2:\n\n\nInput: queries = [[1,7],[2,7,6],[1,2],[2,7,5],[2,7,6]]\n\nOutput: [true,true,false]\n\nExplanation:\n\n\n\n\n\tPlace an obstacle at x = 7 for query 0. A block of size at most 7 can be placed before x = 7.\n\tPlace an obstacle at x = 2 for query 2. Now, a block of size at most 5 can be placed before x = 7, and a block of size at most 2 before x = 2.\n\n\n\n \nConstraints:\n\n\n\t1 <= queries.length <= 15 * 10⁴\n\t2 <= queries[i].length <= 3\n\t1 <= queries[i][0] <= 2\n\t1 <= x, sz <= min(5 * 10⁴, 3 * queries.length)\n\tThe input is generated such that for queries of type 1, no obstacle exists at distance x when the query is asked.\n\tThe input is generated such that there is at least one query of type 2.",
    "function_signature": "class Solution:\n    def getResults(self, queries: List[List[int]]) -> List[bool]:\n        \n"
  },
  "3162": {
    "question_number": "3162",
    "question_title": "Find the Number of Good Pairs I is on the run...",
    "question_description": "You are given 2 integer arrays nums1 and nums2 of lengths n and m respectively. You are also given a positive integer k.\n\nA pair (i, j) is called good if nums1[i] is divisible by nums2[j] * k (0 <= i <= n - 1, 0 <= j <= m - 1).\n\nReturn the total number of good pairs.\n\n \nExample 1:\n\n\nInput: nums1 = [1,3,4], nums2 = [1,3,4], k = 1\n\nOutput: 5\n\nExplanation:\nThe 5 good pairs are (0, 0), (1, 0), (1, 1), (2, 0), and (2, 2).\n\nExample 2:\n\n\nInput: nums1 = [1,2,4,12], nums2 = [2,4], k = 3\n\nOutput: 2\n\nExplanation:\n\nThe 2 good pairs are (3, 0) and (3, 1).\n\n\n \nConstraints:\n\n\n\t1 <= n, m <= 50\n\t1 <= nums1[i], nums2[j] <= 50\n\t1 <= k <= 50",
    "function_signature": "class Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        \n"
  },
  "3163": {
    "question_number": "3163",
    "question_title": "String Compression III is on the run...",
    "question_description": "Given a string word, compress it using the following algorithm:\n\n\n\tBegin with an empty string comp. While word is not empty, use the following operation:\n\n\t\n\t\tRemove a maximum length prefix of word made of a single character c repeating at most 9 times.\n\t\tAppend the length of the prefix followed by c to comp.\n\t\n\t\n\n\nReturn the string comp.\n\n \nExample 1:\n\n\nInput: word = \"abcde\"\n\nOutput: \"1a1b1c1d1e\"\n\nExplanation:\n\nInitially, comp = \"\". Apply the operation 5 times, choosing \"a\", \"b\", \"c\", \"d\", and \"e\" as the prefix in each operation.\n\nFor each prefix, append \"1\" followed by the character to comp.\n\n\nExample 2:\n\n\nInput: word = \"aaaaaaaaaaaaaabb\"\n\nOutput: \"9a5a2b\"\n\nExplanation:\n\nInitially, comp = \"\". Apply the operation 3 times, choosing \"aaaaaaaaa\", \"aaaaa\", and \"bb\" as the prefix in each operation.\n\n\n\tFor prefix \"aaaaaaaaa\", append \"9\" followed by \"a\" to comp.\n\tFor prefix \"aaaaa\", append \"5\" followed by \"a\" to comp.\n\tFor prefix \"bb\", append \"2\" followed by \"b\" to comp.\n\n\n\n \nConstraints:\n\n\n\t1 <= word.length <= 2 * 10⁵\n\tword consists only of lowercase English letters.",
    "function_signature": "class Solution:\n    def compressedString(self, word: str) -> str:\n        \n"
  },
  "3164": {
    "question_number": "3164",
    "question_title": "Find the Number of Good Pairs II is on the run...",
    "question_description": "You are given 2 integer arrays nums1 and nums2 of lengths n and m respectively. You are also given a positive integer k.\n\nA pair (i, j) is called good if nums1[i] is divisible by nums2[j] * k (0 <= i <= n - 1, 0 <= j <= m - 1).\n\nReturn the total number of good pairs.\n\n \nExample 1:\n\n\nInput: nums1 = [1,3,4], nums2 = [1,3,4], k = 1\n\nOutput: 5\n\nExplanation:\nThe 5 good pairs are (0, 0), (1, 0), (1, 1), (2, 0), and (2, 2).\n\nExample 2:\n\n\nInput: nums1 = [1,2,4,12], nums2 = [2,4], k = 3\n\nOutput: 2\n\nExplanation:\n\nThe 2 good pairs are (3, 0) and (3, 1).\n\n\n \nConstraints:\n\n\n\t1 <= n, m <= 10⁵\n\t1 <= nums1[i], nums2[j] <= 10⁶\n\t1 <= k <= 10³",
    "function_signature": "class Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        \n"
  },
  "3165": {
    "question_number": "3165",
    "question_title": "Maximum Sum of Subsequence With Non-adjacent Elements is on the run...",
    "question_description": "You are given an array nums consisting of integers. You are also given a 2D array queries, where queries[i] = [posi, xi].\n\nFor query i, we first set nums[posi] equal to xi, then we calculate the answer to query i which is the maximum sum of a subsequence of nums where no two adjacent elements are selected.\n\nReturn the sum of the answers to all queries.\n\nSince the final answer may be very large, return it modulo 10⁹ + 7.\n\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n\n \nExample 1:\n\n\nInput: nums = [3,5,9], queries = [[1,-2],[0,-3]]\n\nOutput: 21\n\nExplanation:\nAfter the 1st query, nums = [3,-2,9] and the maximum sum of a subsequence with non-adjacent elements is 3 + 9 = 12.\nAfter the 2nd query, nums = [-3,-2,9] and the maximum sum of a subsequence with non-adjacent elements is 9.\n\n\nExample 2:\n\n\nInput: nums = [0,-1], queries = [[0,-5]]\n\nOutput: 0\n\nExplanation:\nAfter the 1st query, nums = [-5,-1] and the maximum sum of a subsequence with non-adjacent elements is 0 (choosing an empty subsequence).\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 5 * 10⁴\n\t-10⁵ <= nums[i] <= 10⁵\n\t1 <= queries.length <= 5 * 10⁴\n\tqueries[i] == [posi, xi]\n\t0 <= posi <= nums.length - 1\n\t-10⁵ <= xi <= 10⁵",
    "function_signature": "class Solution:\n    def maximumSumSubsequence(self, nums: List[int], queries: List[List[int]]) -> int:\n        \n"
  },
  "3167": {
    "question_number": "3167",
    "question_title": "Better Compression of String is on the run...",
    "question_description": "You are given a string compressed representing a compressed version of a string. The format is a character followed by its frequency. For example, \"a3b1a1c2\" is a compressed version of the string \"aaabacc\".\n\nWe seek a better compression with the following conditions:\n\n\n\tEach character should appear only once in the compressed version.\n\tThe characters should be in alphabetical order.\n\n\nReturn the better compression of compressed.\n\nNote: In the better version of compression, the order of letters may change, which is acceptable.\n\n \nExample 1:\n\n\nInput: compressed = \"a3c9b2c1\"\n\nOutput: \"a3b2c10\"\n\nExplanation:\n\nCharacters \"a\" and \"b\" appear only once in the input, but \"c\" appears twice, once with a size of 9 and once with a size of 1.\n\nHence, in the resulting string, it should have a size of 10.\n\n\nExample 2:\n\n\nInput: compressed = \"c2b3a1\"\n\nOutput: \"a1b3c2\"\n\n\nExample 3:\n\n\nInput: compressed = \"a2b4c1\"\n\nOutput: \"a2b4c1\"\n\n\n \nConstraints:\n\n\n\t1 <= compressed.length <= 6 * 10⁴\n\tcompressed consists only of lowercase English letters and digits.\n\tcompressed is a valid compression, i.e., each character is followed by its frequency.\n\tFrequencies are in the range [1, 10⁴] and have no leading zeroes.",
    "function_signature": "class Solution:\n    def betterCompression(self, compressed: str) -> str:\n        \n"
  },
  "3168": {
    "question_number": "3168",
    "question_title": "Minimum Number of Chairs in a Waiting Room is on the run...",
    "question_description": "You are given a string s. Simulate events at each second i:\n\n\n\tIf s[i] == 'E', a person enters the waiting room and takes one of the chairs in it.\n\tIf s[i] == 'L', a person leaves the waiting room, freeing up a chair.\n\n\nReturn the minimum number of chairs needed so that a chair is available for every person who enters the waiting room given that it is initially empty.\n\n \nExample 1:\n\n\nInput: s = \"EEEEEEE\"\n\nOutput: 7\n\nExplanation:\n\nAfter each second, a person enters the waiting room and no person leaves it. Therefore, a minimum of 7 chairs is needed.\n\n\nExample 2:\n\n\nInput: s = \"ELELEEL\"\n\nOutput: 2\n\nExplanation:\n\nLet's consider that there are 2 chairs in the waiting room. The table below shows the state of the waiting room at each second.\n\n\n\n\t\n\t\t\n\t\t\tSecond\n\t\t\tEvent\n\t\t\tPeople in the Waiting Room\n\t\t\tAvailable Chairs\n\t\t\n\t\t\n\t\t\t0\n\t\t\tEnter\n\t\t\t1\n\t\t\t1\n\t\t\n\t\t\n\t\t\t1\n\t\t\tLeave\n\t\t\t0\n\t\t\t2\n\t\t\n\t\t\n\t\t\t2\n\t\t\tEnter\n\t\t\t1\n\t\t\t1\n\t\t\n\t\t\n\t\t\t3\n\t\t\tLeave\n\t\t\t0\n\t\t\t2\n\t\t\n\t\t\n\t\t\t4\n\t\t\tEnter\n\t\t\t1\n\t\t\t1\n\t\t\n\t\t\n\t\t\t5\n\t\t\tEnter\n\t\t\t2\n\t\t\t0\n\t\t\n\t\t\n\t\t\t6\n\t\t\tLeave\n\t\t\t1\n\t\t\t1\n\t\t\n\t\n\n\nExample 3:\n\n\nInput: s = \"ELEELEELLL\"\n\nOutput: 3\n\nExplanation:\n\nLet's consider that there are 3 chairs in the waiting room. The table below shows the state of the waiting room at each second.\n\n\n\n\t\n\t\t\n\t\t\tSecond\n\t\t\tEvent\n\t\t\tPeople in the Waiting Room\n\t\t\tAvailable Chairs\n\t\t\n\t\t\n\t\t\t0\n\t\t\tEnter\n\t\t\t1\n\t\t\t2\n\t\t\n\t\t\n\t\t\t1\n\t\t\tLeave\n\t\t\t0\n\t\t\t3\n\t\t\n\t\t\n\t\t\t2\n\t\t\tEnter\n\t\t\t1\n\t\t\t2\n\t\t\n\t\t\n\t\t\t3\n\t\t\tEnter\n\t\t\t2\n\t\t\t1\n\t\t\n\t\t\n\t\t\t4\n\t\t\tLeave\n\t\t\t1\n\t\t\t2\n\t\t\n\t\t\n\t\t\t5\n\t\t\tEnter\n\t\t\t2\n\t\t\t1\n\t\t\n\t\t\n\t\t\t6\n\t\t\tEnter\n\t\t\t3\n\t\t\t0\n\t\t\n\t\t\n\t\t\t7\n\t\t\tLeave\n\t\t\t2\n\t\t\t1\n\t\t\n\t\t\n\t\t\t8\n\t\t\tLeave\n\t\t\t1\n\t\t\t2\n\t\t\n\t\t\n\t\t\t9\n\t\t\tLeave\n\t\t\t0\n\t\t\t3\n\t\t\n\t\n\n\n \nConstraints:\n\n\n\t1 <= s.length <= 50\n\ts consists only of the letters 'E' and 'L'.\n\ts represents a valid sequence of entries and exits.",
    "function_signature": "class Solution:\n    def minimumChairs(self, s: str) -> int:\n        \n"
  },
  "3169": {
    "question_number": "3169",
    "question_title": "Count Days Without Meetings is on the run...",
    "question_description": "You are given a positive integer days representing the total number of days an employee is available for work (starting from day 1). You are also given a 2D array meetings of size n where, meetings[i] = [start_i, end_i] represents the starting and ending days of meeting i (inclusive).\n\nReturn the count of days when the employee is available for work but no meetings are scheduled.\n\nNote: The meetings may overlap.\n\n \nExample 1:\n\n\nInput: days = 10, meetings = [[5,7],[1,3],[9,10]]\n\nOutput: 2\n\nExplanation:\n\nThere is no meeting scheduled on the 4th and 8th days.\n\n\nExample 2:\n\n\nInput: days = 5, meetings = [[2,4],[1,3]]\n\nOutput: 1\n\nExplanation:\n\nThere is no meeting scheduled on the 5th day.\n\n\nExample 3:\n\n\nInput: days = 6, meetings = [[1,6]]\n\nOutput: 0\n\nExplanation:\n\nMeetings are scheduled for all working days.\n\n\n \nConstraints:\n\n\n\t1 <= days <= 10⁹\n\t1 <= meetings.length <= 10⁵\n\tmeetings[i].length == 2\n\t1 <= meetings[i][0] <= meetings[i][1] <= days",
    "function_signature": "class Solution:\n    def countDays(self, days: int, meetings: List[List[int]]) -> int:\n        \n"
  },
  "3170": {
    "question_number": "3170",
    "question_title": "Lexicographically Minimum String After Removing Stars is on the run...",
    "question_description": "You are given a string s. It may contain any number of '*' characters. Your task is to remove all '*' characters.\n\nWhile there is a '*', do the following operation:\n\n\n\tDelete the leftmost '*' and the smallest non-'*' character to its left. If there are several smallest characters, you can delete any of them.\n\n\nReturn the lexicographically smallest resulting string after removing all '*' characters.\n\n \nExample 1:\n\n\nInput: s = \"aaba*\"\n\nOutput: \"aab\"\n\nExplanation:\n\nWe should delete one of the 'a' characters with '*'. If we choose s[3], s becomes the lexicographically smallest.\n\n\nExample 2:\n\n\nInput: s = \"abc\"\n\nOutput: \"abc\"\n\nExplanation:\n\nThere is no '*' in the string.\n\n\n \nConstraints:\n\n\n\t1 <= s.length <= 10⁵\n\ts consists only of lowercase English letters and '*'.\n\tThe input is generated such that it is possible to delete all '*' characters.",
    "function_signature": "class Solution:\n    def clearStars(self, s: str) -> str:\n        \n"
  },
  "3171": {
    "question_number": "3171",
    "question_title": "Find Subarray With Bitwise OR Closest to K is on the run...",
    "question_description": "You are given an array nums and an integer k. You need to find a subarray of nums such that the absolute difference between k and the bitwise OR of the subarray elements is as small as possible. In other words, select a subarray nums[l..r] such that |k - (nums[l] OR nums[l + 1] ... OR nums[r])| is minimum.\n\nReturn the minimum possible value of the absolute difference.\n\nA subarray is a contiguous non-empty sequence of elements within an array.\n\n \nExample 1:\n\n\nInput: nums = [1,2,4,5], k = 3\n\nOutput: 0\n\nExplanation:\n\nThe subarray nums[0..1] has OR value 3, which gives the minimum absolute difference |3 - 3| = 0.\n\n\nExample 2:\n\n\nInput: nums = [1,3,1,3], k = 2\n\nOutput: 1\n\nExplanation:\n\nThe subarray nums[1..1] has OR value 3, which gives the minimum absolute difference |3 - 2| = 1.\n\n\nExample 3:\n\n\nInput: nums = [1], k = 10\n\nOutput: 9\n\nExplanation:\n\nThere is a single subarray with OR value 1, which gives the minimum absolute difference |10 - 1| = 9.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 10⁵\n\t1 <= nums[i] <= 10⁹\n\t1 <= k <= 10⁹",
    "function_signature": "class Solution:\n    def minimumDifference(self, nums: List[int], k: int) -> int:\n        \n"
  },
  "3173": {
    "question_number": "3173",
    "question_title": "Bitwise OR of Adjacent Elements is on the run...",
    "question_description": "Given an array nums of length n, return an array answer of length n - 1 such that answer[i] = nums[i] | nums[i + 1] where | is the bitwise OR operation.\n\n \nExample 1:\n\n\nInput: nums = [1,3,7,15]\n\nOutput: [3,7,15]\n\n\nExample 2:\n\n\nInput: nums = [8,4,2]\n\nOutput: [12,6]\n\n\nExample 3:\n\n\nInput: nums = [5,4,9,11]\n\nOutput: [5,13,11]\n\n\n \nConstraints:\n\n\n\t2 <= nums.length <= 100\n\t0 <= nums[i] <= 100",
    "function_signature": "class Solution:\n    def orArray(self, nums: List[int]) -> List[int]:\n        \n"
  },
  "3174": {
    "question_number": "3174",
    "question_title": "Clear Digits is on the run...",
    "question_description": "You are given a string s.\n\nYour task is to remove all digits by doing this operation repeatedly:\n\n\n\tDelete the first digit and the closest non-digit character to its left.\n\n\nReturn the resulting string after removing all digits.\n\nNote that the operation cannot be performed on a digit that does not have any non-digit character to its left.\n\n \nExample 1:\n\n\nInput: s = \"abc\"\n\nOutput: \"abc\"\n\nExplanation:\n\nThere is no digit in the string.\n\n\nExample 2:\n\n\nInput: s = \"cb34\"\n\nOutput: \"\"\n\nExplanation:\n\nFirst, we apply the operation on s[2], and s becomes \"c4\".\n\nThen we apply the operation on s[1], and s becomes \"\".\n\n\n \nConstraints:\n\n\n\t1 <= s.length <= 100\n\ts consists only of lowercase English letters and digits.\n\tThe input is generated such that it is possible to delete all digits.",
    "function_signature": "class Solution:\n    def clearDigits(self, s: str) -> str:\n        \n"
  },
  "3175": {
    "question_number": "3175",
    "question_title": "Find The First Player to win K Games in a Row is on the run...",
    "question_description": "A competition consists of n players numbered from 0 to n - 1.\n\nYou are given an integer array skills of size n and a positive integer k, where skills[i] is the skill level of player i. All integers in skills are unique.\n\nAll players are standing in a queue in order from player 0 to player n - 1.\n\nThe competition process is as follows:\n\n\n\tThe first two players in the queue play a game, and the player with the higher skill level wins.\n\tAfter the game, the winner stays at the beginning of the queue, and the loser goes to the end of it.\n\n\nThe winner of the competition is the first player who wins k games in a row.\n\nReturn the initial index of the winning player.\n\n \nExample 1:\n\n\nInput: skills = [4,2,6,3,9], k = 2\n\nOutput: 2\n\nExplanation:\n\nInitially, the queue of players is [0,1,2,3,4]. The following process happens:\n\n\n\tPlayers 0 and 1 play a game, since the skill of player 0 is higher than that of player 1, player 0 wins. The resulting queue is [0,2,3,4,1].\n\tPlayers 0 and 2 play a game, since the skill of player 2 is higher than that of player 0, player 2 wins. The resulting queue is [2,3,4,1,0].\n\tPlayers 2 and 3 play a game, since the skill of player 2 is higher than that of player 3, player 2 wins. The resulting queue is [2,4,1,0,3].\n\n\nPlayer 2 won k = 2 games in a row, so the winner is player 2.\n\n\nExample 2:\n\n\nInput: skills = [2,5,4], k = 3\n\nOutput: 1\n\nExplanation:\n\nInitially, the queue of players is [0,1,2]. The following process happens:\n\n\n\tPlayers 0 and 1 play a game, since the skill of player 1 is higher than that of player 0, player 1 wins. The resulting queue is [1,2,0].\n\tPlayers 1 and 2 play a game, since the skill of player 1 is higher than that of player 2, player 1 wins. The resulting queue is [1,0,2].\n\tPlayers 1 and 0 play a game, since the skill of player 1 is higher than that of player 0, player 1 wins. The resulting queue is [1,2,0].\n\n\nPlayer 1 won k = 3 games in a row, so the winner is player 1.\n\n\n \nConstraints:\n\n\n\tn == skills.length\n\t2 <= n <= 10⁵\n\t1 <= k <= 10⁹\n\t1 <= skills[i] <= 10⁶\n\tAll integers in skills are unique.",
    "function_signature": "class Solution:\n    def findWinningPlayer(self, skills: List[int], k: int) -> int:\n        \n"
  },
  "3176": {
    "question_number": "3176",
    "question_title": "Find the Maximum Length of a Good Subsequence I is on the run...",
    "question_description": "You are given an integer array nums and a non-negative integer k. A sequence of integers seq is called good if there are at most k indices i in the range [0, seq.length - 2] such that seq[i] != seq[i + 1].\n\nReturn the maximum possible length of a good subsequence of nums.\n\n \nExample 1:\n\n\nInput: nums = [1,2,1,1,3], k = 2\n\nOutput: 4\n\nExplanation:\n\nThe maximum length subsequence is [1,2,1,1,3].\n\n\nExample 2:\n\n\nInput: nums = [1,2,3,4,5,1], k = 0\n\nOutput: 2\n\nExplanation:\n\nThe maximum length subsequence is [1,2,3,4,5,1].\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 500\n\t1 <= nums[i] <= 10⁹\n\t0 <= k <= min(nums.length, 25)",
    "function_signature": "class Solution:\n    def maximumLength(self, nums: List[int], k: int) -> int:\n        \n"
  },
  "3177": {
    "question_number": "3177",
    "question_title": "Find the Maximum Length of a Good Subsequence II is on the run...",
    "question_description": "You are given an integer array nums and a non-negative integer k. A sequence of integers seq is called good if there are at most k indices i in the range [0, seq.length - 2] such that seq[i] != seq[i + 1].\n\nReturn the maximum possible length of a good subsequence of nums.\n\n \nExample 1:\n\n\nInput: nums = [1,2,1,1,3], k = 2\n\nOutput: 4\n\nExplanation:\n\nThe maximum length subsequence is [1,2,1,1,3].\n\n\nExample 2:\n\n\nInput: nums = [1,2,3,4,5,1], k = 0\n\nOutput: 2\n\nExplanation:\n\nThe maximum length subsequence is [1,2,3,4,5,1].\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 5 * 10³\n\t1 <= nums[i] <= 10⁹\n\t0 <= k <= min(50, nums.length)",
    "function_signature": "class Solution:\n    def maximumLength(self, nums: List[int], k: int) -> int:\n        \n"
  },
  "3178": {
    "question_number": "3178",
    "question_title": "Find the Child Who Has the Ball After K Seconds is on the run...",
    "question_description": "You are given two positive integers n and k. There are n children numbered from 0 to n - 1 standing in a queue in order from left to right.\n\nInitially, child 0 holds a ball and the direction of passing the ball is towards the right direction. After each second, the child holding the ball passes it to the child next to them. Once the ball reaches either end of the line, i.e. child 0 or child n - 1, the direction of passing is reversed.\n\nReturn the number of the child who receives the ball after k seconds.\n\n \nExample 1:\n\n\nInput: n = 3, k = 5\n\nOutput: 1\n\nExplanation:\n\n\n\t\n\t\t\n\t\t\tTime elapsed\n\t\t\tChildren\n\t\t\n\t\t\n\t\t\t0\n\t\t\t[0, 1, 2]\n\t\t\n\t\t\n\t\t\t1\n\t\t\t[0, 1, 2]\n\t\t\n\t\t\n\t\t\t2\n\t\t\t[0, 1, 2]\n\t\t\n\t\t\n\t\t\t3\n\t\t\t[0, 1, 2]\n\t\t\n\t\t\n\t\t\t4\n\t\t\t[0, 1, 2]\n\t\t\n\t\t\n\t\t\t5\n\t\t\t[0, 1, 2]\n\t\t\n\t\n\n\n\nExample 2:\n\n\nInput: n = 5, k = 6\n\nOutput: 2\n\nExplanation:\n\n\n\t\n\t\t\n\t\t\tTime elapsed\n\t\t\tChildren\n\t\t\n\t\t\n\t\t\t0\n\t\t\t[0, 1, 2, 3, 4]\n\t\t\n\t\t\n\t\t\t1\n\t\t\t[0, 1, 2, 3, 4]\n\t\t\n\t\t\n\t\t\t2\n\t\t\t[0, 1, 2, 3, 4]\n\t\t\n\t\t\n\t\t\t3\n\t\t\t[0, 1, 2, 3, 4]\n\t\t\n\t\t\n\t\t\t4\n\t\t\t[0, 1, 2, 3, 4]\n\t\t\n\t\t\n\t\t\t5\n\t\t\t[0, 1, 2, 3, 4]\n\t\t\n\t\t\n\t\t\t6\n\t\t\t[0, 1, 2, 3, 4]\n\t\t\n\t\n\n\n\nExample 3:\n\n\nInput: n = 4, k = 2\n\nOutput: 2\n\nExplanation:\n\n\n\t\n\t\t\n\t\t\tTime elapsed\n\t\t\tChildren\n\t\t\n\t\t\n\t\t\t0\n\t\t\t[0, 1, 2, 3]\n\t\t\n\t\t\n\t\t\t1\n\t\t\t[0, 1, 2, 3]\n\t\t\n\t\t\n\t\t\t2\n\t\t\t[0, 1, 2, 3]\n\t\t\n\t\n\n\n\n \nConstraints:\n\n\n\t2 <= n <= 50\n\t1 <= k <= 50\n\n\n \nNote: This question is the same as  2582: Pass the Pillow.",
    "function_signature": "class Solution:\n    def numberOfChild(self, n: int, k: int) -> int:\n        \n"
  },
  "3179": {
    "question_number": "3179",
    "question_title": "Find the N-th Value After K Seconds is on the run...",
    "question_description": "You are given two integers n and k.\n\nInitially, you start with an array a of n integers where a[i] = 1 for all 0 <= i <= n - 1. After each second, you simultaneously update each element to be the sum of all its preceding elements plus the element itself. For example, after one second, a[0] remains the same, a[1] becomes a[0] + a[1], a[2] becomes a[0] + a[1] + a[2], and so on.\n\nReturn the value of a[n - 1] after k seconds.\n\nSince the answer may be very large, return it modulo 10⁹ + 7.\n\n \nExample 1:\n\n\nInput: n = 4, k = 5\n\nOutput: 56\n\nExplanation:\n\n\n\t\n\t\t\n\t\t\tSecond\n\t\t\tState After\n\t\t\n\t\t\n\t\t\t0\n\t\t\t[1,1,1,1]\n\t\t\n\t\t\n\t\t\t1\n\t\t\t[1,2,3,4]\n\t\t\n\t\t\n\t\t\t2\n\t\t\t[1,3,6,10]\n\t\t\n\t\t\n\t\t\t3\n\t\t\t[1,4,10,20]\n\t\t\n\t\t\n\t\t\t4\n\t\t\t[1,5,15,35]\n\t\t\n\t\t\n\t\t\t5\n\t\t\t[1,6,21,56]\n\t\t\n\t\n\n\n\nExample 2:\n\n\nInput: n = 5, k = 3\n\nOutput: 35\n\nExplanation:\n\n\n\t\n\t\t\n\t\t\tSecond\n\t\t\tState After\n\t\t\n\t\t\n\t\t\t0\n\t\t\t[1,1,1,1,1]\n\t\t\n\t\t\n\t\t\t1\n\t\t\t[1,2,3,4,5]\n\t\t\n\t\t\n\t\t\t2\n\t\t\t[1,3,6,10,15]\n\t\t\n\t\t\n\t\t\t3\n\t\t\t[1,4,10,20,35]\n\t\t\n\t\n\n\n\n \nConstraints:\n\n\n\t1 <= n, k <= 1000",
    "function_signature": "class Solution:\n    def valueAfterKSeconds(self, n: int, k: int) -> int:\n        \n"
  },
  "3180": {
    "question_number": "3180",
    "question_title": "Maximum Total Reward Using Operations I is on the run...",
    "question_description": "You are given an integer array rewardValues of length n, representing the values of rewards.\n\nInitially, your total reward x is 0, and all indices are unmarked. You are allowed to perform the following operation any number of times:\n\n\n\tChoose an unmarked index i from the range [0, n - 1].\n\tIf rewardValues[i] is greater than your current total reward x, then add rewardValues[i] to x (i.e., x = x + rewardValues[i]), and mark the index i.\n\n\nReturn an integer denoting the maximum total reward you can collect by performing the operations optimally.\n\n \nExample 1:\n\n\nInput: rewardValues = [1,1,3,3]\n\nOutput: 4\n\nExplanation:\n\nDuring the operations, we can choose to mark the indices 0 and 2 in order, and the total reward will be 4, which is the maximum.\n\n\nExample 2:\n\n\nInput: rewardValues = [1,6,4,3,2]\n\nOutput: 11\n\nExplanation:\n\nMark the indices 0, 2, and 1 in order. The total reward will then be 11, which is the maximum.\n\n\n \nConstraints:\n\n\n\t1 <= rewardValues.length <= 2000\n\t1 <= rewardValues[i] <= 2000",
    "function_signature": "class Solution:\n    def maxTotalReward(self, rewardValues: List[int]) -> int:\n        \n"
  },
  "3181": {
    "question_number": "3181",
    "question_title": "Maximum Total Reward Using Operations II is on the run...",
    "question_description": "You are given an integer array rewardValues of length n, representing the values of rewards.\n\nInitially, your total reward x is 0, and all indices are unmarked. You are allowed to perform the following operation any number of times:\n\n\n\tChoose an unmarked index i from the range [0, n - 1].\n\tIf rewardValues[i] is greater than your current total reward x, then add rewardValues[i] to x (i.e., x = x + rewardValues[i]), and mark the index i.\n\n\nReturn an integer denoting the maximum total reward you can collect by performing the operations optimally.\n\n \nExample 1:\n\n\nInput: rewardValues = [1,1,3,3]\n\nOutput: 4\n\nExplanation:\n\nDuring the operations, we can choose to mark the indices 0 and 2 in order, and the total reward will be 4, which is the maximum.\n\n\nExample 2:\n\n\nInput: rewardValues = [1,6,4,3,2]\n\nOutput: 11\n\nExplanation:\n\nMark the indices 0, 2, and 1 in order. The total reward will then be 11, which is the maximum.\n\n\n \nConstraints:\n\n\n\t1 <= rewardValues.length <= 5 * 10⁴\n\t1 <= rewardValues[i] <= 5 * 10⁴",
    "function_signature": "class Solution:\n    def maxTotalReward(self, rewardValues: List[int]) -> int:\n        \n"
  },
  "3183": {
    "question_number": "3183",
    "question_title": "The Number of Ways to Make the Sum is on the run...",
    "question_description": "You have an infinite number of coins with values 1, 2, and 6, and only 2 coins with value 4.\n\nGiven an integer n, return the number of ways to make the sum of n with the coins you have.\n\nSince the answer may be very large, return it modulo 10⁹ + 7.\n\nNote that the order of the coins doesn't matter and [2, 2, 3] is the same as [2, 3, 2].\n\n \nExample 1:\n\n\nInput: n = 4\n\nOutput: 4\n\nExplanation:\n\nHere are the four combinations: [1, 1, 1, 1], [1, 1, 2], [2, 2], [4].\n\n\nExample 2:\n\n\nInput: n = 12\n\nOutput: 22\n\nExplanation:\n\nNote that [4, 4, 4] is not a valid combination since we cannot use 4 three times.\n\n\nExample 3:\n\n\nInput: n = 5\n\nOutput: 4\n\nExplanation:\n\nHere are the four combinations: [1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 2, 2], [1, 4].\n\n\n \nConstraints:\n\n\n\t1 <= n <= 10⁵",
    "function_signature": "class Solution:\n    def numberOfWays(self, n: int) -> int:\n        \n"
  },
  "3184": {
    "question_number": "3184",
    "question_title": "Count Pairs That Form a Complete Day I is on the run...",
    "question_description": "Given an integer array hours representing times in hours, return an integer denoting the number of pairs i, j where i < j and hours[i] + hours[j] forms a complete day.\n\nA complete day is defined as a time duration that is an exact multiple of 24 hours.\n\nFor example, 1 day is 24 hours, 2 days is 48 hours, 3 days is 72 hours, and so on.\n\n \nExample 1:\n\n\nInput: hours = [12,12,30,24,24]\n\nOutput: 2\n\nExplanation:\n\nThe pairs of indices that form a complete day are (0, 1) and (3, 4).\n\n\nExample 2:\n\n\nInput: hours = [72,48,24,3]\n\nOutput: 3\n\nExplanation:\n\nThe pairs of indices that form a complete day are (0, 1), (0, 2), and (1, 2).\n\n\n \nConstraints:\n\n\n\t1 <= hours.length <= 100\n\t1 <= hours[i] <= 10⁹",
    "function_signature": "class Solution:\n    def countCompleteDayPairs(self, hours: List[int]) -> int:\n        \n"
  },
  "3185": {
    "question_number": "3185",
    "question_title": "Count Pairs That Form a Complete Day II is on the run...",
    "question_description": "Given an integer array hours representing times in hours, return an integer denoting the number of pairs i, j where i < j and hours[i] + hours[j] forms a complete day.\n\nA complete day is defined as a time duration that is an exact multiple of 24 hours.\n\nFor example, 1 day is 24 hours, 2 days is 48 hours, 3 days is 72 hours, and so on.\n\n \nExample 1:\n\n\nInput: hours = [12,12,30,24,24]\n\nOutput: 2\n\nExplanation: The pairs of indices that form a complete day are (0, 1) and (3, 4).\n\n\nExample 2:\n\n\nInput: hours = [72,48,24,3]\n\nOutput: 3\n\nExplanation: The pairs of indices that form a complete day are (0, 1), (0, 2), and (1, 2).\n\n\n \nConstraints:\n\n\n\t1 <= hours.length <= 5 * 10⁵\n\t1 <= hours[i] <= 10⁹",
    "function_signature": "class Solution:\n    def countCompleteDayPairs(self, hours: List[int]) -> int:\n        \n"
  },
  "3186": {
    "question_number": "3186",
    "question_title": "Maximum Total Damage With Spell Casting is on the run...",
    "question_description": "A magician has various spells.\n\nYou are given an array power, where each element represents the damage of a spell. Multiple spells can have the same damage value.\n\nIt is a known fact that if a magician decides to cast a spell with a damage of power[i], they cannot cast any spell with a damage of power[i] - 2, power[i] - 1, power[i] + 1, or power[i] + 2.\n\nEach spell can be cast only once.\n\nReturn the maximum possible total damage that a magician can cast.\n\n \nExample 1:\n\n\nInput: power = [1,1,3,4]\n\nOutput: 6\n\nExplanation:\n\nThe maximum possible damage of 6 is produced by casting spells 0, 1, 3 with damage 1, 1, 4.\n\n\nExample 2:\n\n\nInput: power = [7,1,6,6]\n\nOutput: 13\n\nExplanation:\n\nThe maximum possible damage of 13 is produced by casting spells 1, 2, 3 with damage 1, 6, 6.\n\n\n \nConstraints:\n\n\n\t1 <= power.length <= 10⁵\n\t1 <= power[i] <= 10⁹",
    "function_signature": "class Solution:\n    def maximumTotalDamage(self, power: List[int]) -> int:\n        \n"
  },
  "3187": {
    "question_number": "3187",
    "question_title": "Peaks in Array is on the run...",
    "question_description": "A peak in an array arr is an element that is greater than its previous and next element in arr.\n\nYou are given an integer array nums and a 2D integer array queries.\n\nYou have to process queries of two types:\n\n\n\tqueries[i] = [1, li, ri], determine the count of peak elements in the subarray nums[li..ri].\n\tqueries[i] = [2, indexi, vali], change nums[indexi] to vali.\n\n\nReturn an array answer containing the results of the queries of the first type in order.\n\nNotes:\n\n\n\tThe first and the last element of an array or a subarray cannot be a peak.\n\n\n \nExample 1:\n\n\nInput: nums = [3,1,4,2,5], queries = [[2,3,4],[1,0,4]]\n\nOutput: [0]\n\nExplanation:\n\nFirst query: We change nums[3] to 4 and nums becomes [3,1,4,4,5].\n\nSecond query: The number of peaks in the [3,1,4,4,5] is 0.\n\n\nExample 2:\n\n\nInput: nums = [4,1,4,2,1,5], queries = [[2,2,4],[1,0,2],[1,0,4]]\n\nOutput: [0,1]\n\nExplanation:\n\nFirst query: nums[2] should become 4, but it is already set to 4.\n\nSecond query: The number of peaks in the [4,1,4] is 0.\n\nThird query: The second 4 is a peak in the [4,1,4,2,1].\n\n\n \nConstraints:\n\n\n\t3 <= nums.length <= 10⁵\n\t1 <= nums[i] <= 10⁵\n\t1 <= queries.length <= 10⁵\n\tqueries[i][0] == 1 or queries[i][0] == 2\n\tFor all i that:\n\t\n\t\tqueries[i][0] == 1: 0 <= queries[i][1] <= queries[i][2] <= nums.length - 1\n\t\tqueries[i][0] == 2: 0 <= queries[i][1] <= nums.length - 1, 1 <= queries[i][2] <= 10⁵",
    "function_signature": "class Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        \n"
  },
  "3189": {
    "question_number": "3189",
    "question_title": "Minimum Moves to Get a Peaceful Board is on the run...",
    "question_description": "Given a 2D array rooks of length n, where rooks[i] = [xi, yi] indicates the position of a rook on an n x n chess board. Your task is to move the rooks 1 cell at a time vertically or horizontally (to an adjacent cell) such that the board becomes peaceful.\n\nA board is peaceful if there is exactly one rook in each row and each column.\n\nReturn the minimum number of moves required to get a peaceful board.\n\nNote that at no point can there be two rooks in the same cell.\n\n \nExample 1:\n\n\nInput: rooks = [[0,0],[1,0],[1,1]]\n\nOutput: 3\n\nExplanation:\n\n\nExample 2:\n\n\nInput: rooks = [[0,0],[0,1],[0,2],[0,3]]\n\nOutput: 6\n\nExplanation:\n\n\n \nConstraints:\n\n\n\t1 <= n == rooks.length <= 500\n\t0 <= xi, yi <= n - 1\n\tThe input is generated such that there are no 2 rooks in the same cell.",
    "function_signature": "class Solution:\n    def minMoves(self, rooks: List[List[int]]) -> int:\n        \n"
  },
  "3190": {
    "question_number": "3190",
    "question_title": "Find Minimum Operations to Make All Elements Divisible by Three is on the run...",
    "question_description": "You are given an integer array nums. In one operation, you can add or subtract 1 from any element of nums.\n\nReturn the minimum number of operations to make all elements of nums divisible by 3.\n\n \nExample 1:\n\n\nInput: nums = [1,2,3,4]\n\nOutput: 3\n\nExplanation:\n\nAll array elements can be made divisible by 3 using 3 operations:\n\n\n\tSubtract 1 from 1.\n\tAdd 1 to 2.\n\tSubtract 1 from 4.\n\n\n\nExample 2:\n\n\nInput: nums = [3,6,9]\n\nOutput: 0\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 50\n\t1 <= nums[i] <= 50",
    "function_signature": "class Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        \n"
  },
  "3191": {
    "question_number": "3191",
    "question_title": "Minimum Operations to Make Binary Array Elements Equal to One I is on the run...",
    "question_description": "You are given a binary array nums.\n\nYou can do the following operation on the array any number of times (possibly zero):\n\n\n\tChoose any 3 consecutive elements from the array and flip all of them.\n\n\nFlipping an element means changing its value from 0 to 1, and from 1 to 0.\n\nReturn the minimum number of operations required to make all elements in nums equal to 1. If it is impossible, return -1.\n\n \nExample 1:\n\n\nInput: nums = [0,1,1,1,0,0]\n\nOutput: 3\n\nExplanation:\nWe can do the following operations:\n\n\n\tChoose the elements at indices 0, 1 and 2. The resulting array is nums = [1,0,0,1,0,0].\n\tChoose the elements at indices 1, 2 and 3. The resulting array is nums = [1,1,1,0,0,0].\n\tChoose the elements at indices 3, 4 and 5. The resulting array is nums = [1,1,1,1,1,1].\n\n\n\nExample 2:\n\n\nInput: nums = [0,1,1,1]\n\nOutput: -1\n\nExplanation:\nIt is impossible to make all elements equal to 1.\n\n\n \nConstraints:\n\n\n\t3 <= nums.length <= 10⁵\n\t0 <= nums[i] <= 1",
    "function_signature": "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n"
  },
  "3192": {
    "question_number": "3192",
    "question_title": "Minimum Operations to Make Binary Array Elements Equal to One II is on the run...",
    "question_description": "You are given a binary array nums.\n\nYou can do the following operation on the array any number of times (possibly zero):\n\n\n\tChoose any index i from the array and flip all the elements from index i to the end of the array.\n\n\nFlipping an element means changing its value from 0 to 1, and from 1 to 0.\n\nReturn the minimum number of operations required to make all elements in nums equal to 1.\n\n \nExample 1:\n\n\nInput: nums = [0,1,1,0,1]\n\nOutput: 4\n\nExplanation:\nWe can do the following operations:\n\n\n\tChoose the index i = 1. The resulting array will be nums = [0,0,0,1,0].\n\tChoose the index i = 0. The resulting array will be nums = [1,1,1,0,1].\n\tChoose the index i = 4. The resulting array will be nums = [1,1,1,0,0].\n\tChoose the index i = 3. The resulting array will be nums = [1,1,1,1,1].\n\n\n\nExample 2:\n\n\nInput: nums = [1,0,0,0]\n\nOutput: 1\n\nExplanation:\nWe can do the following operation:\n\n\n\tChoose the index i = 1. The resulting array will be nums = [1,1,1,1].\n\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 10⁵\n\t0 <= nums[i] <= 1",
    "function_signature": "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        \n"
  },
  "3193": {
    "question_number": "3193",
    "question_title": "Count the Number of Inversions is on the run...",
    "question_description": "You are given an integer n and a 2D array requirements, where requirements[i] = [endi, cnti] represents the end index and the inversion count of each requirement.\n\nA pair of indices (i, j) from an integer array nums is called an inversion if:\n\n\n\ti < j and nums[i] > nums[j]\n\n\nReturn the number of permutations perm of [0, 1, 2, ..., n - 1] such that for all requirements[i], perm[0..endi] has exactly cnti inversions.\n\nSince the answer may be very large, return it modulo 10⁹ + 7.\n\n \nExample 1:\n\n\nInput: n = 3, requirements = [[2,2],[0,0]]\n\nOutput: 2\n\nExplanation:\n\nThe two permutations are:\n\n\n\t[2, 0, 1]\n\n\t\n\t\tPrefix [2, 0, 1] has inversions (0, 1) and (0, 2).\n\t\tPrefix [2] has 0 inversions.\n\t\n\t\n\t[1, 2, 0]\n\t\n\t\tPrefix [1, 2, 0] has inversions (0, 2) and (1, 2).\n\t\tPrefix [1] has 0 inversions.\n\t\n\t\n\n\n\nExample 2:\n\n\nInput: n = 3, requirements = [[2,2],[1,1],[0,0]]\n\nOutput: 1\n\nExplanation:\n\nThe only satisfying permutation is [2, 0, 1]:\n\n\n\tPrefix [2, 0, 1] has inversions (0, 1) and (0, 2).\n\tPrefix [2, 0] has an inversion (0, 1).\n\tPrefix [2] has 0 inversions.\n\n\n\nExample 3:\n\n\nInput: n = 2, requirements = [[0,0],[1,0]]\n\nOutput: 1\n\nExplanation:\n\nThe only satisfying permutation is [0, 1]:\n\n\n\tPrefix [0] has 0 inversions.\n\tPrefix [0, 1] has an inversion (0, 1).\n\n\n\n \nConstraints:\n\n\n\t2 <= n <= 300\n\t1 <= requirements.length <= n\n\trequirements[i] = [endi, cnti]\n\t0 <= endi <= n - 1\n\t0 <= cnti <= 400\n\tThe input is generated such that there is at least one i such that endi == n - 1.\n\tThe input is generated such that all endi are unique.",
    "function_signature": "class Solution:\n    def numberOfPermutations(self, n: int, requirements: List[List[int]]) -> int:\n        \n"
  },
  "3194": {
    "question_number": "3194",
    "question_title": "Minimum Average of Smallest and Largest Elements is on the run...",
    "question_description": "You have an array of floating point numbers averages which is initially empty. You are given an array nums of n integers where n is even.\n\nYou repeat the following procedure n / 2 times:\n\n\n\tRemove the smallest element, minElement, and the largest element maxElement, from nums.\n\tAdd (minElement + maxElement) / 2 to averages.\n\n\nReturn the minimum element in averages.\n\n \nExample 1:\n\n\nInput: nums = [7,8,3,4,15,13,4,1]\n\nOutput: 5.5\n\nExplanation:\n\n\n\t\n\t\t\n\t\t\tstep\n\t\t\tnums\n\t\t\taverages\n\t\t\n\t\t\n\t\t\t0\n\t\t\t[7,8,3,4,15,13,4,1]\n\t\t\t[]\n\t\t\n\t\t\n\t\t\t1\n\t\t\t[7,8,3,4,13,4]\n\t\t\t[8]\n\t\t\n\t\t\n\t\t\t2\n\t\t\t[7,8,4,4]\n\t\t\t[8,8]\n\t\t\n\t\t\n\t\t\t3\n\t\t\t[7,4]\n\t\t\t[8,8,6]\n\t\t\n\t\t\n\t\t\t4\n\t\t\t[]\n\t\t\t[8,8,6,5.5]\n\t\t\n\t\n\nThe smallest element of averages, 5.5, is returned.\n\nExample 2:\n\n\nInput: nums = [1,9,8,3,10,5]\n\nOutput: 5.5\n\nExplanation:\n\n\n\t\n\t\t\n\t\t\tstep\n\t\t\tnums\n\t\t\taverages\n\t\t\n\t\t\n\t\t\t0\n\t\t\t[1,9,8,3,10,5]\n\t\t\t[]\n\t\t\n\t\t\n\t\t\t1\n\t\t\t[9,8,3,5]\n\t\t\t[5.5]\n\t\t\n\t\t\n\t\t\t2\n\t\t\t[8,5]\n\t\t\t[5.5,6]\n\t\t\n\t\t\n\t\t\t3\n\t\t\t[]\n\t\t\t[5.5,6,6.5]\n\t\t\n\t\n\n\n\nExample 3:\n\n\nInput: nums = [1,2,3,7,8,9]\n\nOutput: 5.0\n\nExplanation:\n\n\n\t\n\t\t\n\t\t\tstep\n\t\t\tnums\n\t\t\taverages\n\t\t\n\t\t\n\t\t\t0\n\t\t\t[1,2,3,7,8,9]\n\t\t\t[]\n\t\t\n\t\t\n\t\t\t1\n\t\t\t[2,3,7,8]\n\t\t\t[5]\n\t\t\n\t\t\n\t\t\t2\n\t\t\t[3,7]\n\t\t\t[5,5]\n\t\t\n\t\t\n\t\t\t3\n\t\t\t[]\n\t\t\t[5,5,5]\n\t\t\n\t\n\n\n\n \nConstraints:\n\n\n\t2 <= n == nums.length <= 50\n\tn is even.\n\t1 <= nums[i] <= 50",
    "function_signature": "class Solution:\n    def minimumAverage(self, nums: List[int]) -> float:\n        \n"
  },
  "3195": {
    "question_number": "3195",
    "question_title": "Find the Minimum Area to Cover All Ones I is on the run...",
    "question_description": "You are given a 2D binary array grid. Find a rectangle with horizontal and vertical sides with the smallest area, such that all the 1's in grid lie inside this rectangle.\n\nReturn the minimum possible area of the rectangle.\n\n \nExample 1:\n\n\nInput: grid = [[0,1,0],[1,0,1]]\n\nOutput: 6\n\nExplanation:\n\n\n\nThe smallest rectangle has a height of 2 and a width of 3, so it has an area of 2 * 3 = 6.\n\n\nExample 2:\n\n\nInput: grid = [[1,0],[0,0]]\n\nOutput: 1\n\nExplanation:\n\n\n\nThe smallest rectangle has both height and width 1, so its area is 1 * 1 = 1.\n\n\n \nConstraints:\n\n\n\t1 <= grid.length, grid[i].length <= 1000\n\tgrid[i][j] is either 0 or 1.\n\tThe input is generated such that there is at least one 1 in grid.",
    "function_signature": "class Solution:\n    def minimumArea(self, grid: List[List[int]]) -> int:\n        \n"
  },
  "3196": {
    "question_number": "3196",
    "question_title": "Maximize Total Cost of Alternating Subarrays is on the run...",
    "question_description": "You are given an integer array nums with length n.\n\nThe cost of a subarray nums[l..r], where 0 <= l <= r < n, is defined as:\n\ncost(l, r) = nums[l] - nums[l + 1] + ... + nums[r] * (−1)r − l\n\nYour task is to split nums into subarrays such that the total cost of the subarrays is maximized, ensuring each element belongs to exactly one subarray.\n\nFormally, if nums is split into k subarrays, where k > 1, at indices i₁, i₂, ..., ik − 1, where 0 <= i₁ < i₂ < ... < ik - 1 < n - 1, then the total cost will be:\n\ncost(0, i₁) + cost(i₁ + 1, i₂) + ... + cost(ik − 1 + 1, n − 1)\n\nReturn an integer denoting the maximum total cost of the subarrays after splitting the array optimally.\n\nNote: If nums is not split into subarrays, i.e. k = 1, the total cost is simply cost(0, n - 1).\n\n \nExample 1:\n\n\nInput: nums = [1,-2,3,4]\n\nOutput: 10\n\nExplanation:\n\nOne way to maximize the total cost is by splitting [1, -2, 3, 4] into subarrays [1, -2, 3] and [4]. The total cost will be (1 + 2 + 3) + 4 = 10.\n\n\nExample 2:\n\n\nInput: nums = [1,-1,1,-1]\n\nOutput: 4\n\nExplanation:\n\nOne way to maximize the total cost is by splitting [1, -1, 1, -1] into subarrays [1, -1] and [1, -1]. The total cost will be (1 + 1) + (1 + 1) = 4.\n\n\nExample 3:\n\n\nInput: nums = [0]\n\nOutput: 0\n\nExplanation:\n\nWe cannot split the array further, so the answer is 0.\n\n\nExample 4:\n\n\nInput: nums = [1,-1]\n\nOutput: 2\n\nExplanation:\n\nSelecting the whole array gives a total cost of 1 + 1 = 2, which is the maximum.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 10⁵\n\t-10⁹ <= nums[i] <= 10⁹",
    "function_signature": "class Solution:\n    def maximumTotalCost(self, nums: List[int]) -> int:\n        \n"
  },
  "3197": {
    "question_number": "3197",
    "question_title": "Find the Minimum Area to Cover All Ones II is on the run...",
    "question_description": "You are given a 2D binary array grid. You need to find 3 non-overlapping rectangles having non-zero areas with horizontal and vertical sides such that all the 1's in grid lie inside these rectangles.\n\nReturn the minimum possible sum of the area of these rectangles.\n\nNote that the rectangles are allowed to touch.\n\n \nExample 1:\n\n\nInput: grid = [[1,0,1],[1,1,1]]\n\nOutput: 5\n\nExplanation:\n\n\n\n\n\tThe 1's at (0, 0) and (1, 0) are covered by a rectangle of area 2.\n\tThe 1's at (0, 2) and (1, 2) are covered by a rectangle of area 2.\n\tThe 1 at (1, 1) is covered by a rectangle of area 1.\n\n\n\nExample 2:\n\n\nInput: grid = [[1,0,1,0],[0,1,0,1]]\n\nOutput: 5\n\nExplanation:\n\n\n\n\n\tThe 1's at (0, 0) and (0, 2) are covered by a rectangle of area 3.\n\tThe 1 at (1, 1) is covered by a rectangle of area 1.\n\tThe 1 at (1, 3) is covered by a rectangle of area 1.\n\n\n\n \nConstraints:\n\n\n\t1 <= grid.length, grid[i].length <= 30\n\tgrid[i][j] is either 0 or 1.\n\tThe input is generated such that there are at least three 1's in grid.",
    "function_signature": "class Solution:\n    def minimumSum(self, grid: List[List[int]]) -> int:\n        \n"
  },
  "3199": {
    "question_number": "3199",
    "question_title": "Count Triplets with Even XOR Set Bits I is on the run...",
    "question_description": "Given three integer arrays a, b, and c, return the number of triplets (a[i], b[j], c[k]), such that the bitwise XOR of the elements of each triplet has an even number of set bits.\n \nExample 1:\n\n\nInput: a = [1], b = [2], c = [3]\n\nOutput: 1\n\nExplanation:\n\nThe only triplet is (a[0], b[0], c[0]) and their XOR is: 1 XOR 2 XOR 3 = 00₂.\n\n\nExample 2:\n\n\nInput: a = [1,1], b = [2,3], c = [1,5]\n\nOutput: 4\n\nExplanation:\n\nConsider these four triplets:\n\n\n\t(a[0], b[1], c[0]): 1 XOR 3 XOR 1 = 011₂\n\t(a[1], b[1], c[0]): 1 XOR 3 XOR 1 = 011₂\n\t(a[0], b[0], c[1]): 1 XOR 2 XOR 5 = 110₂\n\t(a[1], b[0], c[1]): 1 XOR 2 XOR 5 = 110₂\n\n\n\n \nConstraints:\n\n\n\t1 <= a.length, b.length, c.length <= 100\n\t0 <= a[i], b[i], c[i] <= 100",
    "function_signature": "class Solution:\n    def tripletCount(self, a: List[int], b: List[int], c: List[int]) -> int:\n        \n"
  }
}