# Two-Pointer Approach Problem Solving Prompt

## Task Overview
As an experienced software developer, your task is to design and implement a solution in Python 3 for the given coding problem using the two-pointer technique. The following steps should be followed to ensure a comprehensive and correct solution:

### 1. **Analyze the Problem Requirements and Constraints**
   - Thoroughly review the problem's input, output, and constraints.
   - Identify any specific edge cases, such as minimal or extreme values, empty inputs, or other relevant corner cases.
   - Understand the problem's complexity requirements and ensure the solution operates efficiently (typically O(n) for two-pointer solutions).

### 2. **Formulate a Clear Strategy for Pointer Selection**
   - Pointer Initialization: Define where and how to initialize the two pointers. Consider if they start at the beginning of the data structure or elsewhere (e.g., middle, end, etc.).
   - Pointer Movement Logic: Explain how the pointers will move during the solution. Define how the left and right pointers will interact, and why their movement is suitable for the problem at hand.
   - Termination Conditions: Clearly define when the algorithm should stop. This includes when the pointers meet, when a valid condition is met, or when the data has been fully processed.
   - Edge Case Handling: Ensure that the pointers handle all edge cases correctly, such as empty lists, arrays with only one element, or the smallest and largest possible inputs.

### 3. **Time Complexity Consideration**
   - Aim for a solution that runs efficiently within the problem's time complexity constraints, typically O(n) for two-pointer approaches.
   - Provide an analysis of the algorithmâ€™s time complexity and explain why it adheres to the optimal expected performance.

### 4. **Testing and Validation**
   - Sample Case: Start by testing your solution on the provided sample case to verify the basic correctness of the approach.
   - Additional Test Cases:
     - Test with a variety of normal scenarios to ensure the solution handles all cases correctly.
     - Design edge cases that could challenge the logic, such as:
       - Empty input
       - Minimal input
       - Extreme values (e.g., very large or small values)
       - Arrays or lists with duplicate or unique values
   - Step-by-Step Walkthrough: For at least one test case, provide a step-by-step walkthrough of the pointer movements. This should demonstrate the correctness of your approach visually, showing how the pointers change during the execution.

### 5. **Code Review and Refinement**
   - Boundary Conditions: Ensure the pointers never violate boundaries, such as going out of bounds of the data structure.
   - Logic Validation: After implementing the solution, carefully review the code to ensure that the pointer movement logic is correct and all test cases pass.
   - Iterative Refinement: If any component fails (e.g., incorrect edge-case handling or pointer mismanagement), refine the solution iteratively until the implementation is robust and reliable.


